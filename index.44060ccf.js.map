{"mappings":"A,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,I,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,I,E,E,Q,C,E,Q,S,C,C,C,E,E,E,O,C,c,I,G,E,E,O,C,kB,I,G,E,E,O,C,kB,I,G,E,E,O,C,iB,I,G,E,E,O,C,a,I,G,E,E,O,C,kB,I,G,E,E,O,C,c,I,G,E,E,O,C,e,I,G,E,E,O,C,O,I,G,E,E,O,C,c,I,G,E,E,O,C,iB,I,G,E,S,I,E,E,S,E,E,S,E,E,S,E,S,I,E,E,S,E,E,S,E,E,SCKA,IAAM,EAAU,SAAS,aAAa,CAAC,YACjC,EAAkB,IAAI,EAAA,OAAoB,CAEhD,QAAQ,GAAG,CAAC,cACZ,EAAI,UAAU,GAAG,EACjB,IAAM,EAAU,AAAA,EAAA,4BAA2B,CAAE,OAAO,CAEpD,GAAK,EAIH,EAAI,6BAJQ,CACZ,MAAM,wHACN,MACF,CAIA,IAAI,EAAS,KACT,EAAU,KACV,EAAa,KACb,EAAM,KACC,EAAY,KACZ,EAAW,KACX,EAAsB,aAAa,mBAAsB,EAAI,OAsBjE,eAAe,IACpB,MAAM,EAAQ,aAAa,CAAC,CAC1B,QAAS,CACP,CACE,GAAG,EAAA,yBAAwB,CAC3B,SAAU,KACV,UAAW,IACb,EACD,AACH,GACA,MAAM,GACR,CAEO,eAAe,IAUpB,OATA,EAAU,MAAM,EAAQ,UAAU,CAChC,CACE,CACE,GAAG,EAAA,yBAAwB,CAC3B,SAAU,KACV,UAAW,IACb,EACD,CAGL,CAEO,SAAS,EAAgB,CAAM,EAGpC,GADA,QAAQ,GAAG,CADX,EAAS,EAAQ,MAAM,CAAC,AAAA,GAAgB,EAAI,MAAM,EAAI,IAElD,EAAO,MAAM,CAAG,EAAG,CACrB,EAAS,KACT,MACF,CACA,EAAS,CAAM,CAAC,EAAE,CACd,KACF,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E,S,mB,E,E,E,O,C,oB,I,A,E,S,iB,E,E,E,O,C,kB,I,A,E,S,e,E,E,E,O,C,W,I,A,E,S,Q,E,E,E,O,C,qB,I,A,E,S,kB,E,E,E,O,C,kB,I,A,E,S,e,E,E,E,O,C,iB,I,A,E,S,c,E,E,E,O,C,kB,I,A,E,S,e,E,E,E,O,C,iB,I,A,E,S,c,E,E,E,O,C,0B,I,A,E,S,uB,E,E,E,O,C,qB,I,A,E,S,kB,E,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,Q,G,E,Q,S,C,C,C,E,E,E,O,C,0B,I,G,E,S,I,E,E,S,E,E,S,E,E,S,E,E,QGxJK,OAAO,EAGT,CAAA,CAAS,AAAoB,AAC7B,KAAI,UAAJ,CACI,OAAO,IAAI,CAAC,CAAA,CAAS,AACzB,CAEA,CAAA,CAAS,AAA6B,AACtC,KAAI,UAAJ,CACI,OAAO,IAAI,CAAC,CAAA,CAAS,AACzB,CAEA,YACI,CAAgE,CADpE,KAIQ,EAEJ,IAAM,EAAW,IAAI,EAAA,sBAAA,CACjB,IAAI,EAAA,kBAAA,CAA+B,AAAC,IAChC,EAAyB,CAC7B,GAGJ,CAAA,IAAI,CAAC,CAAA,CAAS,CAAG,IAAI,EAAA,cAAA,CAAkB,CACnC,MAAM,KAAK,CAAU,EACjB,GAAI,CACA,IAAM,EAAQ,MAAM,EAAU,GAC9B,EAAW,OAAO,CAAC,EACvB,CAAE,MAAO,EAAG,CAIR,GAAI,aAAa,EAAA,gBAAA,CAAkB,CAC/B,EAAW,KAAK,GAChB,MACJ,CACA,MAAM,CACV,CACJ,EACA,OAAQ,AAAC,GAGE,EAAS,MAAM,CAAC,EAE9B,GAED,IAAI,CAAC,CAAA,CAAS,CAAG,IAAI,EAAA,cAAA,CAAe,CAChC,MAAM,MAAM,CAAK,EACb,MAAM,EAAuB,OAAO,CAAC,EACzC,EACA,QACI,EAAuB,KAAK,EAChC,EACA,QACI,EAAuB,KAAK,EAChC,CACH,EACL,CACH,C,G,E,Q,S,C,C,C,E,E,E,O,C,0B,I,A,E,S,uB,E,E,E,O,C,S,I,A,E,S,M,E,E,E,O,C,mB,I,A,E,S,gB,E,E,E,O,C,c,I,A,E,S,W,E,E,E,O,C,oB,I,A,E,S,iB,E,E,E,O,C,a,I,A,E,S,U,E,E,E,O,C,a,I,A,E,S,U,E,E,E,O,C,c,I,A,E,S,W,E,E,E,O,C,U,I,A,E,S,M,E,E,S,E,S,E,S,E,S,E,Q,G,E,Q,S,C,C,C,E,E,E,O,C,wB,I,A,E,S,qB,E,E,E,O,C,mB,I,A,E,S,gB,E,E,E,O,C,uB,I,A,E,S,oB,E,E,E,O,C,0B,I,A,E,S,uB,E,E,E,O,C,oB,I,A,E,S,iB,E,E,E,O,C,sB,I,A,E,S,mB,E,E,E,O,C,c,I,A,E,S,W,E,E,S,E,S,E,S,E,S,E,Q,G,E,Q,S,C,C,C,E,E,E,O,C,wB,I,EI1DK,OAAgB,EAST,MAAgB,AAMhB,CAAA,YAA4B,AAE5B,CAAA,OAAkB,AAE3B,aAAY,CAAiB,CAA7B,CACI,IAAI,CAAC,OAAO,CAAG,CACnB,CAkCH,C,G,E,Q,S,C,C,C,E,E,E,O,C,mB,I,EEzDK,OAAgB,EAIT,UAAwB,AAGxB,CAAA,OAAiC,AAGjC,CAAA,MAAoB,AAE7B,KAAI,oBAAJ,CACI,OACI,IAAI,CAAC,GAAG,GAAK,EAAiB,SAAS,CAAC,GAAG,EAC3C,IAAI,CAAC,GAAG,GAAK,EAAiB,SAAS,CAAC,GAAG,AAEnD,CAEU,KAA6B,AAEvC,aACI,CAAuB,CACvB,CAAgC,CAChC,CAAmB,CACnB,CAA4B,CAJhC,CAMI,IAAI,CAAC,UAAU,CAAG,EAClB,IAAI,CAAC,OAAO,CAAG,EACf,IAAI,CAAC,MAAM,CAAG,EACd,IAAI,CAAC,KAAK,CAAG,CACjB,CAOA,SAAA,CACI,OAAO,IAAI,CAAC,UAAU,CAAC,OAAO,EAClC,CAKA,KAAA,CACI,OAAO,IAAI,CAAC,KAAc,AAC9B,CAKA,IAAI,CAA4B,CAAhC,CACI,IAAI,CAAC,KAAK,CAAG,CACjB,CAUH,C,G,E,Q,S,C,C,C,E,E,E,O,C,uB,I,GE1DM,IAAM,EAAgD,CACzD,aAAc,CAAA,CACjB,C,G,E,Q,S,C,C,C,E,E,E,O,C,0B,I,EEdK,OAAO,UAAgC,MACzC,aAAA,CACI,KAAK,CAAC,uBACN,OAAO,cAAc,CAAC,IAAI,CAAE,WAAW,SAAS,CACp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AAkB,AAE3B,aAAY,CAAiB,CAAE,CAAgC,CAA/D,CAEI,KAAK,GACL,IAAI,CAAC,OAAO,CAAG,CACnB,CAEA,SAAA,CACI,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,AAC5B,CAEA,OACI,CAAgC,CAChC,CAAmB,CACnB,CAAsB,CAH1B,CAKI,OAAO,IAAI,EAAiB,IAAI,CAAE,EAAS,EAAQ,EACvD,CAYS,YACL,CAAgC,CAChC,CAA0C,CAC1C,CAAmB,CAHd,CAKL,MAAO,AAAA,CAAA,EAAA,EAAA,WAAA,AAAA,EAAY,GAAG,CAAC,IACZ,EAAO,WAAW,CAAC,IAAI,CAAC,OAAO,KAErC,IAAI,CAAC,AAAC,IACH,IAAM,EAAQ,IAAI,CAAC,OAAO,CAAC,WAAW,CAClC,EACA,EACA,EAAQ,YAAY,EAExB,OAAO,IAAI,CAAC,MAAM,CAAC,EAAS,EAAQ,EACxC,GACC,cAAc,EACvB,CACH,CAEK,MAAO,UAEH,EAAA,gBAAA,CACG,UACL,CAAkB,CAClB,CAAiB,CACjB,CAAc,CAHT,CAKL,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,SAAS,CAC7B,EACA,EACA,IAAI,CAAC,KAAc,CACnB,IAAI,CAAC,OAAO,CAAC,YAAY,CAEjC,CACH,C,G,E,Q,S,C,C,C,E,E,E,O,C,W,I,A,E,S,Q,E,E,E,O,C,W,I,A,E,S,Q,E,E,E,O,C,W,I,A,E,S,Q,E,E,E,O,C,W,I,A,E,S,Q,E,E,E,O,C,oB,I,A,E,S,iB,E,E,E,O,C,uB,I,A,E,S,oB,E,E,E,O,C,U,I,A,E,S,O,E,E,E,O,C,Y,I,A,E,S,S,E,E,E,O,C,Y,I,A,E,S,S,E,E,E,O,C,wB,I,A,E,S,qB,E,E,E,O,C,wB,I,A,E,S,qB,E,E,E,O,C,Y,I,A,E,S,S,E,E,E,O,C,qB,I,A,E,S,kB,E,E,E,O,C,wB,I,A,E,S,qB,E,E,E,O,C,Y,I,A,E,S,S,E,E,S,E,S,E,S,E,S,E,S,E,S,E,Q,G,E,Q,S,C,C,C,E,E,E,O,C,W,I,GGhHK,SAAU,EACZ,CAAkB,CAClB,CAAc,CACd,CAAqB,EAErB,OAAO,EACD,AAAE,CAAA,CAAM,CAAC,EAAQ,CA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I,A,E,S,0B,E,E,E,O,C,Y,I,A,E,S,S,E,E,E,O,C,U,I,A,E,S,O,E,E,E,O,C,kB,I,A,E,S,e,E,E,S,E,S,E,S,E,S,E,S,E,S,E,Q,G,E,Q,S,C,C,C,E,E,E,O,C,iB,I,G,E,S,I,E,E,QGnFK,OAAO,UAAuB,EAAA,cAAA,CACtB,GAAS,AAEnB,aAAY,CAAQ,CAApB,CACI,KAAK,GACL,IAAI,CAAC,GAAG,CAAG,CACf,CACH,C,G,E,Q,S,C,C,C,E,E,E,O,C,iB,I,A,E,S,c,E,E,S,E,S,E,S,E,Q,G,E,Q,S,C,C,C,E,E,E,O,C,iB,I,EGPK,OAAO,EACT,CAAA,CAAY,CAAiB,EAAE,AAAC,AAEhC,cAAA,CACI,IAAI,CAAC,OAAO,CAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CACzC,CAEU,cAAoC,CAAa,CAAjD,CAEN,OADA,IAAI,CAAC,CAAA,CAAY,CAAC,IAAI,CAAC,GAChB,CACX,CAEA,SAAA,CACI,IAAK,IAAM,KAAc,IAAI,CAAC,CAAA,CAAY,CACtC,EAAW,OAAO,EAGtB,CAAA,IAAI,CAAC,CAAA,CAAY,CAAG,EAAE,AAC1B,CACH,C,G,E,Q,S,C,C,C,E,G,E,Q,S,C,C,C,E,G,E,Q,S,C,C,C,E,E,S,E,Q,G,E,Q,S,C,C,C,E,E,E,O,C,c,I,G,E,S,I,E,E,S,E,S,I,E,E,SOlBD,IAAM,EAAU,GAAI,CAAA,EAAA,EAAA,MAAA,AAAA,EAAO,CAAE,aAAc,CAAA,CAAI,GAAI,MAAM,CAAC,WAE7C,EAAmB,GAAI,CAAA,EAAA,EAAA,MAAA,AAAA,EAAO,CAAE,aAAc,CAAA,CAAI,GAC1D,MAAM,CAAC,OACP,MAAM,CAAC,QACP,MAAM,CAAC,SACP,MAAM,CAAC,UACP,MAAM,CAAC,cACP,MAAM,CAAC,cACP,MAAM,CAAC,eACP,MAAM,CAAC,eACP,MAAM,CAAC,gBACP,MAAM,CAAC,gBACP,MAAM,CAAC,gBACP,MAAM,CAAC,gBACP,UAAU,CAAC,OAAQ,CAAE,YAAa,MAAM,GAIhC,EAAmB,GAAI,CAAA,EAAA,EAAA,MAAA,AAAA,EAAO,CAAE,aAAc,CAAA,C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","sources":["<anon>","src/js/common.js","node_modules/@yume-chan/adb-daemon-webusb/src/index.ts","node_modules/@yume-chan/adb-daemon-webusb/esm/device.js","node_modules/@yume-chan/adb-daemon-webusb/src/device.ts","node_modules/@yume-chan/adb/src/index.ts","node_modules/@yume-chan/adb/esm/adb.js","node_modules/@yume-chan/adb/src/adb.ts","node_modules/@yume-chan/stream-extra/src/index.ts","node_modules/@yume-chan/stream-extra/esm/buffered-transform.js","node_modules/@yume-chan/stream-extra/src/buffered-transform.ts","node_modules/@yume-chan/struct/src/index.ts","node_modules/@yume-chan/struct/src/basic/index.ts","node_modules/@yume-chan/struct/esm/basic/definition.js","node_modules/@yume-chan/struct/src/basic/definition.ts","node_modules/@yume-chan/struct/esm/basic/field-value.js","node_modules/@yume-chan/struct/src/basic/field-value.ts","node_modules/@yume-chan/struct/esm/basic/options.js","node_modules/@yume-chan/struct/src/basic/options.ts","node_modules/@yume-chan/struct/esm/basic/stream.js","node_modules/@yume-chan/struct/src/basic/stream.ts","node_modules/@yume-chan/struct/esm/basic/struct-value.js","node_modules/@yume-chan/struct/src/basic/struct-value.ts","node_modules/@yume-chan/struct/esm/struct.js","node_modules/@yume-chan/struct/src/struct.ts","node_modules/@yume-chan/struct/esm/sync-promise.js","node_modules/@yume-chan/struct/src/sync-promise.ts","node_modules/@yume-chan/struct/src/types/index.ts","node_modules/@yume-chan/struct/esm/types/bigint.js","node_modules/@yume-chan/struct/src/types/bigint.ts","node_modules/@yume-chan/no-data-view/src/index.ts","node_modules/@yume-chan/no-data-view/esm/int16.js","node_modules/@yume-chan/no-data-view/src/int16.ts","node_modules/@yume-chan/no-data-view/esm/int32.js","node_modules/@yume-chan/no-data-view/src/int32.ts","node_modules/@yume-chan/no-data-view/esm/int64.js","node_modules/@yume-chan/no-data-view/src/int64.ts","node_modules/@yume-chan/no-data-view/esm/int8.js","node_modules/@yume-chan/no-data-view/src/int8.ts","node_modules/@yume-chan/no-data-view/esm/uint16.js","node_modules/@yume-chan/no-data-view/src/uint16.ts","node_modules/@yume-chan/no-data-view/esm/uint32.js","node_modules/@yume-chan/no-data-view/src/uint32.ts","node_modules/@yume-chan/no-data-view/esm/uint64.js","node_modules/@yume-chan/no-data-view/src/uint64.ts","node_modules/@yume-chan/struct/src/types/buffer/index.ts","node_modules/@yume-chan/struct/esm/types/buffer/base.js","node_modules/@yume-chan/struct/src/types/buffer/base.ts","node_modules/@yume-chan/struct/esm/utils.js","node_modules/@yume-chan/struct/src/utils.ts","node_modules/@yume-chan/struct/esm/types/buffer/fixed-length.js","node_modules/@yume-chan/struct/src/types/buffer/fixed-length.ts","node_modules/@yume-chan/struct/esm/types/buffer/variable-length.js","node_modules/@yume-chan/struct/src/types/buffer/variable-length.ts","node_modules/@yume-chan/struct/esm/types/number.js","node_modules/@yume-chan/struct/src/types/number.ts","node_modules/@yume-chan/stream-extra/esm/buffered.js","node_modules/@yume-chan/stream-extra/src/buffered.ts","node_modules/@yume-chan/stream-extra/esm/push-readable.js","node_modules/@yume-chan/stream-extra/src/push-readable.ts","node_modules/@yume-chan/async/src/index.ts","node_modules/@yume-chan/async/esm/async-operation-manager.js","node_modules/@yume-chan/async/src/async-operation-manager.ts","node_modules/@yume-chan/async/esm/promise-resolver.js","node_modules/@yume-chan/async/src/promise-resolver.ts","node_modules/@yume-chan/async/esm/delay.js","node_modules/@yume-chan/async/src/delay.ts","node_modules/@yume-chan/stream-extra/esm/stream.js","node_modules/@yume-chan/stream-extra/src/stream.ts","node_modules/@yume-chan/stream-extra/esm/types.js","node_modules/@yume-chan/stream-extra/src/types.ts","node_modules/@yume-chan/stream-extra/esm/concat.js","node_modules/@yume-chan/stream-extra/src/concat.ts","node_modules/@yume-chan/stream-extra/esm/consumable.js","node_modules/@yume-chan/stream-extra/src/consumable.ts","node_modules/@yume-chan/stream-extra/esm/task.js","node_modules/@yume-chan/stream-extra/src/task.ts","node_modules/@yume-chan/stream-extra/esm/distribution.js","node_modules/@yume-chan/stream-extra/src/distribution.ts","node_modules/@yume-chan/stream-extra/esm/maybe-consumable.js","node_modules/@yume-chan/stream-extra/src/maybe-consumable.ts","node_modules/@yume-chan/stream-extra/esm/duplex.js","node_modules/@yume-chan/stream-extra/src/duplex.ts","node_modules/@yume-chan/stream-extra/esm/wrap-readable.js","node_modules/@yume-chan/stream-extra/src/wrap-readable.ts","node_modules/@yume-chan/stream-extra/esm/encoding.js","node_modules/@yume-chan/stream-extra/src/encoding.ts","node_modules/@yume-chan/stream-extra/esm/inspect.js","node_modules/@yume-chan/stream-extra/src/inspect.ts","node_modules/@yume-chan/stream-extra/esm/pipe-from.js","node_modules/@yume-chan/stream-extra/src/pipe-from.ts","node_modules/@yume-chan/stream-extra/esm/split-string.js","node_modules/@yume-chan/stream-extra/src/split-string.ts","node_modules/@yume-chan/stream-extra/esm/struct-deserialize.js","node_modules/@yume-chan/stream-extra/src/struct-deserialize.ts","node_modules/@yume-chan/stream-extra/esm/struct-serialize.js","node_modules/@yume-chan/stream-extra/src/struct-serialize.ts","node_modules/@yume-chan/stream-extra/esm/wrap-writable.js","node_modules/@yume-chan/stream-extra/src/wrap-writable.ts","node_modules/@yume-chan/adb/src/commands/index.ts","node_modules/@yume-chan/adb/esm/commands/base.js","node_modules/@yume-chan/adb/src/commands/base.ts","node_modules/@yume-chan/event/src/index.ts","node_modules/@yume-chan/event/esm/disposable.js","node_modules/@yume-chan/event/src/disposable.ts","node_modules/@yume-chan/event/src/event.ts","node_modules/@yume-chan/event/esm/event-emitter.js","node_modules/@yume-chan/event/src/event-emitter.ts","node_modules/@yume-chan/event/esm/utils.js","node_modules/@yume-chan/event/src/utils.ts","node_modules/@yume-chan/adb/esm/commands/framebuffer.js","node_modules/@yume-chan/adb/src/commands/framebuffer.ts","node_modules/@yume-chan/adb/esm/commands/power.js","node_modules/@yume-chan/adb/src/commands/power.ts","node_modules/@yume-chan/adb/esm/commands/reverse.js","node_modules/@yume-chan/adb/src/commands/reverse.ts","node_modules/@yume-chan/adb/src/utils/index.ts","node_modules/@yume-chan/adb/esm/utils/auto-reset-event.js","node_modules/@yume-chan/adb/src/utils/auto-reset-event.ts","node_modules/@yume-chan/adb/esm/utils/base64.js","node_modules/@yume-chan/adb/src/utils/base64.ts","node_modules/@yume-chan/adb/esm/utils/hex.js","node_modules/@yume-chan/adb/src/utils/hex.ts","node_modules/@yume-chan/adb/esm/utils/no-op.js","node_modules/@yume-chan/adb/src/utils/no-op.ts","node_modules/@yume-chan/adb/esm/utils/sequence-equal.js","node_modules/@yume-chan/adb/src/utils/sequence-equal.ts","node_modules/@yume-chan/adb/src/commands/subprocess/index.ts","node_modules/@yume-chan/adb/esm/commands/subprocess/command.js","node_modules/@yume-chan/adb/src/commands/subprocess/command.ts","node_modules/@yume-chan/adb/src/commands/subprocess/protocols/index.ts","node_modules/@yume-chan/adb/esm/commands/subprocess/protocols/none.js","node_modules/@yume-chan/adb/src/commands/subprocess/protocols/none.ts","node_modules/@yume-chan/adb/esm/commands/subprocess/protocols/shell.js","node_modules/@yume-chan/adb/src/commands/subprocess/protocols/shell.ts","node_modules/@yume-chan/adb/esm/features.js","node_modules/@yume-chan/adb/src/features.ts","node_modules/@yume-chan/adb/src/commands/subprocess/protocols/types.ts","node_modules/@yume-chan/adb/esm/commands/subprocess/utils.js","node_modules/@yume-chan/adb/src/commands/subprocess/utils.ts","node_modules/@yume-chan/adb/src/commands/sync/index.ts","node_modules/@yume-chan/adb/esm/commands/sync/list.js","node_modules/@yume-chan/adb/src/commands/sync/list.ts","node_modules/@yume-chan/adb/esm/commands/sync/request.js","node_modules/@yume-chan/adb/src/commands/sync/request.ts","node_modules/@yume-chan/adb/esm/commands/sync/response.js","node_modules/@yume-chan/adb/src/commands/sync/response.ts","node_modules/@yume-chan/adb/esm/commands/sync/stat.js","node_modules/@yume-chan/adb/src/commands/sync/stat.ts","node_modules/@yume-chan/adb/esm/commands/sync/pull.js","node_modules/@yume-chan/adb/src/commands/sync/pull.ts","node_modules/@yume-chan/adb/esm/commands/sync/push.js","node_modules/@yume-chan/adb/src/commands/sync/push.ts","node_modules/@yume-chan/adb/esm/commands/sync/socket.js","node_modules/@yume-chan/adb/src/commands/sync/socket.ts","node_modules/@yume-chan/adb/esm/commands/sync/sync.js","node_modules/@yume-chan/adb/src/commands/sync/sync.ts","node_modules/@yume-chan/adb/esm/commands/tcpip.js","node_modules/@yume-chan/adb/src/commands/tcpip.ts","node_modules/@yume-chan/adb/esm/banner.js","node_modules/@yume-chan/adb/src/banner.ts","node_modules/@yume-chan/adb/src/daemon/index.ts","node_modules/@yume-chan/adb/esm/daemon/auth.js","node_modules/@yume-chan/adb/src/daemon/auth.ts","node_modules/@yume-chan/adb/esm/daemon/crypto.js","node_modules/@yume-chan/adb/src/daemon/crypto.ts","node_modules/@yume-chan/adb/esm/daemon/packet.js","node_modules/@yume-chan/adb/src/daemon/packet.ts","node_modules/@yume-chan/adb/src/daemon/device.ts","node_modules/@yume-chan/adb/esm/daemon/dispatcher.js","node_modules/@yume-chan/adb/src/daemon/dispatcher.ts","node_modules/@yume-chan/adb/esm/daemon/socket.js","node_modules/@yume-chan/adb/src/daemon/socket.ts","node_modules/@yume-chan/adb/esm/daemon/transport.js","node_modules/@yume-chan/adb/src/daemon/transport.ts","node_modules/@yume-chan/adb/src/server/index.ts","node_modules/@yume-chan/adb/esm/server/client.js","node_modules/@yume-chan/adb/src/server/client.ts","node_modules/@yume-chan/adb/esm/server/transport.js","node_modules/@yume-chan/adb/src/server/transport.ts","node_modules/@yume-chan/adb-daemon-webusb/esm/utils.js","node_modules/@yume-chan/adb-daemon-webusb/src/utils.ts","node_modules/@yume-chan/adb-daemon-webusb/esm/manager.js","node_modules/@yume-chan/adb-daemon-webusb/src/manager.ts","node_modules/@yume-chan/adb-daemon-webusb/esm/watcher.js","node_modules/@yume-chan/adb-daemon-webusb/src/watcher.ts","node_modules/@yume-chan/adb-credential-web/esm/index.js","node_modules/@yume-chan/adb-credential-web/src/index.ts"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire75f2\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire75f2\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"h6ark\", function(module, exports) {\n\n$parcel$export(module.exports, \"pair_device\", () => pair_device);\n$parcel$export(module.exports, \"select_existing\", () => select_existing);\n$parcel$export(module.exports, \"get_autoconnect\", () => get_autoconnect);\n$parcel$export(module.exports, \"connect_device\", () => connect_device);\n$parcel$export(module.exports, \"disconnect\", () => disconnect);\n$parcel$export(module.exports, \"set_autoconnect\", () => set_autoconnect);\n$parcel$export(module.exports, \"monitor_usb\", () => monitor_usb);\n$parcel$export(module.exports, \"exploit_gabb\", () => exploit_gabb);\n$parcel$export(module.exports, \"godo\", () => godo);\n$parcel$export(module.exports, \"install_app\", () => install_app);\n$parcel$export(module.exports, \"send_to_device\", () => send_to_device);\nparcelRequire(\"iuptw\");\nvar $dGdCH = parcelRequire(\"dGdCH\");\nvar $aI8PJ = parcelRequire(\"aI8PJ\");\n\nvar $jhyqS = parcelRequire(\"jhyqS\");\nparcelRequire(\"27oor\");\nvar $4uv4T = parcelRequire(\"4uv4T\");\nvar $aIHw7 = parcelRequire(\"aIHw7\");\nvar $23OH0 = parcelRequire(\"23OH0\");\nconst konsole = document.querySelector(\"#konsole\");\nconst CredentialStore = new (0, $jhyqS.default)();\nconsole.log(\"hi friend!\");\nlog(navigator.usb);\nconst Manager = (0, $aI8PJ.AdbDaemonWebUsbDeviceManager).BROWSER;\nif (!Manager) {\n    alert(\"WebUSB is not supported in this browser!\\nWe need WebUSB in order to function.\\nPlease try again with Google Chrome.\");\n    return;\n} else log(\"Yay, you have WebUSB!\");\nlet device = null;\nlet devices = null;\nlet connection = null;\nlet adb = null;\nlet onmonitor = null;\nlet dev_list = null;\nlet autoconnect_enabled = localStorage[\"autoconnect_enabled\"] || \"true\";\nfunction is_device() {\n    return !!device;\n}\nfunction is_connected() {\n    return !!connection;\n}\nasync function pair_device() {\n    await Manager.requestDevice({\n        filters: [\n            {\n                ...(0, $dGdCH.ADB_DEFAULT_DEVICE_FILTER),\n                vendorId: 0x19D2,\n                productId: 0x0452\n            }\n        ]\n    });\n    await autoconnect();\n}\nasync function list_existing() {\n    devices = await Manager.getDevices([\n        {\n            ...(0, $dGdCH.ADB_DEFAULT_DEVICE_FILTER),\n            vendorId: 0x19D2,\n            productId: 0x0452\n        }\n    ]);\n    return devices;\n}\nfunction select_existing(serial) {\n    device = devices.filter((dev)=>{\n        return dev.serial == serial;\n    });\n    console.log(device);\n    if (device.length < 1) {\n        device = null;\n        return;\n    }\n    device = device[0];\n    if (get_autoconnect()) connect_device();\n}\nasync function disconnect() {\n    if (!device) {\n        log(\"No device connected!\");\n        return;\n    }\n    try {\n        await adb.close();\n    } catch (e) {\n        log(\"Error when closing adb\");\n        console.error(e);\n    }\n    log(\"ADB session closed\");\n    adb = null;\n    try {\n        await device.raw.close();\n    } catch (e) {\n        log(\"Error when closing connection\");\n        console.error(e);\n    }\n    log(\"Connection closed\");\n    connection = null;\n    device = null;\n    if (dev_list) await draw_device_list();\n    if (onmonitor) onmonitor();\n}\nasync function autoconnect() {\n    await list_existing();\n    if (device && devices.filter((dev)=>{\n        return dev.serial == device.serial;\n    }).length < 1) device = null;\n    console.log(devices);\n    // if (devices.length == 0) return [];\n    if (!device && get_autoconnect() && devices.length > 0) {\n        device = devices[0];\n        await connect_device();\n        if (onmonitor) onmonitor();\n    }\n    if (dev_list) await draw_device_list();\n    return devices;\n}\nfunction set_autoconnect(val) {\n    val = \"\" + val;\n    autoconnect_enabled = val;\n    localStorage[\"autoconnect_enabled\"] = val;\n}\nfunction get_autoconnect() {\n    return autoconnect_enabled == \"true\";\n}\nfunction monitor_usb(dev_list_p, onmonitor_p) {\n    dev_list = dev_list_p;\n    onmonitor = onmonitor_p;\n    navigator.usb.addEventListener(\"connect\", ()=>{\n        log(\"Connect event received, updating devices...\");\n        autoconnect();\n    });\n    navigator.usb.addEventListener(\"disconnect\", ()=>{\n        log(\"Disconnect event received, updating devices...\");\n        autoconnect();\n    });\n    log(\"Checking devices due to start...\");\n    autoconnect();\n}\nasync function draw_device_list() {\n    const list_elem = dev_list;\n    if (!devices) await list_existing();\n    // log(devices.toString());\n    list_elem.innerHTML = `<option value=\"null\">No device</option>`;\n    for (const dev of devices){\n        const opt = document.createElement(\"option\");\n        opt.textContent = `${dev.raw.productName}\\t${dev.raw.manufacturerName}\\t${dev.serial}`;\n        opt.value = dev.serial;\n        list_elem.appendChild(opt);\n    }\n    if (device) list_elem.value = device.serial;\n    else list_elem.value = \"null\";\n}\nasync function connect_device() {\n    console.log(\"connect dev\");\n    if (!device) {\n        console.log(\"Device is null\");\n        alert(\"Device is null\");\n        return;\n    }\n    connection = await device.connect();\n    log(\"Device connection opened...\");\n    const transport = await (0, $aIHw7.AdbDaemonTransport).authenticate({\n        serial: device.serial,\n        connection: connection,\n        credentialStore: CredentialStore\n    });\n    log(\"ADB transport opened...\");\n    adb = new (0, $4uv4T.Adb)(transport);\n    log(\"ADB connection created!\");\n    // console.log(adb);\n    log(\"Android version: \" + await adb.getProp(\"ro.build.version.release\"));\n    if (onmonitor) onmonitor();\n}\nasync function exploit_gabb() {\n    let res = null;\n    await godo(\"am switch-user 0\");\n    res = await godo(\"pm list users\");\n    const mmus = res.stdout.matchAll(/(?<uid>\\d+):MaintenanceModeUser:/g);\n    for (const mmu of mmus)if (mmu.groups.uid) await godo(\"pm remove-user \" + mmu.groups.uid);\n    await godo(\"pm disable-user --user 0 com.gabb.packageupdater\");\n    log(\"Exploited (if no errors above, lol)!\");\n}\nasync function install_app(file, user) {\n    if (!user) user = \"current\";\n    //const file_input = document.querySelector(\"#apk\");\n    //const file = file_input.files[0];\n    log(\"Acquiring sync...\");\n    const sync = await adb.sync();\n    log(\"Sending APK...\");\n    await sync.write({\n        filename: \"/data/local/tmp/temp.apk\",\n        file: file.stream()\n    });\n    sync.dispose();\n    log(\"APK sent!\");\n    let res = null;\n    log(\"Installing...\");\n    res = await godo(\"pm install-create --user \" + user);\n    const session = res.stdout.split(\"[\")[1].split(\"]\")[0];\n    await godo(`pm install-write ${session} tomato /data/local/tmp/temp.apk`);\n    await godo(`pm install-commit ${session}`);\n    await adb.rm(\"/data/local/tmp/temp.apk\");\n}\nasync function send_command_and_get_response(command, ignore_errors, silence_logs) {\n    const process = await adb.subprocess.spawnAndWait(command, {\n        protocols: [\n            (0, $23OH0.AdbSubprocessShellProtocol)\n        ]\n    });\n    if (process.stderr) {\n        if (!silence_logs) log(process.stderr);\n        if (!ignore_errors) throw process.stderr;\n    }\n    if (!silence_logs) log(process.stdout);\n    return process;\n}\nasync function send_to_device(file) {\n    log(\"Acquiring sync...\");\n    const sync = await adb.sync();\n    log(\"Sending...\");\n    await sync.write({\n        filename: \"/sdcard/Download/\" + file.name,\n        file: file.stream()\n    });\n    await sync.dispose();\n    log(\"Sent!\");\n}\nconst godo = send_command_and_get_response;\nfunction log(msg) {\n    if (konsole) {\n        konsole.textContent += `[${new Date().toLocaleString()}] ${msg}\\n`;\n        konsole.scrollTo(0, konsole.scrollHeight);\n    } else console.log(msg);\n    return msg;\n}\n\n});\nparcelRegister(\"iuptw\", function(module, exports) {\n$parcel$export(module.exports, \"ADB_DEFAULT_DEVICE_FILTER\", () => (parcelRequire(\"dGdCH\")).ADB_DEFAULT_DEVICE_FILTER);\n$parcel$export(module.exports, \"AdbDaemonWebUsbDeviceManager\", () => (parcelRequire(\"aI8PJ\")).AdbDaemonWebUsbDeviceManager);\nparcelRequire(\"dGdCH\");\nparcelRequire(\"aI8PJ\");\nparcelRequire(\"byTpg\");\nparcelRequire(\"7wgv6\");\n\n});\nparcelRegister(\"dGdCH\", function(module, exports) {\n\n$parcel$export(module.exports, \"ADB_DEFAULT_DEVICE_FILTER\", () => $9f59c3e3ec39e929$export$83dac9bc96800be2);\n$parcel$export(module.exports, \"AdbDaemonWebUsbDevice\", () => $9f59c3e3ec39e929$export$b4df074ec7ed7a36);\nparcelRequire(\"27oor\");\nvar $2lmjj = parcelRequire(\"2lmjj\");\nvar $fXuIk = parcelRequire(\"fXuIk\");\nparcelRequire(\"7edQJ\");\nvar $bwQFm = parcelRequire(\"bwQFm\");\nvar $jEctC = parcelRequire(\"jEctC\");\nvar $3Ppgt = parcelRequire(\"3Ppgt\");\nvar $6NYMu = parcelRequire(\"6NYMu\");\nparcelRequire(\"hr1EK\");\nvar $j4unN = parcelRequire(\"j4unN\");\n\nvar $byTpg = parcelRequire(\"byTpg\");\nconst $9f59c3e3ec39e929$export$83dac9bc96800be2 = {\n    classCode: 0xff,\n    subclassCode: 0x42,\n    protocolCode: 1\n};\n/**\n * Find the first pair of input and output endpoints from an alternate interface.\n *\n * ADB interface only has two endpoints, one for input and one for output.\n */ function $9f59c3e3ec39e929$var$findUsbEndpoints(endpoints) {\n    if (endpoints.length === 0) throw new TypeError(\"No endpoints given\");\n    let inEndpoint;\n    let outEndpoint;\n    for (const endpoint of endpoints)switch(endpoint.direction){\n        case \"in\":\n            inEndpoint = endpoint;\n            if (outEndpoint) return {\n                inEndpoint: inEndpoint,\n                outEndpoint: outEndpoint\n            };\n            break;\n        case \"out\":\n            outEndpoint = endpoint;\n            if (inEndpoint) return {\n                inEndpoint: inEndpoint,\n                outEndpoint: outEndpoint\n            };\n            break;\n    }\n    if (!inEndpoint) throw new TypeError(\"No input endpoint found.\");\n    if (!outEndpoint) throw new TypeError(\"No output endpoint found.\");\n    throw new Error(\"unreachable\");\n}\nclass $9f59c3e3ec39e929$var$Uint8ArrayExactReadable {\n    #data;\n    #position;\n    get position() {\n        return this.#position;\n    }\n    constructor(data){\n        this.#data = data;\n        this.#position = 0;\n    }\n    readExactly(length) {\n        const result = this.#data.subarray(this.#position, this.#position + length);\n        this.#position += length;\n        return result;\n    }\n}\nclass $9f59c3e3ec39e929$export$d762018b8d06af13 {\n    #device;\n    get device() {\n        return this.#device;\n    }\n    #inEndpoint;\n    get inEndpoint() {\n        return this.#inEndpoint;\n    }\n    #outEndpoint;\n    get outEndpoint() {\n        return this.#outEndpoint;\n    }\n    #readable;\n    get readable() {\n        return this.#readable;\n    }\n    #writable;\n    get writable() {\n        return this.#writable;\n    }\n    constructor(device, inEndpoint, outEndpoint, usbManager){\n        this.#device = device;\n        this.#inEndpoint = inEndpoint;\n        this.#outEndpoint = outEndpoint;\n        let closed1 = false;\n        const duplex = new (0, $bwQFm.DuplexStreamFactory)({\n            close: async ()=>{\n                try {\n                    closed1 = true;\n                    await device.raw.close();\n                } catch  {\n                /* device may have already disconnected */ }\n            },\n            dispose: ()=>{\n                closed1 = true;\n                usbManager.removeEventListener(\"disconnect\", handleUsbDisconnect);\n            }\n        });\n        function handleUsbDisconnect(e) {\n            if (e.device === device.raw) duplex.dispose().catch((0, $fXuIk.unreachable));\n        }\n        usbManager.addEventListener(\"disconnect\", handleUsbDisconnect);\n        this.#readable = duplex.wrapReadable(new (0, $6NYMu.ReadableStream)({\n            pull: async (controller)=>{\n                const packet = await this.#transferIn();\n                if (packet) controller.enqueue(packet);\n                else controller.close();\n            }\n        }, {\n            highWaterMark: 0\n        }));\n        const zeroMask = outEndpoint.packetSize - 1;\n        this.#writable = (0, $3Ppgt.pipeFrom)(duplex.createWritable(new (0, $jEctC.MaybeConsumable).WritableStream({\n            write: async (chunk)=>{\n                try {\n                    await device.raw.transferOut(outEndpoint.endpointNumber, chunk);\n                    // In USB protocol, a not-full packet indicates the end of a transfer.\n                    // If the payload size is a multiple of the packet size,\n                    // we need to send an empty packet to indicate the end,\n                    // so the OS will send it to the device immediately.\n                    if (zeroMask && (chunk.length & zeroMask) === 0) await device.raw.transferOut(outEndpoint.endpointNumber, (0, $j4unN.EMPTY_UINT8_ARRAY));\n                } catch (e) {\n                    if (closed1) return;\n                    throw e;\n                }\n            }\n        })), new (0, $2lmjj.AdbPacketSerializeStream)());\n    }\n    async #transferIn() {\n        try {\n            while(true){\n                // ADB daemon sends each packet in two parts, the 24-byte header and the payload.\n                const result = await this.#device.raw.transferIn(this.#inEndpoint.endpointNumber, this.#inEndpoint.packetSize);\n                if (result.data.byteLength !== 24) continue;\n                // Per spec, the `result.data` always covers the whole `buffer`.\n                const buffer = new Uint8Array(result.data.buffer);\n                const stream = new $9f59c3e3ec39e929$var$Uint8ArrayExactReadable(buffer);\n                // Add `payload` field to its type, it's assigned below.\n                const packet = (0, $2lmjj.AdbPacketHeader).deserialize(stream);\n                if (packet.magic !== (packet.command ^ 0xffffffff)) continue;\n                if (packet.payloadLength !== 0) {\n                    const result = await this.#device.raw.transferIn(this.#inEndpoint.endpointNumber, packet.payloadLength);\n                    packet.payload = new Uint8Array(result.data.buffer);\n                } else packet.payload = (0, $j4unN.EMPTY_UINT8_ARRAY);\n                return packet;\n            }\n        } catch (e) {\n            // On Windows, disconnecting the device will cause `NetworkError` to be thrown,\n            // even before the `disconnect` event is fired.\n            // We need to wait a little bit and check if the device is still connected.\n            // https://github.com/WICG/webusb/issues/219\n            if ((0, $byTpg.isErrorName)(e, \"NetworkError\")) {\n                await new Promise((resolve)=>{\n                    setTimeout(()=>{\n                        resolve();\n                    }, 100);\n                });\n                if (closed) return undefined;\n                else throw e;\n            }\n            throw e;\n        }\n    }\n}\nclass $9f59c3e3ec39e929$export$b4df074ec7ed7a36 {\n    #filters;\n    #usbManager;\n    #raw;\n    get raw() {\n        return this.#raw;\n    }\n    #serial;\n    get serial() {\n        return this.#serial;\n    }\n    get name() {\n        return this.#raw.productName;\n    }\n    /**\n     * Create a new instance of `AdbDaemonWebUsbConnection` using a specified `USBDevice` instance\n     *\n     * @param device The `USBDevice` instance obtained elsewhere.\n     * @param filters The filters to use when searching for ADB interface. Defaults to {@link ADB_DEFAULT_DEVICE_FILTER}.\n     */ constructor(device, filters = [\n        $9f59c3e3ec39e929$export$83dac9bc96800be2\n    ], usbManager){\n        this.#raw = device;\n        this.#serial = (0, $byTpg.getSerialNumber)(device);\n        this.#filters = filters;\n        this.#usbManager = usbManager;\n    }\n    async #claimInterface() {\n        if (!this.#raw.opened) await this.#raw.open();\n        const { configuration: configuration, interface_: interface_, alternate: alternate } = (0, $byTpg.findUsbAlternateInterface)(this.#raw, this.#filters);\n        if (this.#raw.configuration?.configurationValue !== configuration.configurationValue) // Note: Switching configuration is not supported on Windows,\n        // but Android devices should always expose ADB function at the first (default) configuration.\n        await this.#raw.selectConfiguration(configuration.configurationValue);\n        if (!interface_.claimed) await this.#raw.claimInterface(interface_.interfaceNumber);\n        if (interface_.alternate.alternateSetting !== alternate.alternateSetting) await this.#raw.selectAlternateInterface(interface_.interfaceNumber, alternate.alternateSetting);\n        const { inEndpoint: inEndpoint, outEndpoint: outEndpoint } = $9f59c3e3ec39e929$var$findUsbEndpoints(alternate.endpoints);\n        return [\n            inEndpoint,\n            outEndpoint\n        ];\n    }\n    /**\n     * Claim the device and create a pair of `AdbPacket` streams to the ADB interface.\n     * @returns The pair of `AdbPacket` streams.\n     */ async connect() {\n        const [inEndpoint, outEndpoint] = await this.#claimInterface();\n        return new $9f59c3e3ec39e929$export$d762018b8d06af13(this, inEndpoint, outEndpoint, this.#usbManager);\n    }\n}\n\n});\nparcelRegister(\"27oor\", function(module, exports) {\n$parcel$export(module.exports, \"Adb\", () => (parcelRequire(\"4uv4T\")).Adb);\n$parcel$export(module.exports, \"AdbSubprocessShellProtocol\", () => (parcelRequire(\"23OH0\")).AdbSubprocessShellProtocol);\n$parcel$export(module.exports, \"AdbDaemonTransport\", () => (parcelRequire(\"aIHw7\")).AdbDaemonTransport);\n$parcel$export(module.exports, \"AdbPacketHeader\", () => (parcelRequire(\"2lmjj\")).AdbPacketHeader);\n$parcel$export(module.exports, \"AdbPacketSerializeStream\", () => (parcelRequire(\"2lmjj\")).AdbPacketSerializeStream);\n$parcel$export(module.exports, \"unreachable\", () => (parcelRequire(\"fXuIk\")).unreachable);\nparcelRequire(\"4uv4T\");\nparcelRequire(\"bFpy9\");\nparcelRequire(\"chJ24\");\nparcelRequire(\"7gpwK\");\nparcelRequire(\"drR7i\");\nparcelRequire(\"jBeoN\");\nparcelRequire(\"5lBQi\");\n\n});\nparcelRegister(\"4uv4T\", function(module, exports) {\n\n$parcel$export(module.exports, \"Adb\", () => $34521237b2ec6ce9$export$7a062b26cb22e9be);\nparcelRequire(\"7edQJ\");\nvar $k61Wg = parcelRequire(\"k61Wg\");\nvar $koQVx = parcelRequire(\"koQVx\");\nparcelRequire(\"chJ24\");\nvar $5WSZn = parcelRequire(\"5WSZn\");\nvar $gequt = parcelRequire(\"gequt\");\nvar $5jHg5 = parcelRequire(\"5jHg5\");\nvar $aBc50 = parcelRequire(\"aBc50\");\nvar $liel6 = parcelRequire(\"liel6\");\nvar $beA73 = parcelRequire(\"beA73\");\nvar $755W6 = parcelRequire(\"755W6\");\nclass $34521237b2ec6ce9$export$7a062b26cb22e9be {\n    transport;\n    get serial() {\n        return this.transport.serial;\n    }\n    get maxPayloadSize() {\n        return this.transport.maxPayloadSize;\n    }\n    get banner() {\n        return this.transport.banner;\n    }\n    get disconnected() {\n        return this.transport.disconnected;\n    }\n    get clientFeatures() {\n        return this.transport.clientFeatures;\n    }\n    get deviceFeatures() {\n        return this.banner.features;\n    }\n    subprocess;\n    power;\n    reverse;\n    tcpip;\n    constructor(transport){\n        this.transport = transport;\n        this.subprocess = new (0, $5jHg5.AdbSubprocess)(this);\n        this.power = new (0, $5WSZn.AdbPower)(this);\n        this.reverse = new (0, $gequt.AdbReverseCommand)(this);\n        this.tcpip = new (0, $liel6.AdbTcpIpCommand)(this);\n    }\n    canUseFeature(feature) {\n        return this.clientFeatures.includes(feature) && this.deviceFeatures.includes(feature);\n    }\n    async createSocket(service) {\n        return this.transport.connect(service);\n    }\n    async createSocketAndWait(service) {\n        const socket = await this.createSocket(service);\n        return await socket.readable.pipeThrough(new (0, $koQVx.TextDecoderStream)()).pipeThrough(new (0, $k61Wg.ConcatStringStream)());\n    }\n    async getProp(key) {\n        const stdout = await this.subprocess.spawnAndWaitLegacy([\n            \"getprop\",\n            key\n        ]);\n        return stdout.trim();\n    }\n    async rm(filenames, options) {\n        const args = [\n            \"rm\"\n        ];\n        if (options?.recursive) args.push(\"-r\");\n        if (options?.force) args.push(\"-f\");\n        if (Array.isArray(filenames)) for (const filename of filenames)args.push((0, $beA73.escapeArg)(filename));\n        else args.push((0, $beA73.escapeArg)(filenames));\n        // https://android.googlesource.com/platform/packages/modules/adb/+/1a0fb8846d4e6b671c8aa7f137a8c21d7b248716/client/adb_install.cpp#984\n        args.push(\"</dev/null\");\n        const stdout = await this.subprocess.spawnAndWaitLegacy(args);\n        return stdout;\n    }\n    async sync() {\n        const socket = await this.createSocket(\"sync:\");\n        return new (0, $aBc50.AdbSync)(this, socket);\n    }\n    async framebuffer() {\n        return (0, $755W6.framebuffer)(this);\n    }\n    async close() {\n        await this.transport.close();\n    }\n}\n\n});\nparcelRegister(\"7edQJ\", function(module, exports) {\n$parcel$export(module.exports, \"BufferedReadableStream\", () => (parcelRequire(\"bJSM1\")).BufferedReadableStream);\n$parcel$export(module.exports, \"ConcatStringStream\", () => (parcelRequire(\"k61Wg\")).ConcatStringStream);\n$parcel$export(module.exports, \"Consumable\", () => (parcelRequire(\"5Ywqs\")).Consumable);\n$parcel$export(module.exports, \"BufferCombiner\", () => (parcelRequire(\"b5TnZ\")).BufferCombiner);\n$parcel$export(module.exports, \"DistributionStream\", () => (parcelRequire(\"b5TnZ\")).DistributionStream);\n$parcel$export(module.exports, \"DuplexStreamFactory\", () => (parcelRequire(\"bwQFm\")).DuplexStreamFactory);\n$parcel$export(module.exports, \"TextDecoderStream\", () => (parcelRequire(\"koQVx\")).TextDecoderStream);\n$parcel$export(module.exports, \"MaybeConsumable\", () => (parcelRequire(\"jEctC\")).MaybeConsumable);\n$parcel$export(module.exports, \"pipeFrom\", () => (parcelRequire(\"3Ppgt\")).pipeFrom);\n$parcel$export(module.exports, \"PushReadableStream\", () => (parcelRequire(\"fnPEF\")).PushReadableStream);\n$parcel$export(module.exports, \"AbortController\", () => (parcelRequire(\"6NYMu\")).AbortController);\n$parcel$export(module.exports, \"ReadableStream\", () => (parcelRequire(\"6NYMu\")).ReadableStream);\n$parcel$export(module.exports, \"TransformStream\", () => (parcelRequire(\"6NYMu\")).TransformStream);\n$parcel$export(module.exports, \"WritableStream\", () => (parcelRequire(\"6NYMu\")).WritableStream);\n$parcel$export(module.exports, \"StructDeserializeStream\", () => (parcelRequire(\"ebpYL\")).StructDeserializeStream);\n$parcel$export(module.exports, \"WrapWritableStream\", () => (parcelRequire(\"67qk3\")).WrapWritableStream);\nparcelRequire(\"1QeNb\");\nparcelRequire(\"bJSM1\");\nparcelRequire(\"k61Wg\");\nparcelRequire(\"5Ywqs\");\nparcelRequire(\"b5TnZ\");\nparcelRequire(\"bwQFm\");\nparcelRequire(\"koQVx\");\nparcelRequire(\"4eHDJ\");\nparcelRequire(\"jEctC\");\nparcelRequire(\"3Ppgt\");\nparcelRequire(\"fnPEF\");\nparcelRequire(\"jbstH\");\nparcelRequire(\"6NYMu\");\nparcelRequire(\"ebpYL\");\nparcelRequire(\"1yRYZ\");\nparcelRequire(\"cilb9\");\nparcelRequire(\"cSu3L\");\nparcelRequire(\"67qk3\");\n\n});\nparcelRegister(\"1QeNb\", function(module, exports) {\n\n$parcel$export(module.exports, \"BufferedTransformStream\", () => $15761f3c464dcaca$export$1dec6b9a18b23f58);\nparcelRequire(\"hr1EK\");\nvar $9LJSP = parcelRequire(\"9LJSP\");\n\nvar $bJSM1 = parcelRequire(\"bJSM1\");\n\nvar $fnPEF = parcelRequire(\"fnPEF\");\n\nvar $6NYMu = parcelRequire(\"6NYMu\");\nclass $15761f3c464dcaca$export$1dec6b9a18b23f58 {\n    #readable;\n    get readable() {\n        return this.#readable;\n    }\n    #writable;\n    get writable() {\n        return this.#writable;\n    }\n    constructor(transform){\n        // Convert incoming chunks to a `BufferedReadableStream`\n        let sourceStreamController;\n        const buffered = new (0, $bJSM1.BufferedReadableStream)(new (0, $fnPEF.PushReadableStream)((controller)=>{\n            sourceStreamController = controller;\n        }));\n        this.#readable = new (0, $6NYMu.ReadableStream)({\n            async pull (controller) {\n                try {\n                    const value = await transform(buffered);\n                    controller.enqueue(value);\n                } catch (e) {\n                    // Treat `StructEmptyError` as a normal end.\n                    // If the `transform` method doesn't have enough data to return a value,\n                    // it should throw another error to indicate that.\n                    if (e instanceof (0, $9LJSP.StructEmptyError)) {\n                        controller.close();\n                        return;\n                    }\n                    throw e;\n                }\n            },\n            cancel: (reason)=>{\n                // Propagate cancel to the source stream\n                // So future writes will be rejected\n                return buffered.cancel(reason);\n            }\n        });\n        this.#writable = new (0, $6NYMu.WritableStream)({\n            async write (chunk) {\n                await sourceStreamController.enqueue(chunk);\n            },\n            abort () {\n                sourceStreamController.close();\n            },\n            close () {\n                sourceStreamController.close();\n            }\n        });\n    }\n}\n\n});\nparcelRegister(\"hr1EK\", function(module, exports) {\n$parcel$export(module.exports, \"ExactReadableEndedError\", () => (parcelRequire(\"70dme\")).ExactReadableEndedError);\n$parcel$export(module.exports, \"Struct\", () => (parcelRequire(\"9LJSP\")).Struct);\n$parcel$export(module.exports, \"StructEmptyError\", () => (parcelRequire(\"9LJSP\")).StructEmptyError);\n$parcel$export(module.exports, \"SyncPromise\", () => (parcelRequire(\"6yg6p\")).SyncPromise);\n$parcel$export(module.exports, \"EMPTY_UINT8_ARRAY\", () => (parcelRequire(\"j4unN\")).EMPTY_UINT8_ARRAY);\n$parcel$export(module.exports, \"decodeUtf8\", () => (parcelRequire(\"6Savq\")).decodeUtf8);\n$parcel$export(module.exports, \"encodeUtf8\", () => (parcelRequire(\"6Savq\")).encodeUtf8);\n$parcel$export(module.exports, \"placeholder\", () => (parcelRequire(\"6Savq\")).placeholder);\n\n$parcel$export(module.exports, \"default\", () => (parcelRequire(\"9LJSP\")).Struct);\nparcelRequire(\"aF1FJ\");\n\nvar $9LJSP = parcelRequire(\"9LJSP\");\nparcelRequire(\"6yg6p\");\nparcelRequire(\"3rhZL\");\nparcelRequire(\"6Savq\");\n\n});\nparcelRegister(\"aF1FJ\", function(module, exports) {\n$parcel$export(module.exports, \"StructFieldDefinition\", () => (parcelRequire(\"hU3mS\")).StructFieldDefinition);\n$parcel$export(module.exports, \"StructFieldValue\", () => (parcelRequire(\"4dyEt\")).StructFieldValue);\n$parcel$export(module.exports, \"StructDefaultOptions\", () => (parcelRequire(\"8j8Qa\")).StructDefaultOptions);\n$parcel$export(module.exports, \"ExactReadableEndedError\", () => (parcelRequire(\"70dme\")).ExactReadableEndedError);\n$parcel$export(module.exports, \"isStructValueInit\", () => (parcelRequire(\"iissA\")).isStructValueInit);\n$parcel$export(module.exports, \"STRUCT_VALUE_SYMBOL\", () => (parcelRequire(\"iissA\")).STRUCT_VALUE_SYMBOL);\n$parcel$export(module.exports, \"StructValue\", () => (parcelRequire(\"iissA\")).StructValue);\nparcelRequire(\"hU3mS\");\nparcelRequire(\"4dyEt\");\nparcelRequire(\"8j8Qa\");\nparcelRequire(\"70dme\");\nparcelRequire(\"iissA\");\n\n});\nparcelRegister(\"hU3mS\", function(module, exports) {\n\n$parcel$export(module.exports, \"StructFieldDefinition\", () => $035d11ab306c6c89$export$804794de18b9cab0);\n/**\n * A field definition defines how to deserialize a field.\n *\n * @template TOptions TypeScript type of this definition's `options`.\n * @template TValue TypeScript type of this field.\n * @template TOmitInitKey Optionally remove some fields from the init type. Should be a union of string literal types.\n */ class $035d11ab306c6c89$export$804794de18b9cab0 {\n    /**\n     * When `T` is a type initiated `StructFieldDefinition`,\n     * use `T['TValue']` to retrieve its `TValue` type parameter.\n     */ TValue;\n    /**\n     * When `T` is a type initiated `StructFieldDefinition`,\n     * use `T['TOmitInitKey']` to retrieve its `TOmitInitKey` type parameter.\n     */ TOmitInitKey;\n    options;\n    constructor(options){\n        this.options = options;\n    }\n}\n\n});\n\nparcelRegister(\"4dyEt\", function(module, exports) {\n\n$parcel$export(module.exports, \"StructFieldValue\", () => $312341718db575d7$export$391b04ee9b3e1655);\n/**\n * A field value defines how to serialize a field.\n *\n * It may contains extra metadata about the value which are essential or\n * helpful for the serialization process.\n */ class $312341718db575d7$export$391b04ee9b3e1655 {\n    /** Gets the definition associated with this runtime value */ definition;\n    /** Gets the options of the associated `Struct` */ options;\n    /** Gets the associated `Struct` instance */ struct;\n    get hasCustomAccessors() {\n        return this.get !== $312341718db575d7$export$391b04ee9b3e1655.prototype.get || this.set !== $312341718db575d7$export$391b04ee9b3e1655.prototype.set;\n    }\n    value;\n    constructor(definition, options, struct, value){\n        this.definition = definition;\n        this.options = options;\n        this.struct = struct;\n        this.value = value;\n    }\n    /**\n     * Gets size of this field. By default, it returns its `definition`'s size.\n     *\n     * When overridden in derived classes, can have custom logic to calculate the actual size.\n     */ getSize() {\n        return this.definition.getSize();\n    }\n    /**\n     * When implemented in derived classes, reads current field's value.\n     */ get() {\n        return this.value;\n    }\n    /**\n     * When implemented in derived classes, updates current field's value.\n     */ set(value) {\n        this.value = value;\n    }\n}\n\n});\n\nparcelRegister(\"8j8Qa\", function(module, exports) {\n\n$parcel$export(module.exports, \"StructDefaultOptions\", () => $60c6f49fee635812$export$d519eb5cbd68a82e);\nconst $60c6f49fee635812$export$d519eb5cbd68a82e = {\n    littleEndian: false\n};\n\n});\n\nparcelRegister(\"70dme\", function(module, exports) {\n\n$parcel$export(module.exports, \"ExactReadableEndedError\", () => $5192e50163bfdc4f$export$a89eeb2712a9e4e1);\n// TODO: allow over reading (returning a `Uint8Array`, an `offset` and a `length`) to avoid copying\nclass $5192e50163bfdc4f$export$a89eeb2712a9e4e1 extends Error {\n    constructor(){\n        super(\"ExactReadable ended\");\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\n\n});\n\nparcelRegister(\"iissA\", function(module, exports) {\n\n$parcel$export(module.exports, \"STRUCT_VALUE_SYMBOL\", () => $d51ffc090449bd90$export$bbd6643020302418);\n$parcel$export(module.exports, \"isStructValueInit\", () => $d51ffc090449bd90$export$82df0b712ff78769);\n$parcel$export(module.exports, \"StructValue\", () => $d51ffc090449bd90$export$f66d5fb339033b6);\nconst $d51ffc090449bd90$export$bbd6643020302418 = Symbol(\"struct-value\");\nfunction $d51ffc090449bd90$export$82df0b712ff78769(value) {\n    return typeof value === \"object\" && value !== null && $d51ffc090449bd90$export$bbd6643020302418 in value;\n}\nclass $d51ffc090449bd90$export$f66d5fb339033b6 {\n    /** @internal */ fieldValues = {};\n    /**\n     * Gets the result struct value object\n     */ value;\n    constructor(prototype){\n        // PERF: `Object.create(extra)` is 50% faster\n        // than `Object.defineProperties(this.value, extra)`\n        this.value = Object.create(prototype);\n        // PERF: `Object.defineProperty` is slow\n        // but we need it to be non-enumerable\n        Object.defineProperty(this.value, $d51ffc090449bd90$export$bbd6643020302418, {\n            enumerable: false,\n            value: this\n        });\n    }\n    /**\n     * Sets a `StructFieldValue` for `key`\n     *\n     * @param name The field name\n     * @param fieldValue The associated `StructFieldValue`\n     */ set(name, fieldValue) {\n        this.fieldValues[name] = fieldValue;\n        // PERF: `Object.defineProperty` is slow\n        // use normal property when possible\n        if (fieldValue.hasCustomAccessors) Object.defineProperty(this.value, name, {\n            configurable: true,\n            enumerable: true,\n            get () {\n                return fieldValue.get();\n            },\n            set (v) {\n                fieldValue.set(v);\n            }\n        });\n        else this.value[name] = fieldValue.get();\n    }\n    /**\n     * Gets the `StructFieldValue` for `key`\n     *\n     * @param name The field name\n     */ get(name) {\n        return this.fieldValues[name];\n    }\n}\n\n});\n\n\nparcelRegister(\"9LJSP\", function(module, exports) {\n\n$parcel$export(module.exports, \"StructEmptyError\", () => $71cc184b366eacb0$export$7af6964ac5489517);\n$parcel$export(module.exports, \"Struct\", () => $71cc184b366eacb0$export$eabc71f011df675a);\n/* eslint-disable @typescript-eslint/no-explicit-any */ parcelRequire(\"aF1FJ\");\nvar $70dme = parcelRequire(\"70dme\");\nvar $iissA = parcelRequire(\"iissA\");\nvar $8j8Qa = parcelRequire(\"8j8Qa\");\n\nvar $6yg6p = parcelRequire(\"6yg6p\");\nparcelRequire(\"3rhZL\");\nvar $ioobU = parcelRequire(\"ioobU\");\nvar $7M0oO = parcelRequire(\"7M0oO\");\nvar $fiklF = parcelRequire(\"fiklF\");\nvar $j4unN = parcelRequire(\"j4unN\");\nvar $drcSV = parcelRequire(\"drcSV\");\nclass $71cc184b366eacb0$export$40dad8b579eb5f98 extends Error {\n    constructor(message){\n        super(message);\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\nclass $71cc184b366eacb0$export$4217ee4abf29bfe6 extends $71cc184b366eacb0$export$40dad8b579eb5f98 {\n    constructor(){\n        super(\"The underlying readable was ended before the struct was fully deserialized\");\n    }\n}\nclass $71cc184b366eacb0$export$7af6964ac5489517 extends $71cc184b366eacb0$export$40dad8b579eb5f98 {\n    constructor(){\n        super(\"The underlying readable doesn't contain any more struct\");\n    }\n}\nclass $71cc184b366eacb0$export$eabc71f011df675a {\n    TFields;\n    TOmitInitKey;\n    TExtra;\n    TInit;\n    TDeserializeResult;\n    options;\n    #size = 0;\n    /**\n     * Gets the static size (exclude fields that can change size at runtime)\n     */ get size() {\n        return this.#size;\n    }\n    #fields = [];\n    get fields() {\n        return this.#fields;\n    }\n    #extra = {};\n    #postDeserialized;\n    constructor(options){\n        this.options = {\n            ...(0, $8j8Qa.StructDefaultOptions),\n            ...options\n        };\n    }\n    /**\n     * Appends a `StructFieldDefinition` to the `Struct\n     */ field(name, definition) {\n        for (const field of this.#fields)if (field[0] === name) {\n            // Convert Symbol to string\n            const nameString = String(name);\n            throw new Error(`This struct already have a field with name '${nameString}'`);\n        }\n        this.#fields.push([\n            name,\n            definition\n        ]);\n        const size = definition.getSize();\n        this.#size += size;\n        // Force cast `this` to another type\n        return this;\n    }\n    /**\n     * Merges (flats) another `Struct`'s fields and extra fields into this one.\n     *\n     * `other`'s `postDeserialize` will be ignored.\n     */ concat(other) {\n        if (!(other instanceof $71cc184b366eacb0$export$eabc71f011df675a)) throw new TypeError(\"The other value must be a `Struct` instance\");\n        for (const field of other.#fields)this.#fields.push(field);\n        this.#size += other.#size;\n        Object.defineProperties(this.#extra, Object.getOwnPropertyDescriptors(other.#extra));\n        return this;\n    }\n    #number(name, type, typeScriptType) {\n        return this.field(name, new (0, $fiklF.NumberFieldDefinition)(type, typeScriptType));\n    }\n    /**\n     * Appends an `int8` field to the `Struct`\n     */ int8(name, typeScriptType) {\n        return this.#number(name, (0, $fiklF.NumberFieldVariant).Int8, typeScriptType);\n    }\n    /**\n     * Appends an `uint8` field to the `Struct`\n     */ uint8(name, typeScriptType) {\n        return this.#number(name, (0, $fiklF.NumberFieldVariant).Uint8, typeScriptType);\n    }\n    /**\n     * Appends an `int16` field to the `Struct`\n     */ int16(name, typeScriptType) {\n        return this.#number(name, (0, $fiklF.NumberFieldVariant).Int16, typeScriptType);\n    }\n    /**\n     * Appends an `uint16` field to the `Struct`\n     */ uint16(name, typeScriptType) {\n        return this.#number(name, (0, $fiklF.NumberFieldVariant).Uint16, typeScriptType);\n    }\n    /**\n     * Appends an `int32` field to the `Struct`\n     */ int32(name, typeScriptType) {\n        return this.#number(name, (0, $fiklF.NumberFieldVariant).Int32, typeScriptType);\n    }\n    /**\n     * Appends an `uint32` field to the `Struct`\n     */ uint32(name, typeScriptType) {\n        return this.#number(name, (0, $fiklF.NumberFieldVariant).Uint32, typeScriptType);\n    }\n    #bigint(name, type, typeScriptType) {\n        return this.field(name, new (0, $ioobU.BigIntFieldDefinition)(type, typeScriptType));\n    }\n    /**\n     * Appends an `int64` field to the `Struct`\n     *\n     * Requires native `BigInt` support\n     */ int64(name, typeScriptType) {\n        return this.#bigint(name, (0, $ioobU.BigIntFieldVariant).Int64, typeScriptType);\n    }\n    /**\n     * Appends an `uint64` field to the `Struct`\n     *\n     * Requires native `BigInt` support\n     */ uint64(name, typeScriptType) {\n        return this.#bigint(name, (0, $ioobU.BigIntFieldVariant).Uint64, typeScriptType);\n    }\n    #arrayBufferLike = (name, type, options)=>{\n        if (\"length\" in options) return this.field(name, new (0, $7M0oO.FixedLengthBufferLikeFieldDefinition)(type, options));\n        else return this.field(name, new (0, $drcSV.VariableLengthBufferLikeFieldDefinition)(type, options));\n    };\n    uint8Array = (name, options, typeScriptType)=>{\n        return this.#arrayBufferLike(name, (0, $j4unN.Uint8ArrayBufferFieldConverter).Instance, options, typeScriptType);\n    };\n    string = (name, options, typeScriptType)=>{\n        return this.#arrayBufferLike(name, (0, $j4unN.StringBufferFieldConverter).Instance, options, typeScriptType);\n    };\n    /**\n     * Adds some extra properties into every `Struct` value.\n     *\n     * Extra properties will not affect serialize or deserialize process.\n     *\n     * Multiple calls to `extra` will merge all properties together.\n     *\n     * @param value\n     * An object containing properties to be added to the result value. Accessors and methods are also allowed.\n     */ extra(value) {\n        Object.defineProperties(this.#extra, Object.getOwnPropertyDescriptors(value));\n        return this;\n    }\n    postDeserialize(callback) {\n        this.#postDeserialized = callback;\n        return this;\n    }\n    deserialize(stream) {\n        const structValue = new (0, $iissA.StructValue)(this.#extra);\n        let promise = (0, $6yg6p.SyncPromise).resolve();\n        const startPosition = stream.position;\n        for (const [name, definition] of this.#fields)promise = promise.then(()=>definition.deserialize(this.options, stream, structValue)).then((fieldValue)=>{\n            structValue.set(name, fieldValue);\n        }, (e)=>{\n            if (!(e instanceof (0, $70dme.ExactReadableEndedError))) throw e;\n            if (stream.position === startPosition) throw new $71cc184b366eacb0$export$7af6964ac5489517();\n            else throw new $71cc184b366eacb0$export$4217ee4abf29bfe6();\n        });\n        return promise.then(()=>{\n            const value = structValue.value;\n            // Run `postDeserialized`\n            if (this.#postDeserialized) {\n                const override = this.#postDeserialized.call(value, value);\n                // If it returns a new value, use that as result\n                // Otherwise it only inspects/mutates the object in place.\n                if (override !== undefined) return override;\n            }\n            return value;\n        }).valueOrPromise();\n    }\n    /**\n     * Serialize a struct value to a buffer.\n     * @param init Fields of the struct\n     * @param output The buffer to serialize the struct to. It must be large enough to hold the entire struct. If not provided, a new buffer will be created.\n     * @returns A view of `output` that contains the serialized struct, or a new buffer if `output` is not provided.\n     */ serialize(init, output) {\n        let structValue;\n        if ((0, $iissA.isStructValueInit)(init)) {\n            structValue = init[0, $iissA.STRUCT_VALUE_SYMBOL];\n            for (const [key, value] of Object.entries(init)){\n                const fieldValue = structValue.get(key);\n                if (fieldValue) fieldValue.set(value);\n            }\n        } else {\n            structValue = new (0, $iissA.StructValue)({});\n            for (const [name, definition] of this.#fields){\n                const fieldValue = definition.create(this.options, structValue, init[name]);\n                structValue.set(name, fieldValue);\n            }\n        }\n        let structSize = 0;\n        const fieldsInfo = [];\n        for (const [name] of this.#fields){\n            const fieldValue = structValue.get(name);\n            const size = fieldValue.getSize();\n            fieldsInfo.push({\n                fieldValue: fieldValue,\n                size: size\n            });\n            structSize += size;\n        }\n        if (!output) output = new Uint8Array(structSize);\n        else if (output.length < structSize) throw new TypeError(\"Output buffer is too small\");\n        const dataView = new DataView(output.buffer, output.byteOffset, output.byteLength);\n        let offset = 0;\n        for (const { fieldValue: fieldValue, size: size } of fieldsInfo){\n            fieldValue.serialize(dataView, output, offset);\n            offset += size;\n        }\n        if (output.length !== structSize) return output.subarray(0, structSize);\n        else return output;\n    }\n}\n\n});\nparcelRegister(\"6yg6p\", function(module, exports) {\n\n$parcel$export(module.exports, \"SyncPromise\", () => $4c5268a801551813$export$6f292d4960313241);\nconst $4c5268a801551813$export$6f292d4960313241 = {\n    reject (reason) {\n        return new $4c5268a801551813$var$RejectedSyncPromise(reason);\n    },\n    resolve (value) {\n        if (typeof value === \"object\" && value !== null && typeof value.then === \"function\") {\n            if (value instanceof $4c5268a801551813$var$PendingSyncPromise || value instanceof $4c5268a801551813$var$ResolvedSyncPromise || value instanceof $4c5268a801551813$var$RejectedSyncPromise) return value;\n            return new $4c5268a801551813$var$PendingSyncPromise(value);\n        } else return new $4c5268a801551813$var$ResolvedSyncPromise(value);\n    },\n    try (executor) {\n        try {\n            return $4c5268a801551813$export$6f292d4960313241.resolve(executor());\n        } catch (e) {\n            return $4c5268a801551813$export$6f292d4960313241.reject(e);\n        }\n    }\n};\nclass $4c5268a801551813$var$PendingSyncPromise {\n    #promise;\n    constructor(promise){\n        this.#promise = promise;\n    }\n    then(onfulfilled, onrejected) {\n        return new $4c5268a801551813$var$PendingSyncPromise(this.#promise.then(onfulfilled, onrejected));\n    }\n    valueOrPromise() {\n        return this.#promise;\n    }\n}\nclass $4c5268a801551813$var$ResolvedSyncPromise {\n    #value;\n    constructor(value){\n        this.#value = value;\n    }\n    then(onfulfilled) {\n        if (!onfulfilled) return this;\n        return $4c5268a801551813$export$6f292d4960313241.try(()=>onfulfilled(this.#value));\n    }\n    valueOrPromise() {\n        return this.#value;\n    }\n}\nclass $4c5268a801551813$var$RejectedSyncPromise {\n    #reason;\n    constructor(reason){\n        this.#reason = reason;\n    }\n    then(onfulfilled, onrejected) {\n        if (!onrejected) return this;\n        return $4c5268a801551813$export$6f292d4960313241.try(()=>onrejected(this.#reason));\n    }\n    valueOrPromise() {\n        throw this.#reason;\n    }\n}\n\n});\n\nparcelRegister(\"3rhZL\", function(module, exports) {\n$parcel$export(module.exports, \"BigIntFieldDefinition\", () => (parcelRequire(\"ioobU\")).BigIntFieldDefinition);\n$parcel$export(module.exports, \"BigIntFieldVariant\", () => (parcelRequire(\"ioobU\")).BigIntFieldVariant);\n$parcel$export(module.exports, \"EMPTY_UINT8_ARRAY\", () => (parcelRequire(\"j4unN\")).EMPTY_UINT8_ARRAY);\n$parcel$export(module.exports, \"FixedLengthBufferLikeFieldDefinition\", () => (parcelRequire(\"7M0oO\")).FixedLengthBufferLikeFieldDefinition);\n$parcel$export(module.exports, \"StringBufferFieldConverter\", () => (parcelRequire(\"j4unN\")).StringBufferFieldConverter);\n$parcel$export(module.exports, \"Uint8ArrayBufferFieldConverter\", () => (parcelRequire(\"j4unN\")).Uint8ArrayBufferFieldConverter);\n$parcel$export(module.exports, \"VariableLengthBufferLikeFieldDefinition\", () => (parcelRequire(\"drcSV\")).VariableLengthBufferLikeFieldDefinition);\n$parcel$export(module.exports, \"NumberFieldDefinition\", () => (parcelRequire(\"fiklF\")).NumberFieldDefinition);\n$parcel$export(module.exports, \"NumberFieldVariant\", () => (parcelRequire(\"fiklF\")).NumberFieldVariant);\nparcelRequire(\"ioobU\");\nparcelRequire(\"5R05c\");\nparcelRequire(\"fiklF\");\n\n});\nparcelRegister(\"ioobU\", function(module, exports) {\n\n$parcel$export(module.exports, \"BigIntFieldVariant\", () => $d63d3bb5814df626$export$7f44118adc318a0c);\n$parcel$export(module.exports, \"BigIntFieldDefinition\", () => $d63d3bb5814df626$export$47590baf50e650b4);\nparcelRequire(\"cOond\");\nvar $duafd = parcelRequire(\"duafd\");\nvar $jzfEx = parcelRequire(\"jzfEx\");\nparcelRequire(\"aF1FJ\");\nvar $hU3mS = parcelRequire(\"hU3mS\");\nvar $4dyEt = parcelRequire(\"4dyEt\");\n\nvar $6yg6p = parcelRequire(\"6yg6p\");\nclass $d63d3bb5814df626$export$7f44118adc318a0c {\n    TTypeScriptType;\n    size;\n    deserialize;\n    serialize;\n    constructor(size, deserialize, serialize){\n        this.size = size;\n        this.deserialize = deserialize;\n        this.serialize = serialize;\n    }\n    static Int64 = new $d63d3bb5814df626$export$7f44118adc318a0c(8, (0, $duafd.getInt64), (0, $duafd.setInt64));\n    static Uint64 = new $d63d3bb5814df626$export$7f44118adc318a0c(8, (0, $jzfEx.getUint64), (0, $jzfEx.setUint64));\n}\nclass $d63d3bb5814df626$export$47590baf50e650b4 extends (0, $hU3mS.StructFieldDefinition) {\n    variant;\n    constructor(variant, typescriptType){\n        super();\n        this.variant = variant;\n    }\n    getSize() {\n        return this.variant.size;\n    }\n    create(options, struct, value) {\n        return new $d63d3bb5814df626$export$356b59f789fa5206(this, options, struct, value);\n    }\n    deserialize(options, stream, struct) {\n        return (0, $6yg6p.SyncPromise).try(()=>{\n            return stream.readExactly(this.getSize());\n        }).then((array)=>{\n            const value = this.variant.deserialize(array, 0, options.littleEndian);\n            return this.create(options, struct, value);\n        }).valueOrPromise();\n    }\n}\nclass $d63d3bb5814df626$export$356b59f789fa5206 extends (0, $4dyEt.StructFieldValue) {\n    serialize(dataView, array, offset) {\n        this.definition.variant.serialize(array, offset, this.value, this.options.littleEndian);\n    }\n}\n\n});\nparcelRegister(\"cOond\", function(module, exports) {\n$parcel$export(module.exports, \"getInt16\", () => (parcelRequire(\"eRgHk\")).getInt16);\n$parcel$export(module.exports, \"getInt32\", () => (parcelRequire(\"4smoc\")).getInt32);\n$parcel$export(module.exports, \"getInt64\", () => (parcelRequire(\"duafd\")).getInt64);\n$parcel$export(module.exports, \"setInt64\", () => (parcelRequire(\"duafd\")).setInt64);\n$parcel$export(module.exports, \"setInt64BigEndian\", () => (parcelRequire(\"duafd\")).setInt64BigEndian);\n$parcel$export(module.exports, \"setInt64LittleEndian\", () => (parcelRequire(\"duafd\")).setInt64LittleEndian);\n$parcel$export(module.exports, \"getInt8\", () => (parcelRequire(\"gBDJc\")).getInt8);\n$parcel$export(module.exports, \"getUint16\", () => (parcelRequire(\"hXg0k\")).getUint16);\n$parcel$export(module.exports, \"getUint32\", () => (parcelRequire(\"h4MAN\")).getUint32);\n$parcel$export(module.exports, \"getUint32LittleEndian\", () => (parcelRequire(\"h4MAN\")).getUint32LittleEndian);\n$parcel$export(module.exports, \"setUint32LittleEndian\", () => (parcelRequire(\"h4MAN\")).setUint32LittleEndian);\n$parcel$export(module.exports, \"getUint64\", () => (parcelRequire(\"jzfEx\")).getUint64);\n$parcel$export(module.exports, \"getUint64BigEndian\", () => (parcelRequire(\"jzfEx\")).getUint64BigEndian);\n$parcel$export(module.exports, \"getUint64LittleEndian\", () => (parcelRequire(\"jzfEx\")).getUint64LittleEndian);\n$parcel$export(module.exports, \"setUint64\", () => (parcelRequire(\"jzfEx\")).setUint64);\nparcelRequire(\"eRgHk\");\nparcelRequire(\"4smoc\");\nparcelRequire(\"duafd\");\nparcelRequire(\"gBDJc\");\nparcelRequire(\"hXg0k\");\nparcelRequire(\"h4MAN\");\nparcelRequire(\"jzfEx\");\n\n});\nparcelRegister(\"eRgHk\", function(module, exports) {\n\n$parcel$export(module.exports, \"getInt16\", () => $ad12f7c62572a109$export$7111ea4c3e27a959);\nfunction $ad12f7c62572a109$export$8ecc34650601d284(buffer, offset) {\n    return (buffer[offset] | buffer[offset + 1] << 8) << 16 >> 16;\n}\nfunction $ad12f7c62572a109$export$31e6610dad8278c3(buffer, offset) {\n    return (buffer[offset] << 8 | buffer[offset + 1]) << 16 >> 16;\n}\nfunction $ad12f7c62572a109$export$7111ea4c3e27a959(buffer, offset, littleEndian) {\n    return littleEndian ? (buffer[offset] | buffer[offset + 1] << 8) << 16 >> 16 : (buffer[offset] << 8 | buffer[offset + 1]) << 16 >> 16;\n}\nfunction $ad12f7c62572a109$export$1b4d6b0ecaff32eb(buffer, offset, value) {\n    buffer[offset] = value;\n    buffer[offset + 1] = value >> 8;\n}\nfunction $ad12f7c62572a109$export$1583be194bf15055(buffer, offset, value) {\n    buffer[offset] = value >> 8;\n    buffer[offset + 1] = value;\n}\nfunction $ad12f7c62572a109$export$d8d638e42ac1fe2f(buffer, offset, value, littleEndian) {\n    if (littleEndian) {\n        buffer[offset] = value;\n        buffer[offset + 1] = value >> 8;\n    } else {\n        buffer[offset] = value >> 8;\n        buffer[offset + 1] = value;\n    }\n}\n\n});\n\nparcelRegister(\"4smoc\", function(module, exports) {\n\n$parcel$export(module.exports, \"getInt32\", () => $33eb2502b7dced81$export$20d487fff2ae6963);\nfunction $33eb2502b7dced81$export$a2c6b659ff2486d0(buffer, offset) {\n    return buffer[offset] | buffer[offset + 1] << 8 | buffer[offset + 2] << 16 | buffer[offset + 3] << 24;\n}\nfunction $33eb2502b7dced81$export$41cf657275e1bfab(buffer, offset) {\n    return buffer[offset] << 24 | buffer[offset + 1] << 16 | buffer[offset + 2] << 8 | buffer[offset + 3];\n}\nfunction $33eb2502b7dced81$export$20d487fff2ae6963(buffer, offset, littleEndian) {\n    return littleEndian ? buffer[offset] | buffer[offset + 1] << 8 | buffer[offset + 2] << 16 | buffer[offset + 3] << 24 : buffer[offset] << 24 | buffer[offset + 1] << 16 | buffer[offset + 2] << 8 | buffer[offset + 3];\n}\nfunction $33eb2502b7dced81$export$7460bcdfeca2afc5(buffer, offset, value) {\n    buffer[offset] = value;\n    buffer[offset + 1] = value >> 8;\n    buffer[offset + 2] = value >> 16;\n    buffer[offset + 3] = value >> 24;\n}\nfunction $33eb2502b7dced81$export$518473d365c4024c(buffer, offset, value) {\n    buffer[offset] = value >> 24;\n    buffer[offset + 1] = value >> 16;\n    buffer[offset + 2] = value >> 8;\n    buffer[offset + 3] = value;\n}\nfunction $33eb2502b7dced81$export$db798d0ac03ef04(buffer, offset, value, littleEndian) {\n    if (littleEndian) {\n        buffer[offset] = value;\n        buffer[offset + 1] = value >> 8;\n        buffer[offset + 2] = value >> 16;\n        buffer[offset + 3] = value >> 24;\n    } else {\n        buffer[offset] = value >> 24;\n        buffer[offset + 1] = value >> 16;\n        buffer[offset + 2] = value >> 8;\n        buffer[offset + 3] = value;\n    }\n}\n\n});\n\nparcelRegister(\"duafd\", function(module, exports) {\n\n$parcel$export(module.exports, \"getInt64\", () => $9d160602087c97c1$export$69825c7adcc820c6);\n$parcel$export(module.exports, \"setInt64LittleEndian\", () => $9d160602087c97c1$export$e2d026b78208efb4);\n$parcel$export(module.exports, \"setInt64BigEndian\", () => $9d160602087c97c1$export$cb00adb52e928ee5);\n$parcel$export(module.exports, \"setInt64\", () => $9d160602087c97c1$export$8532a5209571c04a);\nfunction $9d160602087c97c1$export$75f4701eb3269d38(buffer, offset) {\n    return BigInt(buffer[offset]) | BigInt(buffer[offset + 1]) << 8n | BigInt(buffer[offset + 2]) << 16n | BigInt(buffer[offset + 3]) << 24n | BigInt(buffer[offset + 4]) << 32n | BigInt(buffer[offset + 5]) << 40n | BigInt(buffer[offset + 6]) << 48n | BigInt(buffer[offset + 7] << 24) << 32n;\n}\nfunction $9d160602087c97c1$export$8e7e9100eaf0d0ef(buffer, offset) {\n    return BigInt(buffer[offset] << 24) << 32n | BigInt(buffer[offset + 1]) << 48n | BigInt(buffer[offset + 2]) << 40n | BigInt(buffer[offset + 3]) << 32n | BigInt(buffer[offset + 4]) << 24n | BigInt(buffer[offset + 5]) << 16n | BigInt(buffer[offset + 6]) << 8n | BigInt(buffer[offset + 7]);\n}\nfunction $9d160602087c97c1$export$69825c7adcc820c6(buffer, offset, littleEndian) {\n    return littleEndian ? BigInt(buffer[offset]) | BigInt(buffer[offset + 1]) << 8n | BigInt(buffer[offset + 2]) << 16n | BigInt(buffer[offset + 3]) << 24n | BigInt(buffer[offset + 4]) << 32n | BigInt(buffer[offset + 5]) << 40n | BigInt(buffer[offset + 6]) << 48n | BigInt(buffer[offset + 7] << 24) << 32n : BigInt(buffer[offset] << 24) << 32n | BigInt(buffer[offset + 1]) << 48n | BigInt(buffer[offset + 2]) << 40n | BigInt(buffer[offset + 3]) << 32n | BigInt(buffer[offset + 4]) << 24n | BigInt(buffer[offset + 5]) << 16n | BigInt(buffer[offset + 6]) << 8n | BigInt(buffer[offset + 7]);\n}\nfunction $9d160602087c97c1$export$e2d026b78208efb4(buffer, offset, value) {\n    buffer[offset] = Number(value & 0xffn);\n    buffer[offset + 1] = Number(value >> 8n & 0xffn);\n    buffer[offset + 2] = Number(value >> 16n & 0xffn);\n    buffer[offset + 3] = Number(value >> 24n & 0xffn);\n    buffer[offset + 4] = Number(value >> 32n & 0xffn);\n    buffer[offset + 5] = Number(value >> 40n & 0xffn);\n    buffer[offset + 6] = Number(value >> 48n & 0xffn);\n    buffer[offset + 7] = Number(value >> 56n & 0xffn);\n}\nfunction $9d160602087c97c1$export$cb00adb52e928ee5(buffer, offset, value) {\n    buffer[offset] = Number(value >> 56n & 0xffn);\n    buffer[offset + 1] = Number(value >> 48n & 0xffn);\n    buffer[offset + 2] = Number(value >> 40n & 0xffn);\n    buffer[offset + 3] = Number(value >> 32n & 0xffn);\n    buffer[offset + 4] = Number(value >> 24n & 0xffn);\n    buffer[offset + 5] = Number(value >> 16n & 0xffn);\n    buffer[offset + 6] = Number(value >> 8n & 0xffn);\n    buffer[offset + 7] = Number(value & 0xffn);\n}\nfunction $9d160602087c97c1$export$8532a5209571c04a(buffer, offset, value, littleEndian) {\n    if (littleEndian) {\n        buffer[offset] = Number(value & 0xffn);\n        buffer[offset + 1] = Number(value >> 8n & 0xffn);\n        buffer[offset + 2] = Number(value >> 16n & 0xffn);\n        buffer[offset + 3] = Number(value >> 24n & 0xffn);\n        buffer[offset + 4] = Number(value >> 32n & 0xffn);\n        buffer[offset + 5] = Number(value >> 40n & 0xffn);\n        buffer[offset + 6] = Number(value >> 48n & 0xffn);\n        buffer[offset + 7] = Number(value >> 56n & 0xffn);\n    } else {\n        buffer[offset] = Number(value >> 56n & 0xffn);\n        buffer[offset + 1] = Number(value >> 48n & 0xffn);\n        buffer[offset + 2] = Number(value >> 40n & 0xffn);\n        buffer[offset + 3] = Number(value >> 32n & 0xffn);\n        buffer[offset + 4] = Number(value >> 24n & 0xffn);\n        buffer[offset + 5] = Number(value >> 16n & 0xffn);\n        buffer[offset + 6] = Number(value >> 8n & 0xffn);\n        buffer[offset + 7] = Number(value & 0xffn);\n    }\n}\n\n});\n\nparcelRegister(\"gBDJc\", function(module, exports) {\n\n$parcel$export(module.exports, \"getInt8\", () => $c16eeb37ab2cbf45$export$56c0324b6d39bf6e);\nfunction $c16eeb37ab2cbf45$export$56c0324b6d39bf6e(buffer, offset) {\n    return buffer[offset] << 24 >> 24;\n}\n\n});\n\nparcelRegister(\"hXg0k\", function(module, exports) {\n\n$parcel$export(module.exports, \"getUint16\", () => $d1245c7d15e31db4$export$89b158b9ac91fb05);\nfunction $d1245c7d15e31db4$export$e809f04cb3902cdf(buffer, offset) {\n    return buffer[offset] | buffer[offset + 1] << 8;\n}\nfunction $d1245c7d15e31db4$export$41356f71fc3df9a6(buffer, offset) {\n    return buffer[offset] << 8 | buffer[offset + 1];\n}\nfunction $d1245c7d15e31db4$export$89b158b9ac91fb05(buffer, offset, littleEndian) {\n    return littleEndian ? buffer[offset] | buffer[offset + 1] << 8 : buffer[offset + 1] | buffer[offset] << 8;\n}\nfunction $d1245c7d15e31db4$export$56e72cb47a22d547(buffer, offset, value) {\n    buffer[offset] = value;\n    buffer[offset + 1] = value >> 8;\n}\nfunction $d1245c7d15e31db4$export$696f8c2194ddb93a(buffer, offset, value) {\n    buffer[offset] = value >> 8;\n    buffer[offset + 1] = value;\n}\nfunction $d1245c7d15e31db4$export$f86e1edc3d839287(buffer, offset, value, littleEndian) {\n    if (littleEndian) {\n        buffer[offset] = value;\n        buffer[offset + 1] = value >> 8;\n    } else {\n        buffer[offset] = value >> 8;\n        buffer[offset + 1] = value;\n    }\n}\n\n});\n\nparcelRegister(\"h4MAN\", function(module, exports) {\n\n$parcel$export(module.exports, \"getUint32LittleEndian\", () => $c6e880d99c088db3$export$93a5511f94f97356);\n$parcel$export(module.exports, \"getUint32\", () => $c6e880d99c088db3$export$44118f6ad20a04bd);\n$parcel$export(module.exports, \"setUint32LittleEndian\", () => $c6e880d99c088db3$export$c60a33cd4171510b);\nfunction $c6e880d99c088db3$export$93a5511f94f97356(buffer, offset) {\n    return (buffer[offset] | buffer[offset + 1] << 8 | buffer[offset + 2] << 16 | buffer[offset + 3] << 24) >>> 0;\n}\nfunction $c6e880d99c088db3$export$5c240411bb8c7df3(buffer, offset) {\n    return (buffer[offset] << 24 | buffer[offset + 1] << 16 | buffer[offset + 2] << 8 | buffer[offset + 3]) >>> 0;\n}\nfunction $c6e880d99c088db3$export$44118f6ad20a04bd(buffer, offset, littleEndian) {\n    return littleEndian ? (buffer[offset] | buffer[offset + 1] << 8 | buffer[offset + 2] << 16 | buffer[offset + 3] << 24) >>> 0 : (buffer[offset] << 24 | buffer[offset + 1] << 16 | buffer[offset + 2] << 8 | buffer[offset + 3]) >>> 0;\n}\nfunction $c6e880d99c088db3$export$c60a33cd4171510b(buffer, offset, value) {\n    buffer[offset] = value;\n    buffer[offset + 1] = value >> 8;\n    buffer[offset + 2] = value >> 16;\n    buffer[offset + 3] = value >> 24;\n}\nfunction $c6e880d99c088db3$export$b619f4ab00f83cf8(buffer, offset, value) {\n    buffer[offset] = value >> 24;\n    buffer[offset + 1] = value >> 16;\n    buffer[offset + 2] = value >> 8;\n    buffer[offset + 3] = value;\n}\nfunction $c6e880d99c088db3$export$5517b6394fc440fb(buffer, offset, value, littleEndian) {\n    if (littleEndian) {\n        buffer[offset] = value;\n        buffer[offset + 1] = value >> 8;\n        buffer[offset + 2] = value >> 16;\n        buffer[offset + 3] = value >> 24;\n    } else {\n        buffer[offset] = value >> 24;\n        buffer[offset + 1] = value >> 16;\n        buffer[offset + 2] = value >> 8;\n        buffer[offset + 3] = value;\n    }\n}\n\n});\n\nparcelRegister(\"jzfEx\", function(module, exports) {\n\n$parcel$export(module.exports, \"getUint64LittleEndian\", () => $e3ed6d8482796099$export$a43c509a1df9dbdf);\n$parcel$export(module.exports, \"getUint64BigEndian\", () => $e3ed6d8482796099$export$71480404fe2732b3);\n$parcel$export(module.exports, \"getUint64\", () => $e3ed6d8482796099$export$59a2dbf579ff9568);\n$parcel$export(module.exports, \"setUint64\", () => $e3ed6d8482796099$export$20f71c4c8b0f96c3);\nfunction $e3ed6d8482796099$export$a43c509a1df9dbdf(buffer, offset) {\n    return BigInt(buffer[offset]) | BigInt(buffer[offset + 1]) << 8n | BigInt(buffer[offset + 2]) << 16n | BigInt(buffer[offset + 3]) << 24n | BigInt(buffer[offset + 4]) << 32n | BigInt(buffer[offset + 5]) << 40n | BigInt(buffer[offset + 6]) << 48n | BigInt(buffer[offset + 7]) << 56n;\n}\nfunction $e3ed6d8482796099$export$71480404fe2732b3(buffer, offset) {\n    return BigInt(buffer[offset]) << 56n | BigInt(buffer[offset + 1]) << 48n | BigInt(buffer[offset + 2]) << 40n | BigInt(buffer[offset + 3]) << 32n | BigInt(buffer[offset + 4]) << 24n | BigInt(buffer[offset + 5]) << 16n | BigInt(buffer[offset + 6]) << 8n | BigInt(buffer[offset + 7]);\n}\nfunction $e3ed6d8482796099$export$59a2dbf579ff9568(buffer, offset, littleEndian) {\n    return littleEndian ? BigInt(buffer[offset]) | BigInt(buffer[offset + 1]) << 8n | BigInt(buffer[offset + 2]) << 16n | BigInt(buffer[offset + 3]) << 24n | BigInt(buffer[offset + 4]) << 32n | BigInt(buffer[offset + 5]) << 40n | BigInt(buffer[offset + 6]) << 48n | BigInt(buffer[offset + 7]) << 56n : BigInt(buffer[offset]) << 56n | BigInt(buffer[offset + 1]) << 48n | BigInt(buffer[offset + 2]) << 40n | BigInt(buffer[offset + 3]) << 32n | BigInt(buffer[offset + 4]) << 24n | BigInt(buffer[offset + 5]) << 16n | BigInt(buffer[offset + 6]) << 8n | BigInt(buffer[offset + 7]);\n}\nfunction $e3ed6d8482796099$export$5f181e77f490ff66(buffer, offset, value) {\n    buffer[offset] = Number(value & 0xffn);\n    buffer[offset + 1] = Number(value >> 8n & 0xffn);\n    buffer[offset + 2] = Number(value >> 16n & 0xffn);\n    buffer[offset + 3] = Number(value >> 24n & 0xffn);\n    buffer[offset + 4] = Number(value >> 32n & 0xffn);\n    buffer[offset + 5] = Number(value >> 40n & 0xffn);\n    buffer[offset + 6] = Number(value >> 48n & 0xffn);\n    buffer[offset + 7] = Number(value >> 56n & 0xffn);\n}\nfunction $e3ed6d8482796099$export$e863955b31b735c4(buffer, offset, value) {\n    buffer[offset] = Number(value >> 56n & 0xffn);\n    buffer[offset + 1] = Number(value >> 48n & 0xffn);\n    buffer[offset + 2] = Number(value >> 40n & 0xffn);\n    buffer[offset + 3] = Number(value >> 32n & 0xffn);\n    buffer[offset + 4] = Number(value >> 24n & 0xffn);\n    buffer[offset + 5] = Number(value >> 16n & 0xffn);\n    buffer[offset + 6] = Number(value >> 8n & 0xffn);\n    buffer[offset + 7] = Number(value & 0xffn);\n}\nfunction $e3ed6d8482796099$export$20f71c4c8b0f96c3(buffer, offset, value, littleEndian) {\n    if (littleEndian) {\n        buffer[offset] = Number(value & 0xffn);\n        buffer[offset + 1] = Number(value >> 8n & 0xffn);\n        buffer[offset + 2] = Number(value >> 16n & 0xffn);\n        buffer[offset + 3] = Number(value >> 24n & 0xffn);\n        buffer[offset + 4] = Number(value >> 32n & 0xffn);\n        buffer[offset + 5] = Number(value >> 40n & 0xffn);\n        buffer[offset + 6] = Number(value >> 48n & 0xffn);\n        buffer[offset + 7] = Number(value >> 56n & 0xffn);\n    } else {\n        buffer[offset] = Number(value >> 56n & 0xffn);\n        buffer[offset + 1] = Number(value >> 48n & 0xffn);\n        buffer[offset + 2] = Number(value >> 40n & 0xffn);\n        buffer[offset + 3] = Number(value >> 32n & 0xffn);\n        buffer[offset + 4] = Number(value >> 24n & 0xffn);\n        buffer[offset + 5] = Number(value >> 16n & 0xffn);\n        buffer[offset + 6] = Number(value >> 8n & 0xffn);\n        buffer[offset + 7] = Number(value & 0xffn);\n    }\n}\n\n});\n\n\n\nparcelRegister(\"5R05c\", function(module, exports) {\n$parcel$export(module.exports, \"EMPTY_UINT8_ARRAY\", () => (parcelRequire(\"j4unN\")).EMPTY_UINT8_ARRAY);\n$parcel$export(module.exports, \"StringBufferFieldConverter\", () => (parcelRequire(\"j4unN\")).StringBufferFieldConverter);\n$parcel$export(module.exports, \"Uint8ArrayBufferFieldConverter\", () => (parcelRequire(\"j4unN\")).Uint8ArrayBufferFieldConverter);\n$parcel$export(module.exports, \"FixedLengthBufferLikeFieldDefinition\", () => (parcelRequire(\"7M0oO\")).FixedLengthBufferLikeFieldDefinition);\n$parcel$export(module.exports, \"VariableLengthBufferLikeFieldDefinition\", () => (parcelRequire(\"drcSV\")).VariableLengthBufferLikeFieldDefinition);\nparcelRequire(\"j4unN\");\nparcelRequire(\"7M0oO\");\nparcelRequire(\"drcSV\");\n\n});\nparcelRegister(\"j4unN\", function(module, exports) {\n\n$parcel$export(module.exports, \"Uint8ArrayBufferFieldConverter\", () => $de25f57275dc3b5f$export$919ddce6d1c56738);\n$parcel$export(module.exports, \"StringBufferFieldConverter\", () => $de25f57275dc3b5f$export$df462518ae175b8f);\n$parcel$export(module.exports, \"EMPTY_UINT8_ARRAY\", () => $de25f57275dc3b5f$export$ff4d98424a9fd4b9);\n$parcel$export(module.exports, \"BufferLikeFieldDefinition\", () => $de25f57275dc3b5f$export$5fed7215206b866f);\n$parcel$export(module.exports, \"BufferLikeFieldValue\", () => $de25f57275dc3b5f$export$3f021200daa961db);\nparcelRequire(\"aF1FJ\");\nvar $hU3mS = parcelRequire(\"hU3mS\");\nvar $4dyEt = parcelRequire(\"4dyEt\");\n\nvar $6yg6p = parcelRequire(\"6yg6p\");\n\nvar $6Savq = parcelRequire(\"6Savq\");\nclass $de25f57275dc3b5f$export$44ecb42ac2345560 {\n    TTypeScriptType;\n}\nclass $de25f57275dc3b5f$export$919ddce6d1c56738 extends $de25f57275dc3b5f$export$44ecb42ac2345560 {\n    static Instance = new $de25f57275dc3b5f$export$919ddce6d1c56738();\n    constructor(){\n        super();\n    }\n    toBuffer(value) {\n        return value;\n    }\n    toValue(buffer) {\n        return buffer;\n    }\n    getSize(value) {\n        return value.length;\n    }\n}\nclass $de25f57275dc3b5f$export$df462518ae175b8f extends $de25f57275dc3b5f$export$44ecb42ac2345560 {\n    static Instance = new $de25f57275dc3b5f$export$df462518ae175b8f();\n    toBuffer(value) {\n        return (0, $6Savq.encodeUtf8)(value);\n    }\n    toValue(array) {\n        return (0, $6Savq.decodeUtf8)(array);\n    }\n    getSize() {\n        // See the note in `BufferFieldConverter.getSize`\n        return undefined;\n    }\n}\nconst $de25f57275dc3b5f$export$ff4d98424a9fd4b9 = new Uint8Array(0);\nclass $de25f57275dc3b5f$export$5fed7215206b866f extends (0, $hU3mS.StructFieldDefinition) {\n    converter;\n    TTypeScriptType;\n    constructor(converter, options){\n        super(options);\n        this.converter = converter;\n    }\n    getDeserializeSize(struct) {\n        return this.getSize();\n    }\n    /**\n     * When implemented in derived classes, creates a `StructFieldValue` for the current field definition.\n     */ create(options, struct, value, array) {\n        return new $de25f57275dc3b5f$export$3f021200daa961db(this, options, struct, value, array);\n    }\n    deserialize(options, stream, struct) {\n        return (0, $6yg6p.SyncPromise).try(()=>{\n            const size = this.getDeserializeSize(struct);\n            if (size === 0) return $de25f57275dc3b5f$export$ff4d98424a9fd4b9;\n            else return stream.readExactly(size);\n        }).then((array)=>{\n            const value = this.converter.toValue(array);\n            return this.create(options, struct, value, array);\n        }).valueOrPromise();\n    }\n}\nclass $de25f57275dc3b5f$export$3f021200daa961db extends (0, $4dyEt.StructFieldValue) {\n    array;\n    constructor(definition, options, struct, value, array){\n        super(definition, options, struct, value);\n        this.array = array;\n    }\n    set(value) {\n        super.set(value);\n        // When value changes, clear the cached `array`\n        // It will be lazily calculated in `serialize()`\n        this.array = undefined;\n    }\n    serialize(dataView, array, offset) {\n        this.array ??= this.definition.converter.toBuffer(this.value);\n        array.set(this.array, offset);\n    }\n}\n\n});\nparcelRegister(\"6Savq\", function(module, exports) {\n\n$parcel$export(module.exports, \"placeholder\", () => $500fef713084bd27$export$c7187bbd1a7a9244);\n$parcel$export(module.exports, \"encodeUtf8\", () => $500fef713084bd27$export$8f647c2204da8484);\n$parcel$export(module.exports, \"decodeUtf8\", () => $500fef713084bd27$export$72118b85b055afd);\n/**\n * Returns a (fake) value of the given type.\n */ function $500fef713084bd27$export$c7187bbd1a7a9244() {\n    return undefined;\n}\nconst { TextEncoder: $500fef713084bd27$var$TextEncoder, TextDecoder: $500fef713084bd27$var$TextDecoder } = globalThis;\nconst $500fef713084bd27$var$SharedEncoder = new $500fef713084bd27$var$TextEncoder();\nconst $500fef713084bd27$var$SharedDecoder = new $500fef713084bd27$var$TextDecoder();\nfunction $500fef713084bd27$export$8f647c2204da8484(input) {\n    return $500fef713084bd27$var$SharedEncoder.encode(input);\n}\nfunction $500fef713084bd27$export$72118b85b055afd(buffer) {\n    // `TextDecoder` has internal states in stream mode,\n    // but this method is not for stream mode, so the instance can be reused\n    return $500fef713084bd27$var$SharedDecoder.decode(buffer);\n}\n\n});\n\n\nparcelRegister(\"7M0oO\", function(module, exports) {\n\n$parcel$export(module.exports, \"FixedLengthBufferLikeFieldDefinition\", () => $5a8d5361bdac236c$export$f6ef9f85bb06aeff);\n\nvar $j4unN = parcelRequire(\"j4unN\");\nclass $5a8d5361bdac236c$export$f6ef9f85bb06aeff extends (0, $j4unN.BufferLikeFieldDefinition) {\n    getSize() {\n        return this.options.length;\n    }\n}\n\n});\n\nparcelRegister(\"drcSV\", function(module, exports) {\n\n$parcel$export(module.exports, \"VariableLengthBufferLikeFieldDefinition\", () => $9c87caa7f7c09f42$export$bd5db95fcc20ece9);\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */ /* eslint-disable @typescript-eslint/no-explicit-any */ parcelRequire(\"aF1FJ\");\nvar $4dyEt = parcelRequire(\"4dyEt\");\n\nvar $j4unN = parcelRequire(\"j4unN\");\nclass $9c87caa7f7c09f42$export$bd5db95fcc20ece9 extends (0, $j4unN.BufferLikeFieldDefinition) {\n    getSize() {\n        return 0;\n    }\n    getDeserializeSize(struct) {\n        let value = struct.value[this.options.lengthField];\n        if (typeof value === \"string\") value = Number.parseInt(value, this.options.lengthFieldRadix ?? 10);\n        return value;\n    }\n    create(options, struct, value, array) {\n        return new $9c87caa7f7c09f42$export$d3219f0279a7fe4e(this, options, struct, value, array);\n    }\n}\nclass $9c87caa7f7c09f42$export$d3219f0279a7fe4e extends (0, $j4unN.BufferLikeFieldValue) {\n    length;\n    lengthFieldValue;\n    constructor(definition, options, struct, value, array){\n        super(definition, options, struct, value, array);\n        if (array) this.length = array.length;\n        // Patch the associated length field.\n        const lengthField = this.definition.options.lengthField;\n        const originalValue = struct.get(lengthField);\n        this.lengthFieldValue = new $9c87caa7f7c09f42$export$4ea2368eb6ab5b42(originalValue, this);\n        struct.set(lengthField, this.lengthFieldValue);\n    }\n    #tryGetSize() {\n        const length = this.definition.converter.getSize(this.value);\n        if (length !== undefined && length < 0) throw new Error(\"Invalid length\");\n        return length;\n    }\n    getSize() {\n        if (this.length === undefined) // first try to get the size from the converter\n        this.length = this.#tryGetSize();\n        if (this.length === undefined) {\n            // The converter doesn't know the size, so convert the value to a buffer to get its size\n            this.array = this.definition.converter.toBuffer(this.value);\n            this.length = this.array.length;\n        }\n        return this.length;\n    }\n    set(value) {\n        super.set(value);\n        this.array = undefined;\n        this.length = undefined;\n    }\n}\nclass $9c87caa7f7c09f42$export$4ea2368eb6ab5b42 extends (0, $4dyEt.StructFieldValue) {\n    originalValue;\n    bufferValue;\n    constructor(originalValue, bufferValue){\n        super(originalValue.definition, originalValue.options, originalValue.struct, 0);\n        this.originalValue = originalValue;\n        this.bufferValue = bufferValue;\n    }\n    getSize() {\n        return this.originalValue.getSize();\n    }\n    get() {\n        let value = this.bufferValue.getSize();\n        const originalValue = this.originalValue.get();\n        if (typeof originalValue === \"string\") value = value.toString(this.bufferValue.definition.options.lengthFieldRadix ?? 10);\n        return value;\n    }\n    set() {\n    // Ignore setting\n    // It will always be in sync with the buffer size\n    }\n    serialize(dataView, array, offset) {\n        this.originalValue.set(this.get());\n        this.originalValue.serialize(dataView, array, offset);\n    }\n}\n\n});\n\n\nparcelRegister(\"fiklF\", function(module, exports) {\n\n$parcel$export(module.exports, \"NumberFieldVariant\", () => $b2285239387cc49c$export$6eb6015f2bce1d68);\n$parcel$export(module.exports, \"NumberFieldDefinition\", () => $b2285239387cc49c$export$e8cfbf1c68de676b);\nparcelRequire(\"cOond\");\nvar $eRgHk = parcelRequire(\"eRgHk\");\nvar $4smoc = parcelRequire(\"4smoc\");\nvar $gBDJc = parcelRequire(\"gBDJc\");\nvar $hXg0k = parcelRequire(\"hXg0k\");\nvar $h4MAN = parcelRequire(\"h4MAN\");\nparcelRequire(\"aF1FJ\");\nvar $hU3mS = parcelRequire(\"hU3mS\");\nvar $4dyEt = parcelRequire(\"4dyEt\");\n\nvar $6yg6p = parcelRequire(\"6yg6p\");\nvar $b2285239387cc49c$export$6eb6015f2bce1d68;\n(function(NumberFieldVariant) {\n    NumberFieldVariant.Uint8 = {\n        signed: false,\n        size: 1,\n        deserialize (array) {\n            return array[0];\n        },\n        serialize (dataView, offset, value) {\n            dataView.setUint8(offset, value);\n        }\n    };\n    NumberFieldVariant.Int8 = {\n        signed: true,\n        size: 1,\n        deserialize (array) {\n            return (0, $gBDJc.getInt8)(array, 0);\n        },\n        serialize (dataView, offset, value) {\n            dataView.setInt8(offset, value);\n        }\n    };\n    NumberFieldVariant.Uint16 = {\n        signed: false,\n        size: 2,\n        deserialize (array, littleEndian) {\n            // PERF: Creating many `DataView`s over small buffers is 90% slower\n            // than this. Even if the `DataView` is cached, `DataView#getUint16`\n            // is still 1% slower than this.\n            return (0, $hXg0k.getUint16)(array, 0, littleEndian);\n        },\n        serialize (dataView, offset, value, littleEndian) {\n            dataView.setUint16(offset, value, littleEndian);\n        }\n    };\n    NumberFieldVariant.Int16 = {\n        signed: true,\n        size: 2,\n        deserialize (array, littleEndian) {\n            return (0, $eRgHk.getInt16)(array, 0, littleEndian);\n        },\n        serialize (dataView, offset, value, littleEndian) {\n            dataView.setInt16(offset, value, littleEndian);\n        }\n    };\n    NumberFieldVariant.Uint32 = {\n        signed: false,\n        size: 4,\n        deserialize (array, littleEndian) {\n            return (0, $h4MAN.getUint32)(array, 0, littleEndian);\n        },\n        serialize (dataView, offset, value, littleEndian) {\n            dataView.setUint32(offset, value, littleEndian);\n        }\n    };\n    NumberFieldVariant.Int32 = {\n        signed: true,\n        size: 4,\n        deserialize (array, littleEndian) {\n            return (0, $4smoc.getInt32)(array, 0, littleEndian);\n        },\n        serialize (dataView, offset, value, littleEndian) {\n            dataView.setInt32(offset, value, littleEndian);\n        }\n    };\n})($b2285239387cc49c$export$6eb6015f2bce1d68 || ($b2285239387cc49c$export$6eb6015f2bce1d68 = {}));\nclass $b2285239387cc49c$export$e8cfbf1c68de676b extends (0, $hU3mS.StructFieldDefinition) {\n    variant;\n    constructor(variant, typescriptType){\n        super();\n        this.variant = variant;\n    }\n    getSize() {\n        return this.variant.size;\n    }\n    create(options, struct, value) {\n        return new $b2285239387cc49c$export$1365bb43729bbdfd(this, options, struct, value);\n    }\n    deserialize(options, stream, struct) {\n        return (0, $6yg6p.SyncPromise).try(()=>{\n            return stream.readExactly(this.getSize());\n        }).then((array)=>{\n            const value = this.variant.deserialize(array, options.littleEndian);\n            return this.create(options, struct, value);\n        }).valueOrPromise();\n    }\n}\nclass $b2285239387cc49c$export$1365bb43729bbdfd extends (0, $4dyEt.StructFieldValue) {\n    serialize(dataView, array, offset) {\n        this.definition.variant.serialize(dataView, offset, this.value, this.options.littleEndian);\n    }\n}\n\n});\n\n\n\n\nparcelRegister(\"bJSM1\", function(module, exports) {\n\n$parcel$export(module.exports, \"BufferedReadableStream\", () => $88be62932bb485b5$export$4bc5733dbde37c71);\nparcelRequire(\"hr1EK\");\nvar $70dme = parcelRequire(\"70dme\");\n\nvar $fnPEF = parcelRequire(\"fnPEF\");\nconst $88be62932bb485b5$var$NOOP = ()=>{\n// no-op\n};\nclass $88be62932bb485b5$export$4bc5733dbde37c71 {\n    #buffered;\n    #bufferedOffset = 0;\n    #bufferedLength = 0;\n    #position = 0;\n    get position() {\n        return this.#position;\n    }\n    stream;\n    reader;\n    constructor(stream){\n        this.stream = stream;\n        this.reader = stream.getReader();\n    }\n    async #readSource() {\n        const { done: done, value: value } = await this.reader.read();\n        if (done) throw new (0, $70dme.ExactReadableEndedError)();\n        return value;\n    }\n    async #readAsync(length, initial) {\n        let result;\n        let index;\n        if (initial) {\n            result = new Uint8Array(length);\n            result.set(initial);\n            index = initial.length;\n            length -= initial.length;\n        } else {\n            const array = await this.#readSource();\n            if (array.length === length) {\n                this.#position += length;\n                return array;\n            }\n            if (array.length > length) {\n                this.#buffered = array;\n                this.#bufferedOffset = length;\n                this.#bufferedLength = array.length - length;\n                this.#position += length;\n                return array.subarray(0, length);\n            }\n            result = new Uint8Array(length);\n            result.set(array);\n            index = array.length;\n            length -= array.length;\n            this.#position += array.length;\n        }\n        while(length > 0){\n            const array = await this.#readSource();\n            if (array.length === length) {\n                result.set(array, index);\n                this.#position += length;\n                return result;\n            }\n            if (array.length > length) {\n                this.#buffered = array;\n                this.#bufferedOffset = length;\n                this.#bufferedLength = array.length - length;\n                result.set(array.subarray(0, length), index);\n                this.#position += length;\n                return result;\n            }\n            result.set(array, index);\n            index += array.length;\n            length -= array.length;\n            this.#position += array.length;\n        }\n        return result;\n    }\n    /**\n     *\n     * @param length\n     * @returns\n     */ readExactly(length) {\n        // PERF: Add a synchronous path for reading from internal buffer\n        if (this.#buffered) {\n            const array = this.#buffered;\n            const offset = this.#bufferedOffset;\n            if (this.#bufferedLength > length) {\n                // PERF: `subarray` is slow\n                // don't use it until absolutely necessary\n                this.#bufferedOffset += length;\n                this.#bufferedLength -= length;\n                this.#position += length;\n                return array.subarray(offset, offset + length);\n            }\n            this.#buffered = undefined;\n            this.#bufferedLength = 0;\n            this.#bufferedOffset = 0;\n            this.#position += array.length - offset;\n            return this.#readAsync(length, array.subarray(offset));\n        }\n        return this.#readAsync(length);\n    }\n    /**\n     * Return a readable stream with unconsumed data (if any) and\n     * all data from the wrapped stream.\n     * @returns A `ReadableStream`\n     */ release() {\n        if (this.#bufferedLength > 0) return new (0, $fnPEF.PushReadableStream)(async (controller)=>{\n            // Put the remaining data back to the stream\n            const buffered = this.#buffered.subarray(this.#bufferedOffset);\n            await controller.enqueue(buffered);\n            controller.abortSignal.addEventListener(\"abort\", ()=>{\n                // NOOP: the reader might already be released\n                this.reader.cancel().catch($88be62932bb485b5$var$NOOP);\n            });\n            // Manually pipe the stream\n            while(true){\n                const { done: done, value: value } = await this.reader.read();\n                if (done) return;\n                else await controller.enqueue(value);\n            }\n        });\n        else {\n            // Simply release the reader and return the stream\n            this.reader.releaseLock();\n            return this.stream;\n        }\n    }\n    async cancel(reason) {\n        await this.reader.cancel(reason);\n    }\n}\n\n});\nparcelRegister(\"fnPEF\", function(module, exports) {\n\n$parcel$export(module.exports, \"PushReadableStream\", () => $b3311298c0c6568c$export$bcc01621d2cdbb44);\nparcelRequire(\"kV55x\");\nvar $aHKds = parcelRequire(\"aHKds\");\n\nvar $6NYMu = parcelRequire(\"6NYMu\");\nclass $b3311298c0c6568c$export$bcc01621d2cdbb44 extends (0, $6NYMu.ReadableStream) {\n    #zeroHighWaterMarkAllowEnqueue = false;\n    /**\n     * Create a new `PushReadableStream` from a source.\n     *\n     * @param source If `source` returns a `Promise`, the stream will be closed\n     * when the `Promise` is resolved, and be errored when the `Promise` is rejected.\n     * @param strategy\n     */ constructor(source, strategy){\n        let waterMarkLow;\n        const abortController = new (0, $6NYMu.AbortController)();\n        super({\n            start: async (controller)=>{\n                await Promise.resolve();\n                const result = source({\n                    abortSignal: abortController.signal,\n                    enqueue: async (chunk)=>{\n                        if (abortController.signal.aborted) // If the stream is already cancelled,\n                        // throw immediately.\n                        throw abortController.signal.reason;\n                        if (controller.desiredSize === null) {\n                            // `desiredSize` being `null` means the stream is in error state,\n                            // `controller.enqueue` will throw an error for us.\n                            controller.enqueue(chunk);\n                            return;\n                        }\n                        if (this.#zeroHighWaterMarkAllowEnqueue) {\n                            this.#zeroHighWaterMarkAllowEnqueue = false;\n                            controller.enqueue(chunk);\n                            return;\n                        }\n                        if (controller.desiredSize <= 0) {\n                            waterMarkLow = new (0, $aHKds.PromiseResolver)();\n                            await waterMarkLow.promise;\n                        }\n                        // `controller.enqueue` will throw error for us\n                        // if the stream is already errored.\n                        controller.enqueue(chunk);\n                    },\n                    close () {\n                        controller.close();\n                    },\n                    error (e) {\n                        controller.error(e);\n                    }\n                });\n                if (result && \"then\" in result) result.then(()=>{\n                    try {\n                        controller.close();\n                    } catch (e) {\n                    // controller already closed\n                    }\n                }, (e)=>{\n                    controller.error(e);\n                });\n            },\n            pull: ()=>{\n                if (waterMarkLow) {\n                    waterMarkLow.resolve();\n                    return;\n                }\n                if (strategy?.highWaterMark === 0) this.#zeroHighWaterMarkAllowEnqueue = true;\n            },\n            cancel: (reason)=>{\n                abortController.abort(reason);\n                waterMarkLow?.reject(reason);\n            }\n        }, strategy);\n    }\n}\n\n});\nparcelRegister(\"kV55x\", function(module, exports) {\n$parcel$export(module.exports, \"AsyncOperationManager\", () => (parcelRequire(\"1PmPk\")).AsyncOperationManager);\n$parcel$export(module.exports, \"delay\", () => (parcelRequire(\"5OCzC\")).delay);\n$parcel$export(module.exports, \"PromiseResolver\", () => (parcelRequire(\"aHKds\")).PromiseResolver);\nparcelRequire(\"1PmPk\");\nparcelRequire(\"5OCzC\");\nparcelRequire(\"aHKds\");\n\n});\nparcelRegister(\"1PmPk\", function(module, exports) {\n\n$parcel$export(module.exports, \"AsyncOperationManager\", () => $154c42d422606d92$export$10a4a5aeec48d07);\n\nvar $aHKds = parcelRequire(\"aHKds\");\nvar $154c42d422606d92$export$10a4a5aeec48d07 = function() {\n    function AsyncOperationManager(startId) {\n        if (startId === void 0) startId = 0;\n        this.pendingResolvers = new Map();\n        this.nextId = startId;\n    }\n    AsyncOperationManager.prototype.add = function() {\n        var id = this.nextId++;\n        var resolver = new (0, $aHKds.PromiseResolver)();\n        this.pendingResolvers.set(id, resolver);\n        return [\n            id,\n            resolver.promise\n        ];\n    };\n    AsyncOperationManager.prototype.getResolver = function(id) {\n        if (!this.pendingResolvers.has(id)) return null;\n        var resolver = this.pendingResolvers.get(id);\n        this.pendingResolvers.delete(id);\n        return resolver;\n    };\n    AsyncOperationManager.prototype.resolve = function(id, result) {\n        var resolver = this.getResolver(id);\n        if (resolver !== null) {\n            resolver.resolve(result);\n            return true;\n        }\n        return false;\n    };\n    AsyncOperationManager.prototype.reject = function(id, reason) {\n        var resolver = this.getResolver(id);\n        if (resolver !== null) {\n            resolver.reject(reason);\n            return true;\n        }\n        return false;\n    };\n    return AsyncOperationManager;\n}();\n\n});\nparcelRegister(\"aHKds\", function(module, exports) {\n\n$parcel$export(module.exports, \"PromiseResolver\", () => $7cb1c50efa1262d9$export$b523a6f1f39bfd1e);\nvar $7cb1c50efa1262d9$export$b523a6f1f39bfd1e = function() {\n    function PromiseResolver() {\n        var _this = this;\n        this._state = \"running\";\n        this.resolve = function(value) {\n            _this._resolve(value);\n            _this._state = \"resolved\";\n        };\n        this.reject = function(reason) {\n            _this._reject(reason);\n            _this._state = \"rejected\";\n        };\n        this._promise = new Promise(function(resolve, reject) {\n            _this._resolve = resolve;\n            _this._reject = reject;\n        });\n    }\n    Object.defineProperty(PromiseResolver.prototype, \"promise\", {\n        get: function() {\n            return this._promise;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(PromiseResolver.prototype, \"state\", {\n        get: function() {\n            return this._state;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return PromiseResolver;\n}();\n\n});\n\n\nparcelRegister(\"5OCzC\", function(module, exports) {\n\n$parcel$export(module.exports, \"delay\", () => $43bf8b277380453a$export$1391212d75b2ee65);\nfunction $43bf8b277380453a$export$1391212d75b2ee65(time) {\n    return new Promise(function(resolve) {\n        globalThis.setTimeout(function() {\n            return resolve();\n        }, time);\n    });\n}\n\n});\n\n\nparcelRegister(\"6NYMu\", function(module, exports) {\n\n$parcel$export(module.exports, \"AbortController\", () => $4f46778d30aae90e$export$48f7e099c149af88);\n$parcel$export(module.exports, \"ReadableStream\", () => $4f46778d30aae90e$export$5d3e1e5268af5f76);\n$parcel$export(module.exports, \"WritableStream\", () => $4f46778d30aae90e$export$826849241f7970f8);\n$parcel$export(module.exports, \"TransformStream\", () => $4f46778d30aae90e$export$d102341634899398);\nparcelRequire(\"lAXwl\");\nconst $4f46778d30aae90e$var$Global = globalThis;\nconst $4f46778d30aae90e$export$48f7e099c149af88 = $4f46778d30aae90e$var$Global.AbortController;\nconst $4f46778d30aae90e$export$5d3e1e5268af5f76 = $4f46778d30aae90e$var$Global.ReadableStream;\nconst $4f46778d30aae90e$export$826849241f7970f8 = $4f46778d30aae90e$var$Global.WritableStream;\nconst $4f46778d30aae90e$export$d102341634899398 = $4f46778d30aae90e$var$Global.TransformStream;\n\n});\nparcelRegister(\"lAXwl\", function(module, exports) {\n/// <reference lib=\"es2018.asynciterable\" />\n\n});\n\n\n\n\n\nparcelRegister(\"k61Wg\", function(module, exports) {\n\n$parcel$export(module.exports, \"ConcatStringStream\", () => $ea15df33799cd8f3$export$b6b7c3423a277d10);\nparcelRequire(\"kV55x\");\nvar $aHKds = parcelRequire(\"aHKds\");\nparcelRequire(\"hr1EK\");\nvar $j4unN = parcelRequire(\"j4unN\");\n\nvar $6NYMu = parcelRequire(\"6NYMu\");\nclass $ea15df33799cd8f3$export$b6b7c3423a277d10 {\n    // PERF: rope (concat strings) is faster than `[].join('')`\n    #result = \"\";\n    #resolver = new (0, $aHKds.PromiseResolver)();\n    #writable = new (0, $6NYMu.WritableStream)({\n        write: (chunk)=>{\n            this.#result += chunk;\n        },\n        close: ()=>{\n            this.#resolver.resolve(this.#result);\n            this.#readableController.enqueue(this.#result);\n            this.#readableController.close();\n        },\n        abort: (reason)=>{\n            this.#resolver.reject(reason);\n            this.#readableController.error(reason);\n        }\n    });\n    get writable() {\n        return this.#writable;\n    }\n    #readableController;\n    #readable = new (0, $6NYMu.ReadableStream)({\n        start: (controller)=>{\n            this.#readableController = controller;\n        }\n    });\n    get readable() {\n        return this.#readable;\n    }\n    constructor(){\n        Object.defineProperties(this.#readable, {\n            then: {\n                get: ()=>this.#resolver.promise.then.bind(this.#resolver.promise)\n            },\n            catch: {\n                get: ()=>this.#resolver.promise.catch.bind(this.#resolver.promise)\n            },\n            finally: {\n                get: ()=>this.#resolver.promise.finally.bind(this.#resolver.promise)\n            }\n        });\n    }\n}\nclass $ea15df33799cd8f3$export$f841ccdf11436336 {\n    #segments = [];\n    #resolver = new (0, $aHKds.PromiseResolver)();\n    #writable = new (0, $6NYMu.WritableStream)({\n        write: (chunk)=>{\n            this.#segments.push(chunk);\n        },\n        close: ()=>{\n            let result;\n            let offset = 0;\n            switch(this.#segments.length){\n                case 0:\n                    result = (0, $j4unN.EMPTY_UINT8_ARRAY);\n                    break;\n                case 1:\n                    result = this.#segments[0];\n                    break;\n                default:\n                    result = new Uint8Array(this.#segments.reduce((prev, item)=>prev + item.length, 0));\n                    for (const segment of this.#segments){\n                        result.set(segment, offset);\n                        offset += segment.length;\n                    }\n                    break;\n            }\n            this.#resolver.resolve(result);\n            this.#readableController.enqueue(result);\n            this.#readableController.close();\n        },\n        abort: (reason)=>{\n            this.#resolver.reject(reason);\n            this.#readableController.error(reason);\n        }\n    });\n    get writable() {\n        return this.#writable;\n    }\n    #readableController;\n    #readable = new (0, $6NYMu.ReadableStream)({\n        start: (controller)=>{\n            this.#readableController = controller;\n        }\n    });\n    get readable() {\n        return this.#readable;\n    }\n    constructor(){\n        Object.defineProperties(this.#readable, {\n            then: {\n                get: ()=>this.#resolver.promise.then.bind(this.#resolver.promise)\n            },\n            catch: {\n                get: ()=>this.#resolver.promise.catch.bind(this.#resolver.promise)\n            },\n            finally: {\n                get: ()=>this.#resolver.promise.finally.bind(this.#resolver.promise)\n            }\n        });\n    }\n}\n\n});\n\nparcelRegister(\"5Ywqs\", function(module, exports) {\n\n$parcel$export(module.exports, \"Consumable\", () => $459bb56e0b905665$export$888324e445e7ab42);\nparcelRequire(\"kV55x\");\nvar $aHKds = parcelRequire(\"aHKds\");\n\nvar $6NYMu = parcelRequire(\"6NYMu\");\n\nvar $cilb9 = parcelRequire(\"cilb9\");\nfunction $459bb56e0b905665$var$isPromiseLike(value) {\n    return typeof value === \"object\" && value !== null && \"then\" in value;\n}\nclass $459bb56e0b905665$export$888324e445e7ab42 {\n    #task;\n    #resolver;\n    value;\n    consumed;\n    constructor(value){\n        this.#task = (0, $cilb9.createTask)(\"Consumable\");\n        this.value = value;\n        this.#resolver = new (0, $aHKds.PromiseResolver)();\n        this.consumed = this.#resolver.promise;\n    }\n    consume() {\n        this.#resolver.resolve();\n    }\n    error(error) {\n        this.#resolver.reject(error);\n    }\n    tryConsume(callback) {\n        try {\n            let result = this.#task.run(()=>callback(this.value));\n            if ($459bb56e0b905665$var$isPromiseLike(result)) result = result.then((value)=>{\n                this.#resolver.resolve();\n                return value;\n            }, (e)=>{\n                this.#resolver.reject(e);\n                throw e;\n            });\n            else this.#resolver.resolve();\n            return result;\n        } catch (e) {\n            this.#resolver.reject(e);\n            throw e;\n        }\n    }\n}\n(function(Consumable) {\n    class WritableStream extends (0, $6NYMu.WritableStream) {\n        static async write(writer, value) {\n            const consumable = new Consumable(value);\n            await writer.write(consumable);\n            await consumable.consumed;\n        }\n        constructor(sink, strategy){\n            let wrappedStrategy;\n            if (strategy) {\n                wrappedStrategy = {};\n                if (\"highWaterMark\" in strategy) wrappedStrategy.highWaterMark = strategy.highWaterMark;\n                if (\"size\" in strategy) wrappedStrategy.size = (chunk)=>{\n                    return strategy.size(chunk instanceof Consumable ? chunk.value : chunk);\n                };\n            }\n            super({\n                start (controller) {\n                    return sink.start?.(controller);\n                },\n                async write (chunk, controller) {\n                    await chunk.tryConsume((chunk)=>sink.write?.(chunk, controller));\n                },\n                abort (reason) {\n                    return sink.abort?.(reason);\n                },\n                close () {\n                    return sink.close?.();\n                }\n            }, wrappedStrategy);\n        }\n    }\n    Consumable.WritableStream = WritableStream;\n    class ReadableStream extends (0, $6NYMu.ReadableStream) {\n        static async enqueue(controller, chunk) {\n            const output = new Consumable(chunk);\n            controller.enqueue(output);\n            await output.consumed;\n        }\n        constructor(source, strategy){\n            let wrappedController;\n            let wrappedStrategy;\n            if (strategy) {\n                wrappedStrategy = {};\n                if (\"highWaterMark\" in strategy) wrappedStrategy.highWaterMark = strategy.highWaterMark;\n                if (\"size\" in strategy) wrappedStrategy.size = (chunk)=>{\n                    return strategy.size(chunk.value);\n                };\n            }\n            super({\n                async start (controller) {\n                    wrappedController = {\n                        async enqueue (chunk) {\n                            await ReadableStream.enqueue(controller, chunk);\n                        },\n                        close () {\n                            controller.close();\n                        },\n                        error (reason) {\n                            controller.error(reason);\n                        }\n                    };\n                    await source.start?.(wrappedController);\n                },\n                async pull () {\n                    await source.pull?.(wrappedController);\n                },\n                async cancel (reason) {\n                    await source.cancel?.(reason);\n                }\n            }, wrappedStrategy);\n        }\n    }\n    Consumable.ReadableStream = ReadableStream;\n})($459bb56e0b905665$export$888324e445e7ab42 || ($459bb56e0b905665$export$888324e445e7ab42 = {}));\n\n});\nparcelRegister(\"cilb9\", function(module, exports) {\n\n$parcel$export(module.exports, \"createTask\", () => $8f3798290ba6e406$export$f7292ab7796be73c);\n// `createTask` allows browser DevTools to track the call stack across async boundaries.\nconst { console: $8f3798290ba6e406$var$console } = globalThis;\nconst $8f3798290ba6e406$export$f7292ab7796be73c = $8f3798290ba6e406$var$console?.createTask?.bind($8f3798290ba6e406$var$console) ?? (()=>({\n        run (callback) {\n            return callback();\n        }\n    }));\n\n});\n\n\nparcelRegister(\"b5TnZ\", function(module, exports) {\n\n$parcel$export(module.exports, \"BufferCombiner\", () => $813b1fd2092db7cf$export$b30c524a58e8458c);\n$parcel$export(module.exports, \"DistributionStream\", () => $813b1fd2092db7cf$export$feca7eb4e486f5cf);\n\nvar $5Ywqs = parcelRequire(\"5Ywqs\");\n\nvar $jEctC = parcelRequire(\"jEctC\");\n\nvar $6NYMu = parcelRequire(\"6NYMu\");\nclass $813b1fd2092db7cf$export$b30c524a58e8458c {\n    #capacity;\n    #buffer;\n    #offset;\n    #available;\n    constructor(size){\n        this.#capacity = size;\n        this.#buffer = new Uint8Array(size);\n        this.#offset = 0;\n        this.#available = size;\n    }\n    /**\n     * Pushes data to the combiner.\n     * @param data The input data to be split or combined.\n     * @returns\n     * A generator that yields buffers of specified size.\n     * It may yield the same buffer multiple times, consume the data before calling `next`.\n     */ *push(data) {\n        let offset = 0;\n        let available = data.length;\n        if (this.#offset !== 0) {\n            if (available >= this.#available) {\n                this.#buffer.set(data.subarray(0, this.#available), this.#offset);\n                offset += this.#available;\n                available -= this.#available;\n                yield this.#buffer;\n                this.#offset = 0;\n                this.#available = this.#capacity;\n                if (available === 0) return;\n            } else {\n                this.#buffer.set(data, this.#offset);\n                this.#offset += available;\n                this.#available -= available;\n                return;\n            }\n        }\n        while(available >= this.#capacity){\n            const end = offset + this.#capacity;\n            yield data.subarray(offset, end);\n            offset = end;\n            available -= this.#capacity;\n        }\n        if (available > 0) {\n            this.#buffer.set(data.subarray(offset), this.#offset);\n            this.#offset += available;\n            this.#available -= available;\n        }\n    }\n    flush() {\n        if (this.#offset === 0) return undefined;\n        const output = this.#buffer.subarray(0, this.#offset);\n        this.#offset = 0;\n        this.#available = this.#capacity;\n        return output;\n    }\n}\nclass $813b1fd2092db7cf$export$feca7eb4e486f5cf extends (0, $6NYMu.TransformStream) {\n    constructor(size, combine = false){\n        const combiner = combine ? new $813b1fd2092db7cf$export$b30c524a58e8458c(size) : undefined;\n        super({\n            async transform (chunk, controller) {\n                await (0, $jEctC.MaybeConsumable).tryConsume(chunk, async (chunk)=>{\n                    if (combiner) for (const buffer of combiner.push(chunk))await (0, $5Ywqs.Consumable).ReadableStream.enqueue(controller, buffer);\n                    else {\n                        let offset = 0;\n                        let available = chunk.length;\n                        while(available > 0){\n                            const end = offset + size;\n                            await (0, $5Ywqs.Consumable).ReadableStream.enqueue(controller, chunk.subarray(offset, end));\n                            offset = end;\n                            available -= size;\n                        }\n                    }\n                });\n            },\n            flush (controller) {\n                if (combiner) {\n                    const data = combiner.flush();\n                    if (data) controller.enqueue(data);\n                }\n            }\n        });\n    }\n}\n\n});\nparcelRegister(\"jEctC\", function(module, exports) {\n\n$parcel$export(module.exports, \"MaybeConsumable\", () => $e4db6e59fbae8999$export$544160f784d9074);\n\nvar $5Ywqs = parcelRequire(\"5Ywqs\");\n\nvar $6NYMu = parcelRequire(\"6NYMu\");\nvar $e4db6e59fbae8999$export$544160f784d9074;\n(function(MaybeConsumable) {\n    function getValue(value) {\n        return value instanceof (0, $5Ywqs.Consumable) ? value.value : value;\n    }\n    MaybeConsumable.getValue = getValue;\n    function tryConsume(value, callback) {\n        if (value instanceof (0, $5Ywqs.Consumable)) return value.tryConsume(callback);\n        else return callback(value);\n    }\n    MaybeConsumable.tryConsume = tryConsume;\n    class UnwrapStream extends (0, $6NYMu.TransformStream) {\n        constructor(){\n            super({\n                transform (chunk, controller) {\n                    MaybeConsumable.tryConsume(chunk, (chunk)=>{\n                        controller.enqueue(chunk);\n                    });\n                }\n            });\n        }\n    }\n    MaybeConsumable.UnwrapStream = UnwrapStream;\n    class WritableStream extends (0, $6NYMu.WritableStream) {\n        constructor(sink, strategy){\n            let wrappedStrategy;\n            if (strategy) {\n                wrappedStrategy = {};\n                if (\"highWaterMark\" in strategy) wrappedStrategy.highWaterMark = strategy.highWaterMark;\n                if (\"size\" in strategy) wrappedStrategy.size = (chunk)=>{\n                    return strategy.size(chunk instanceof (0, $5Ywqs.Consumable) ? chunk.value : chunk);\n                };\n            }\n            super({\n                start (controller) {\n                    return sink.start?.(controller);\n                },\n                async write (chunk, controller) {\n                    await MaybeConsumable.tryConsume(chunk, (chunk)=>sink.write?.(chunk, controller));\n                },\n                abort (reason) {\n                    return sink.abort?.(reason);\n                },\n                close () {\n                    return sink.close?.();\n                }\n            }, wrappedStrategy);\n        }\n    }\n    MaybeConsumable.WritableStream = WritableStream;\n})($e4db6e59fbae8999$export$544160f784d9074 || ($e4db6e59fbae8999$export$544160f784d9074 = {}));\n\n});\n\n\nparcelRegister(\"bwQFm\", function(module, exports) {\n\n$parcel$export(module.exports, \"DuplexStreamFactory\", () => $864b8946dafa2700$export$98fb3f973b596bf2);\nparcelRequire(\"kV55x\");\nvar $aHKds = parcelRequire(\"aHKds\");\n\nvar $6NYMu = parcelRequire(\"6NYMu\");\n\nvar $cSu3L = parcelRequire(\"cSu3L\");\nconst $864b8946dafa2700$var$NOOP = ()=>{\n// no-op\n};\nclass $864b8946dafa2700$export$98fb3f973b596bf2 {\n    #readableControllers = [];\n    #writers = [];\n    #writableClosed = false;\n    get writableClosed() {\n        return this.#writableClosed;\n    }\n    #closed = new (0, $aHKds.PromiseResolver)();\n    get closed() {\n        return this.#closed.promise;\n    }\n    #options;\n    constructor(options){\n        this.#options = options ?? {};\n    }\n    wrapReadable(readable, strategy) {\n        return new (0, $cSu3L.WrapReadableStream)({\n            start: (controller)=>{\n                this.#readableControllers.push(controller);\n                return readable;\n            },\n            cancel: async ()=>{\n                // cancel means the local peer wants to close the connection.\n                await this.close();\n            },\n            close: async ()=>{\n                // stream end means the remote peer closed the connection first.\n                await this.dispose();\n            }\n        }, strategy);\n    }\n    createWritable(stream) {\n        const writer = stream.getWriter();\n        this.#writers.push(writer);\n        // `WritableStream` has no way to tell if the remote peer has closed the connection.\n        // So it only triggers `close`.\n        return new (0, $6NYMu.WritableStream)({\n            write: async (chunk)=>{\n                await writer.write(chunk);\n            },\n            abort: async (reason)=>{\n                await writer.abort(reason);\n                await this.close();\n            },\n            close: async ()=>{\n                // NOOP: the writer is already closed\n                await writer.close().catch($864b8946dafa2700$var$NOOP);\n                await this.close();\n            }\n        });\n    }\n    async close() {\n        if (this.#writableClosed) return;\n        this.#writableClosed = true;\n        // Call `close` first, so it can still write data to `WritableStream`s.\n        if (await this.#options.close?.() !== false) // `close` can return `false` to disable automatic `dispose`.\n        await this.dispose();\n        for (const writer of this.#writers)// NOOP: the writer is already closed\n        writer.close().catch($864b8946dafa2700$var$NOOP);\n    }\n    async dispose() {\n        this.#writableClosed = true;\n        this.#closed.resolve();\n        for (const controller of this.#readableControllers)try {\n            controller.close();\n        } catch  {\n        // ignore\n        }\n        await this.#options.dispose?.();\n    }\n}\n\n});\nparcelRegister(\"cSu3L\", function(module, exports) {\n\n$parcel$export(module.exports, \"WrapReadableStream\", () => $9601d8647e507a4c$export$85a7b9d088379e9e);\n\nvar $6NYMu = parcelRequire(\"6NYMu\");\nfunction $9601d8647e507a4c$var$getWrappedReadableStream(wrapper, controller) {\n    if (\"start\" in wrapper) return wrapper.start(controller);\n    else if (typeof wrapper === \"function\") return wrapper(controller);\n    else // Can't use `wrapper instanceof ReadableStream`\n    // Because we want to be compatible with any ReadableStream-like objects\n    return wrapper;\n}\nclass $9601d8647e507a4c$export$85a7b9d088379e9e extends (0, $6NYMu.ReadableStream) {\n    readable;\n    #reader;\n    constructor(wrapper, strategy){\n        super({\n            start: async (controller)=>{\n                // `start` is invoked before `ReadableStream`'s constructor finish,\n                // so using `this` synchronously causes\n                // \"Must call super constructor in derived class before accessing 'this' or returning from derived constructor\".\n                // Queue a microtask to avoid this.\n                await Promise.resolve();\n                this.readable = await $9601d8647e507a4c$var$getWrappedReadableStream(wrapper, controller);\n                this.#reader = this.readable.getReader();\n            },\n            pull: async (controller)=>{\n                const result = await this.#reader.read();\n                if (result.done) {\n                    controller.close();\n                    if (\"close\" in wrapper) await wrapper.close?.();\n                } else controller.enqueue(result.value);\n            },\n            cancel: async (reason)=>{\n                await this.#reader.cancel(reason);\n                if (\"cancel\" in wrapper) await wrapper.cancel?.(reason);\n            }\n        }, strategy);\n    }\n}\n\n});\n\n\nparcelRegister(\"koQVx\", function(module, exports) {\n\n$parcel$export(module.exports, \"TextDecoderStream\", () => $ed9f1ac4caa555e8$export$a47f15ea2f3a718a);\nconst $ed9f1ac4caa555e8$var$Global = globalThis;\nconst $ed9f1ac4caa555e8$export$a47f15ea2f3a718a = $ed9f1ac4caa555e8$var$Global.TextDecoderStream;\nconst $ed9f1ac4caa555e8$export$d6af92c119329dd1 = $ed9f1ac4caa555e8$var$Global.TextEncoderStream;\n\n});\n\nparcelRegister(\"4eHDJ\", function(module, exports) {\n\nvar $6NYMu = parcelRequire(\"6NYMu\");\nclass $315a522dec2122a9$export$4ebc589aac5c3f5f extends (0, $6NYMu.TransformStream) {\n    constructor(callback){\n        super({\n            transform (chunk, controller) {\n                callback(chunk);\n                controller.enqueue(chunk);\n            }\n        });\n    }\n}\n\n});\n\nparcelRegister(\"3Ppgt\", function(module, exports) {\n\n$parcel$export(module.exports, \"pipeFrom\", () => $2c99bb95550a3c12$export$d407da7ebfa84417);\n\nvar $6NYMu = parcelRequire(\"6NYMu\");\nfunction $2c99bb95550a3c12$export$d407da7ebfa84417(writable, pair) {\n    const writer = pair.writable.getWriter();\n    const pipe = pair.readable.pipeTo(writable);\n    return new (0, $6NYMu.WritableStream)({\n        async write (chunk) {\n            await writer.write(chunk);\n        },\n        async close () {\n            await writer.close();\n            await pipe;\n        }\n    });\n}\n\n});\n\nparcelRegister(\"jbstH\", function(module, exports) {\n\nvar $6NYMu = parcelRequire(\"6NYMu\");\nfunction* $df75228a7787164b$var$split(input, separator) {\n    let start = 0;\n    while(true){\n        const index = input.indexOf(separator, start);\n        if (index === -1) return;\n        const part = input.substring(start, index);\n        yield part;\n        start = index + 1;\n    }\n}\nclass $df75228a7787164b$export$6ff6004bc16f7ed4 extends (0, $6NYMu.TransformStream) {\n    constructor(separator){\n        super({\n            transform (chunk, controller) {\n                for (const part of $df75228a7787164b$var$split(chunk, separator))controller.enqueue(part);\n            }\n        });\n    }\n}\n\n});\n\nparcelRegister(\"ebpYL\", function(module, exports) {\n\n$parcel$export(module.exports, \"StructDeserializeStream\", () => $a5363ea64eecd913$export$e8da4e75be156fae);\n\nvar $1QeNb = parcelRequire(\"1QeNb\");\nclass $a5363ea64eecd913$export$e8da4e75be156fae extends (0, $1QeNb.BufferedTransformStream) {\n    constructor(struct){\n        super((stream)=>{\n            return struct.deserialize(stream);\n        });\n    }\n}\n\n});\n\nparcelRegister(\"1yRYZ\", function(module, exports) {\n\nvar $6NYMu = parcelRequire(\"6NYMu\");\nclass $1232d747f46baf59$export$783a776b9d0340da extends (0, $6NYMu.TransformStream) {\n    constructor(struct){\n        super({\n            transform (chunk, controller) {\n                controller.enqueue(struct.serialize(chunk));\n            }\n        });\n    }\n}\n\n});\n\nparcelRegister(\"67qk3\", function(module, exports) {\n\n$parcel$export(module.exports, \"WrapWritableStream\", () => $4747d098e697958e$export$98b7c608564c82c4);\n\nvar $6NYMu = parcelRequire(\"6NYMu\");\nasync function $4747d098e697958e$var$getWrappedWritableStream(start) {\n    if (\"start\" in start) return await start.start();\n    else if (typeof start === \"function\") return await start();\n    else // Can't use `wrapper instanceof WritableStream`\n    // Because we want to be compatible with any WritableStream-like objects\n    return start;\n}\nclass $4747d098e697958e$export$98b7c608564c82c4 extends (0, $6NYMu.WritableStream) {\n    writable;\n    #writer;\n    constructor(start){\n        super({\n            start: async ()=>{\n                // `start` is invoked before `ReadableStream`'s constructor finish,\n                // so using `this` synchronously causes\n                // \"Must call super constructor in derived class before accessing 'this' or returning from derived constructor\".\n                // Queue a microtask to avoid this.\n                await Promise.resolve();\n                this.writable = await $4747d098e697958e$var$getWrappedWritableStream(start);\n                this.#writer = this.writable.getWriter();\n            },\n            write: async (chunk)=>{\n                await this.#writer.write(chunk);\n            },\n            abort: async (reason)=>{\n                await this.#writer.abort(reason);\n                if (start !== this.writable && \"close\" in start) await start.close?.();\n            },\n            close: async ()=>{\n                // Close the inner stream first.\n                // Usually the inner stream is a logical sub-stream over the outer stream,\n                // closing the outer stream first will make the inner stream incapable of\n                // sending data in its `close` handler.\n                await this.#writer.close();\n                if (start !== this.writable && \"close\" in start) await start.close?.();\n            }\n        });\n    }\n    bePipedThroughFrom(transformer) {\n        let promise;\n        return new $4747d098e697958e$export$98b7c608564c82c4({\n            start: ()=>{\n                promise = transformer.readable.pipeTo(this);\n                return transformer.writable;\n            },\n            async close () {\n                await promise;\n            }\n        });\n    }\n}\n\n});\n\n\nparcelRegister(\"chJ24\", function(module, exports) {\n$parcel$export(module.exports, \"framebuffer\", () => (parcelRequire(\"755W6\")).framebuffer);\n$parcel$export(module.exports, \"AdbPower\", () => (parcelRequire(\"5WSZn\")).AdbPower);\n$parcel$export(module.exports, \"AdbReverseCommand\", () => (parcelRequire(\"gequt\")).AdbReverseCommand);\n$parcel$export(module.exports, \"AdbSubprocess\", () => (parcelRequire(\"5jHg5\")).AdbSubprocess);\n$parcel$export(module.exports, \"AdbSubprocessShellProtocol\", () => (parcelRequire(\"23OH0\")).AdbSubprocessShellProtocol);\n$parcel$export(module.exports, \"escapeArg\", () => (parcelRequire(\"beA73\")).escapeArg);\n$parcel$export(module.exports, \"AdbSync\", () => (parcelRequire(\"aBc50\")).AdbSync);\n$parcel$export(module.exports, \"AdbTcpIpCommand\", () => (parcelRequire(\"liel6\")).AdbTcpIpCommand);\nparcelRequire(\"2TOFC\");\nparcelRequire(\"755W6\");\nparcelRequire(\"5WSZn\");\nparcelRequire(\"gequt\");\nparcelRequire(\"ezTiR\");\nparcelRequire(\"3HODG\");\nparcelRequire(\"liel6\");\n\n});\nparcelRegister(\"2TOFC\", function(module, exports) {\n\n$parcel$export(module.exports, \"AdbCommandBase\", () => $21c805dd93e00cd7$export$6c55dba0cc5f72fb);\nparcelRequire(\"hpom2\");\nvar $aGQPd = parcelRequire(\"aGQPd\");\nclass $21c805dd93e00cd7$export$6c55dba0cc5f72fb extends (0, $aGQPd.AutoDisposable) {\n    adb;\n    constructor(adb){\n        super();\n        this.adb = adb;\n    }\n}\n\n});\nparcelRegister(\"hpom2\", function(module, exports) {\n$parcel$export(module.exports, \"AutoDisposable\", () => (parcelRequire(\"aGQPd\")).AutoDisposable);\nparcelRequire(\"aGQPd\");\nparcelRequire(\"67ny9\");\nparcelRequire(\"lreyP\");\nparcelRequire(\"5oa12\");\n\n});\nparcelRegister(\"aGQPd\", function(module, exports) {\n\n$parcel$export(module.exports, \"AutoDisposable\", () => $7c86cd92403ce500$export$a22a94f7d5cef8d5);\nclass $7c86cd92403ce500$export$a22a94f7d5cef8d5 {\n    #disposables = [];\n    constructor(){\n        this.dispose = this.dispose.bind(this);\n    }\n    addDisposable(disposable) {\n        this.#disposables.push(disposable);\n        return disposable;\n    }\n    dispose() {\n        for (const disposable of this.#disposables)disposable.dispose();\n        this.#disposables = [];\n    }\n}\nclass $7c86cd92403ce500$export$d6ed760be7336d34 extends $7c86cd92403ce500$export$a22a94f7d5cef8d5 {\n    add(disposable) {\n        return this.addDisposable(disposable);\n    }\n}\n\n});\n\nparcelRegister(\"67ny9\", function(module, exports) {\n\n});\n\nparcelRegister(\"lreyP\", function(module, exports) {\nclass $f9b76a0a34481251$export$4fae95256245c8c0 {\n    listeners = [];\n    constructor(){\n        this.event = this.event.bind(this);\n    }\n    addEventListener(info) {\n        this.listeners.push(info);\n        const remove = ()=>{\n            const index = this.listeners.indexOf(info);\n            if (index !== -1) this.listeners.splice(index, 1);\n        };\n        remove.dispose = remove;\n        return remove;\n    }\n    event = (listener, thisArg, ...args)=>{\n        const info = {\n            listener: listener,\n            thisArg: thisArg,\n            args: args\n        };\n        return this.addEventListener(info);\n    };\n    fire(e) {\n        for (const info of this.listeners.slice())info.listener.apply(info.thisArg, [\n            e,\n            ...info.args\n        ]);\n    }\n    dispose() {\n        this.listeners.length = 0;\n    }\n}\n\n});\n\nparcelRegister(\"5oa12\", function(module, exports) {\nparcelRequire(\"kV55x\");\nvar $aHKds = parcelRequire(\"aHKds\");\nasync function $3ec6f68da26e5927$export$d2de3aaeafa91619(event) {\n    const resolver = new (0, $aHKds.PromiseResolver)();\n    const dispose = event(resolver.resolve);\n    const result = await resolver.promise;\n    dispose();\n    return result;\n}\n\n});\n\n\n\nparcelRegister(\"755W6\", function(module, exports) {\n\n$parcel$export(module.exports, \"framebuffer\", () => $527d9ad6cf7afd05$export$4ed6c7c560c63868);\nparcelRequire(\"7edQJ\");\nvar $bJSM1 = parcelRequire(\"bJSM1\");\nparcelRequire(\"hr1EK\");\nvar $9LJSP = parcelRequire(\"9LJSP\");\nconst $527d9ad6cf7afd05$var$Version = new (0, $9LJSP.Struct)({\n    littleEndian: true\n}).uint32(\"version\");\nconst $527d9ad6cf7afd05$export$4c5fa6579699b052 = new (0, $9LJSP.Struct)({\n    littleEndian: true\n}).uint32(\"bpp\").uint32(\"size\").uint32(\"width\").uint32(\"height\").uint32(\"red_offset\").uint32(\"red_length\").uint32(\"blue_offset\").uint32(\"blue_length\").uint32(\"green_offset\").uint32(\"green_length\").uint32(\"alpha_offset\").uint32(\"alpha_length\").uint8Array(\"data\", {\n    lengthField: \"size\"\n});\nconst $527d9ad6cf7afd05$export$d0bda24c79a1d603 = new (0, $9LJSP.Struct)({\n    littleEndian: true\n}).uint32(\"bpp\").uint32(\"colorSpace\").uint32(\"size\").uint32(\"width\").uint32(\"height\").uint32(\"red_offset\").uint32(\"red_length\").uint32(\"blue_offset\").uint32(\"blue_length\").uint32(\"green_offset\").uint32(\"green_length\").uint32(\"alpha_offset\").uint32(\"alpha_length\").uint8Array(\"data\", {\n    lengthField: \"size\"\n});\nclass $527d9ad6cf7afd05$export$31b42747346031c6 extends Error {\n    constructor(message, options){\n        super(message, options);\n    }\n}\nclass $527d9ad6cf7afd05$export$4fe684c7fc4bab42 extends $527d9ad6cf7afd05$export$31b42747346031c6 {\n    constructor(version){\n        super(`Unsupported FrameBuffer version ${version}`);\n    }\n}\nclass $527d9ad6cf7afd05$export$b1ac6f66a424282e extends $527d9ad6cf7afd05$export$31b42747346031c6 {\n    constructor(){\n        super(\"FrameBuffer is disabled by current app\");\n    }\n}\nasync function $527d9ad6cf7afd05$export$4ed6c7c560c63868(adb) {\n    const socket = await adb.createSocket(\"framebuffer:\");\n    const stream = new (0, $bJSM1.BufferedReadableStream)(socket.readable);\n    let version;\n    try {\n        ({ version: version } = await $527d9ad6cf7afd05$var$Version.deserialize(stream));\n    } catch (e) {\n        if (e instanceof (0, $9LJSP.StructEmptyError)) throw new $527d9ad6cf7afd05$export$b1ac6f66a424282e();\n        throw e;\n    }\n    switch(version){\n        case 1:\n            // TODO: AdbFrameBuffer: does all v1 responses uses the same color space? Add it so the command returns same format for all versions.\n            return $527d9ad6cf7afd05$export$4c5fa6579699b052.deserialize(stream);\n        case 2:\n            return $527d9ad6cf7afd05$export$d0bda24c79a1d603.deserialize(stream);\n        default:\n            throw new $527d9ad6cf7afd05$export$4fe684c7fc4bab42(version);\n    }\n}\n\n});\n\nparcelRegister(\"5WSZn\", function(module, exports) {\n\n$parcel$export(module.exports, \"AdbPower\", () => $454d062a32aa0607$export$9b4dc8cf402dd991);\n// cspell: ignore bootloader\n// cspell: ignore fastboot\n// cspell: ignore keyevent\n// cspell: ignore longpress\n\nvar $2TOFC = parcelRequire(\"2TOFC\");\nclass $454d062a32aa0607$export$9b4dc8cf402dd991 extends (0, $2TOFC.AdbCommandBase) {\n    reboot(mode = \"\") {\n        return this.adb.createSocketAndWait(`reboot:${mode}`);\n    }\n    bootloader() {\n        return this.reboot(\"bootloader\");\n    }\n    fastboot() {\n        return this.reboot(\"fastboot\");\n    }\n    recovery() {\n        return this.reboot(\"recovery\");\n    }\n    sideload() {\n        return this.reboot(\"sideload\");\n    }\n    /**\n     * Reboot to Qualcomm Emergency Download (EDL) Mode.\n     *\n     * Only works on some Qualcomm devices.\n     */ qualcommEdlMode() {\n        return this.reboot(\"edl\");\n    }\n    powerOff() {\n        return this.adb.subprocess.spawnAndWaitLegacy([\n            \"reboot\",\n            \"-p\"\n        ]);\n    }\n    powerButton(longPress = false) {\n        const args = [\n            \"input\",\n            \"keyevent\"\n        ];\n        if (longPress) args.push(\"--longpress\");\n        args.push(\"POWER\");\n        return this.adb.subprocess.spawnAndWaitLegacy(args);\n    }\n    /**\n     * Reboot to Samsung Odin download mode.\n     *\n     * Only works on Samsung devices.\n     */ samsungOdin() {\n        return this.reboot(\"download\");\n    }\n}\n\n});\n\nparcelRegister(\"gequt\", function(module, exports) {\n\n$parcel$export(module.exports, \"AdbReverseCommand\", () => $bd12809a72d921e3$export$f48b52846b274f79);\n// cspell: ignore killforward\nparcelRequire(\"hpom2\");\nvar $aGQPd = parcelRequire(\"aGQPd\");\nparcelRequire(\"7edQJ\");\nvar $bJSM1 = parcelRequire(\"bJSM1\");\nparcelRequire(\"hr1EK\");\nvar $9LJSP = parcelRequire(\"9LJSP\");\nvar $6Savq = parcelRequire(\"6Savq\");\nvar $70dme = parcelRequire(\"70dme\");\nparcelRequire(\"5lBQi\");\nvar $32bmk = parcelRequire(\"32bmk\");\nvar $gtlgZ = parcelRequire(\"gtlgZ\");\nconst $bd12809a72d921e3$var$AdbReverseStringResponse = new (0, $9LJSP.Struct)().string(\"length\", {\n    length: 4\n}).string(\"content\", {\n    lengthField: \"length\",\n    lengthFieldRadix: 16\n});\nclass $bd12809a72d921e3$export$12a5efc419918650 extends Error {\n    constructor(message){\n        super(message);\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\nclass $bd12809a72d921e3$export$ae7a90ef18b5896a extends $bd12809a72d921e3$export$12a5efc419918650 {\n    constructor(){\n        super(\"ADB reverse tunnel is not supported on this device when connected wirelessly.\");\n    }\n}\nconst $bd12809a72d921e3$var$AdbReverseErrorResponse = new (0, $9LJSP.Struct)().concat($bd12809a72d921e3$var$AdbReverseStringResponse).postDeserialize((value)=>{\n    // https://issuetracker.google.com/issues/37066218\n    // ADB on Android <9 can't create reverse tunnels when connected wirelessly (ADB over Wi-Fi),\n    // and returns this confusing \"more than one device/emulator\" error.\n    if (value.content === \"more than one device/emulator\") throw new $bd12809a72d921e3$export$ae7a90ef18b5896a();\n    else throw new $bd12809a72d921e3$export$12a5efc419918650(value.content);\n});\n// Like `hexToNumber`, it's much faster than first converting `buffer` to a string\nfunction $bd12809a72d921e3$var$decimalToNumber(buffer) {\n    let value = 0;\n    for (const byte of buffer){\n        // Like `parseInt`, return when it encounters a non-digit character\n        if (byte < 48 || byte > 57) return value;\n        value = value * 10 + byte - 48;\n    }\n    return value;\n}\nconst $bd12809a72d921e3$var$OKAY = (0, $6Savq.encodeUtf8)(\"OKAY\");\nclass $bd12809a72d921e3$export$f48b52846b274f79 extends (0, $aGQPd.AutoDisposable) {\n    adb;\n    #deviceAddressToLocalAddress = new Map();\n    constructor(adb){\n        super();\n        this.adb = adb;\n    }\n    async createBufferedStream(service) {\n        const socket = await this.adb.createSocket(service);\n        return new (0, $bJSM1.BufferedReadableStream)(socket.readable);\n    }\n    async sendRequest(service) {\n        const stream = await this.createBufferedStream(service);\n        const response = await stream.readExactly(4);\n        if (!(0, $gtlgZ.sequenceEqual)(response, $bd12809a72d921e3$var$OKAY)) await $bd12809a72d921e3$var$AdbReverseErrorResponse.deserialize(stream);\n        return stream;\n    }\n    async list() {\n        const stream = await this.createBufferedStream(\"reverse:list-forward\");\n        const response = await $bd12809a72d921e3$var$AdbReverseStringResponse.deserialize(stream);\n        return response.content.split(\"\\n\").filter((line)=>!!line).map((line)=>{\n            const [deviceSerial, localName, remoteName] = line.split(\" \");\n            return {\n                deviceSerial: deviceSerial,\n                localName: localName,\n                remoteName: remoteName\n            };\n        });\n    // No need to close the stream, device will close it\n    }\n    /**\n     * Add an already existing reverse tunnel. Depends on the transport type, this may not do anything.\n     * @param deviceAddress The address to be listened on device by ADB daemon. Or `tcp:0` to choose an available TCP port.\n     * @param localAddress The address that listens on the local machine.\n     * @returns `tcp:{ACTUAL_LISTENING_PORT}`, If `deviceAddress` is `tcp:0`; otherwise, `deviceAddress`.\n     */ async addExternal(deviceAddress, localAddress) {\n        const stream = await this.sendRequest(`reverse:forward:${deviceAddress};${localAddress}`);\n        // `tcp:0` tells the device to pick an available port.\n        // On Android >=8, device will respond with the selected port for all `tcp:` requests.\n        if (deviceAddress.startsWith(\"tcp:\")) {\n            const position = stream.position;\n            try {\n                const length = (0, $32bmk.hexToNumber)(await stream.readExactly(4));\n                const port = $bd12809a72d921e3$var$decimalToNumber(await stream.readExactly(length));\n                deviceAddress = `tcp:${port}`;\n            } catch (e) {\n                if (e instanceof (0, $70dme.ExactReadableEndedError) && stream.position === position) ;\n                else throw e;\n            }\n        }\n        return deviceAddress;\n    }\n    /**\n     * @param deviceAddress The address to be listened on device by ADB daemon. Or `tcp:0` to choose an available TCP port.\n     * @param handler A callback to handle incoming connections.\n     * @param localAddressThe The address that listens on the local machine. May be `undefined` to let the transport choose an appropriate one.\n     * @returns `tcp:{ACTUAL_LISTENING_PORT}`, If `deviceAddress` is `tcp:0`; otherwise, `deviceAddress`.\n     * @throws {AdbReverseNotSupportedError} If ADB reverse tunnel is not supported on this device when connected wirelessly.\n     * @throws {AdbReverseError} If ADB daemon returns an error.\n     */ async add(deviceAddress, handler, localAddress) {\n        localAddress = await this.adb.transport.addReverseTunnel(handler, localAddress);\n        try {\n            deviceAddress = await this.addExternal(deviceAddress, localAddress);\n            this.#deviceAddressToLocalAddress.set(deviceAddress, localAddress);\n            return deviceAddress;\n        } catch (e) {\n            await this.adb.transport.removeReverseTunnel(localAddress);\n            throw e;\n        }\n    }\n    async remove(deviceAddress) {\n        const localAddress = this.#deviceAddressToLocalAddress.get(deviceAddress);\n        if (localAddress) await this.adb.transport.removeReverseTunnel(localAddress);\n        await this.sendRequest(`reverse:killforward:${deviceAddress}`);\n    // No need to close the stream, device will close it\n    }\n    async removeAll() {\n        await this.adb.transport.clearReverseTunnels();\n        this.#deviceAddressToLocalAddress.clear();\n        await this.sendRequest(`reverse:killforward-all`);\n    // No need to close the stream, device will close it\n    }\n}\n\n});\nparcelRegister(\"5lBQi\", function(module, exports) {\n$parcel$export(module.exports, \"AutoResetEvent\", () => (parcelRequire(\"5SRHv\")).AutoResetEvent);\n$parcel$export(module.exports, \"calculateBase64EncodedLength\", () => (parcelRequire(\"2kccq\")).calculateBase64EncodedLength);\n$parcel$export(module.exports, \"encodeBase64\", () => (parcelRequire(\"2kccq\")).encodeBase64);\n$parcel$export(module.exports, \"hexToNumber\", () => (parcelRequire(\"32bmk\")).hexToNumber);\n$parcel$export(module.exports, \"write4HexDigits\", () => (parcelRequire(\"32bmk\")).write4HexDigits);\n$parcel$export(module.exports, \"NOOP\", () => (parcelRequire(\"fXuIk\")).NOOP);\n$parcel$export(module.exports, \"unreachable\", () => (parcelRequire(\"fXuIk\")).unreachable);\n$parcel$export(module.exports, \"sequenceEqual\", () => (parcelRequire(\"gtlgZ\")).sequenceEqual);\n\n$parcel$export(module.exports, \"encodeUtf8\", () => (parcelRequire(\"6Savq\")).encodeUtf8);\nparcelRequire(\"hr1EK\");\nvar $6Savq = parcelRequire(\"6Savq\");\nparcelRequire(\"5SRHv\");\nparcelRequire(\"2kccq\");\nparcelRequire(\"32bmk\");\nparcelRequire(\"fXuIk\");\nparcelRequire(\"gtlgZ\");\n\n});\nparcelRegister(\"5SRHv\", function(module, exports) {\n\n$parcel$export(module.exports, \"AutoResetEvent\", () => $448ba6c1507a4b6f$export$6c7050fcdf3fbd6b);\nparcelRequire(\"kV55x\");\nvar $aHKds = parcelRequire(\"aHKds\");\nclass $448ba6c1507a4b6f$export$6c7050fcdf3fbd6b {\n    #set;\n    #queue = [];\n    constructor(initialSet = false){\n        this.#set = initialSet;\n    }\n    wait() {\n        if (!this.#set) {\n            this.#set = true;\n            if (this.#queue.length === 0) return Promise.resolve();\n        }\n        const resolver = new (0, $aHKds.PromiseResolver)();\n        this.#queue.push(resolver);\n        return resolver.promise;\n    }\n    notifyOne() {\n        if (this.#queue.length !== 0) this.#queue.pop().resolve();\n        else this.#set = false;\n    }\n    dispose() {\n        for (const item of this.#queue)item.reject(new Error(\"The AutoResetEvent has been disposed\"));\n        this.#queue.length = 0;\n    }\n}\n\n});\n\nparcelRegister(\"2kccq\", function(module, exports) {\n\n$parcel$export(module.exports, \"calculateBase64EncodedLength\", () => $1b16e9917870169f$export$9e6dcb9430409adb);\n$parcel$export(module.exports, \"encodeBase64\", () => $1b16e9917870169f$export$8fb536984ec8b4d7);\n// Array is faster than object literal or `Map`\nconst $1b16e9917870169f$var$charToIndex = [];\nconst $1b16e9917870169f$var$indexToChar = [];\nconst $1b16e9917870169f$var$paddingChar = \"=\".charCodeAt(0);\nfunction $1b16e9917870169f$var$addRange(start, end) {\n    const charCodeStart = start.charCodeAt(0);\n    const charCodeEnd = end.charCodeAt(0);\n    for(let charCode = charCodeStart; charCode <= charCodeEnd; charCode += 1){\n        $1b16e9917870169f$var$charToIndex[charCode] = $1b16e9917870169f$var$indexToChar.length;\n        $1b16e9917870169f$var$indexToChar.push(charCode);\n    }\n}\n$1b16e9917870169f$var$addRange(\"A\", \"Z\");\n$1b16e9917870169f$var$addRange(\"a\", \"z\");\n$1b16e9917870169f$var$addRange(\"0\", \"9\");\n$1b16e9917870169f$var$addRange(\"+\", \"+\");\n$1b16e9917870169f$var$addRange(\"/\", \"/\");\nfunction $1b16e9917870169f$export$9e6dcb9430409adb(inputLength) {\n    const remainder = inputLength % 3;\n    const paddingLength = remainder !== 0 ? 3 - remainder : 0;\n    return [\n        (inputLength + paddingLength) / 3 * 4,\n        paddingLength\n    ];\n}\nfunction $1b16e9917870169f$export$8fb536984ec8b4d7(input, output) {\n    const [outputLength, paddingLength] = $1b16e9917870169f$export$9e6dcb9430409adb(input.length);\n    if (!output) {\n        output = new Uint8Array(outputLength);\n        $1b16e9917870169f$var$encodeForward(input, output, paddingLength);\n        return output;\n    } else {\n        if (output.length < outputLength) throw new TypeError(\"output buffer is too small\");\n        output = output.subarray(0, outputLength);\n        // When input and output are on same ArrayBuffer,\n        // we check if it's possible to encode in-place.\n        if (input.buffer !== output.buffer) $1b16e9917870169f$var$encodeForward(input, output, paddingLength);\n        else if (output.byteOffset + output.length - (paddingLength + 1) <= input.byteOffset + input.length) // Output ends before input ends.\n        // Can encode forwards, because writing output won't catch up with reading input.\n        // The output end is subtracted by `(paddingLength + 1)` because\n        // depending on padding length, it's possible to write 1-3 extra bytes after input ends.\n        //\n        // The following diagrams show how the last read from input and the last write to output\n        // are not conflicting.\n        //\n        // spell: disable\n        //\n        // `paddingLength === 2` can write 3 extra bytes:\n        //\n        //   input:  | aaaaaabb |          |          |          |\n        //   output: |  aaaaaa  |  bb0000  |    =     |    =     |\n        //\n        // `paddingLength === 1` can write 2 extra bytes:\n        //\n        //   input:  | aaaaaabb | bbbbcccc |          |          |\n        //   output: |  aaaaaa  |  bbbbbb  |  cccc00  |    =     |\n        //\n        // `paddingLength === 0` can write 1 extra byte:\n        //\n        //   input:  | aaaaaabb | bbbbcccc | ccdddddd |          |\n        //   output: |  aaaaaa  |  bbbbbb  |  cccccc  |  dddddd  |\n        //\n        // spell: enable\n        $1b16e9917870169f$var$encodeForward(input, output, paddingLength);\n        else if (output.byteOffset >= input.byteOffset - 1) // Output starts after input starts\n        // So in backwards, writing output won't catch up with reading input.\n        // The input start is subtracted by `1`, Because as the first 3 bytes becomes 4 bytes,\n        // it's possible to write 1 extra byte before input starts.\n        // spell: disable-next-line\n        //   input:  |          | aaaaaabb | bbbbcccc | ccdddddd |\n        //   output: |  aaaaaa  |  bbbbbb  |  cccccc  |  dddddd  |\n        // Must encode backwards.\n        $1b16e9917870169f$var$encodeBackward(input, output, paddingLength);\n        else // Input is in the middle of output,\n        // It's not possible to read either the first or the last three bytes\n        // before they are overwritten by the output.\n        throw new TypeError(\"input and output cannot overlap\");\n        return outputLength;\n    }\n}\nfunction $1b16e9917870169f$var$encodeForward(input, output, paddingLength) {\n    let inputIndex = 0;\n    let outputIndex = 0;\n    while(inputIndex < input.length - 2){\n        /* cspell: disable-next-line */ // aaaaaabb\n        const x = input[inputIndex];\n        inputIndex += 1;\n        /* cspell: disable-next-line */ // bbbbcccc\n        const y = input[inputIndex];\n        inputIndex += 1;\n        /* cspell: disable-next-line */ // ccdddddd\n        const z = input[inputIndex];\n        inputIndex += 1;\n        output[outputIndex] = $1b16e9917870169f$var$indexToChar[x >> 2];\n        outputIndex += 1;\n        output[outputIndex] = $1b16e9917870169f$var$indexToChar[(x & 3) << 4 | y >> 4];\n        outputIndex += 1;\n        output[outputIndex] = $1b16e9917870169f$var$indexToChar[(y & 15) << 2 | z >> 6];\n        outputIndex += 1;\n        output[outputIndex] = $1b16e9917870169f$var$indexToChar[z & 63];\n        outputIndex += 1;\n    }\n    if (paddingLength === 2) {\n        /* cspell: disable-next-line */ // aaaaaabb\n        const x = input[inputIndex];\n        inputIndex += 1;\n        output[outputIndex] = $1b16e9917870169f$var$indexToChar[x >> 2];\n        outputIndex += 1;\n        output[outputIndex] = $1b16e9917870169f$var$indexToChar[(x & 3) << 4];\n        outputIndex += 1;\n        output[outputIndex] = $1b16e9917870169f$var$paddingChar;\n        outputIndex += 1;\n        output[outputIndex] = $1b16e9917870169f$var$paddingChar;\n    } else if (paddingLength === 1) {\n        /* cspell: disable-next-line */ // aaaaaabb\n        const x = input[inputIndex];\n        inputIndex += 1;\n        /* cspell: disable-next-line */ // bbbbcccc\n        const y = input[inputIndex];\n        inputIndex += 1;\n        output[outputIndex] = $1b16e9917870169f$var$indexToChar[x >> 2];\n        outputIndex += 1;\n        output[outputIndex] = $1b16e9917870169f$var$indexToChar[(x & 3) << 4 | y >> 4];\n        outputIndex += 1;\n        output[outputIndex] = $1b16e9917870169f$var$indexToChar[(y & 15) << 2];\n        outputIndex += 1;\n        output[outputIndex] = $1b16e9917870169f$var$paddingChar;\n    }\n}\nfunction $1b16e9917870169f$var$encodeBackward(input, output, paddingLength) {\n    let inputIndex = input.length - 1;\n    let outputIndex = output.length - 1;\n    if (paddingLength === 2) {\n        /* cspell: disable-next-line */ // aaaaaabb\n        const x = input[inputIndex];\n        inputIndex -= 1;\n        output[outputIndex] = $1b16e9917870169f$var$paddingChar;\n        outputIndex -= 1;\n        output[outputIndex] = $1b16e9917870169f$var$paddingChar;\n        outputIndex -= 1;\n        output[outputIndex] = $1b16e9917870169f$var$indexToChar[(x & 3) << 4];\n        outputIndex -= 1;\n        output[outputIndex] = $1b16e9917870169f$var$indexToChar[x >> 2];\n        outputIndex -= 1;\n    } else if (paddingLength === 1) {\n        /* cspell: disable-next-line */ // bbbbcccc\n        const y = input[inputIndex];\n        inputIndex -= 1;\n        /* cspell: disable-next-line */ // aaaaaabb\n        const x = input[inputIndex];\n        inputIndex -= 1;\n        output[outputIndex] = $1b16e9917870169f$var$paddingChar;\n        outputIndex -= 1;\n        output[outputIndex] = $1b16e9917870169f$var$indexToChar[(y & 15) << 2];\n        outputIndex -= 1;\n        output[outputIndex] = $1b16e9917870169f$var$indexToChar[(x & 3) << 4 | y >> 4];\n        outputIndex -= 1;\n        output[outputIndex] = $1b16e9917870169f$var$indexToChar[x >> 2];\n        outputIndex -= 1;\n    }\n    while(inputIndex >= 0){\n        /* cspell: disable-next-line */ // ccdddddd\n        const z = input[inputIndex];\n        inputIndex -= 1;\n        /* cspell: disable-next-line */ // bbbbcccc\n        const y = input[inputIndex];\n        inputIndex -= 1;\n        /* cspell: disable-next-line */ // aaaaaabb\n        const x = input[inputIndex];\n        inputIndex -= 1;\n        output[outputIndex] = $1b16e9917870169f$var$indexToChar[z & 63];\n        outputIndex -= 1;\n        output[outputIndex] = $1b16e9917870169f$var$indexToChar[(y & 15) << 2 | z >> 6];\n        outputIndex -= 1;\n        output[outputIndex] = $1b16e9917870169f$var$indexToChar[(x & 3) << 4 | y >> 4];\n        outputIndex -= 1;\n        output[outputIndex] = $1b16e9917870169f$var$indexToChar[x >> 2];\n        outputIndex -= 1;\n    }\n}\nfunction $1b16e9917870169f$export$94fdf11bafc8de6b(input) {\n    let padding;\n    if (input[input.length - 2] === \"=\") padding = 2;\n    else if (input[input.length - 1] === \"=\") padding = 1;\n    else padding = 0;\n    const result = new Uint8Array(input.length / 4 * 3 - padding);\n    let sIndex = 0;\n    let dIndex = 0;\n    while(sIndex < input.length - (padding !== 0 ? 4 : 0)){\n        const a = $1b16e9917870169f$var$charToIndex[input.charCodeAt(sIndex)];\n        sIndex += 1;\n        const b = $1b16e9917870169f$var$charToIndex[input.charCodeAt(sIndex)];\n        sIndex += 1;\n        const c = $1b16e9917870169f$var$charToIndex[input.charCodeAt(sIndex)];\n        sIndex += 1;\n        const d = $1b16e9917870169f$var$charToIndex[input.charCodeAt(sIndex)];\n        sIndex += 1;\n        result[dIndex] = a << 2 | (b & 48) >> 4;\n        dIndex += 1;\n        result[dIndex] = (b & 15) << 4 | (c & 60) >> 2;\n        dIndex += 1;\n        result[dIndex] = (c & 3) << 6 | d;\n        dIndex += 1;\n    }\n    if (padding === 1) {\n        const a = $1b16e9917870169f$var$charToIndex[input.charCodeAt(sIndex)];\n        sIndex += 1;\n        const b = $1b16e9917870169f$var$charToIndex[input.charCodeAt(sIndex)];\n        sIndex += 1;\n        const c = $1b16e9917870169f$var$charToIndex[input.charCodeAt(sIndex)];\n        result[dIndex] = a << 2 | (b & 48) >> 4;\n        dIndex += 1;\n        result[dIndex] = (b & 15) << 4 | (c & 60) >> 2;\n    } else if (padding === 2) {\n        const a = $1b16e9917870169f$var$charToIndex[input.charCodeAt(sIndex)];\n        sIndex += 1;\n        const b = $1b16e9917870169f$var$charToIndex[input.charCodeAt(sIndex)];\n        result[dIndex] = a << 2 | (b & 48) >> 4;\n    }\n    return result;\n}\n\n});\n\nparcelRegister(\"32bmk\", function(module, exports) {\n\n$parcel$export(module.exports, \"hexToNumber\", () => $235a5eb6b9daa8b2$export$d57f2bacc26b4249);\n$parcel$export(module.exports, \"write4HexDigits\", () => $235a5eb6b9daa8b2$export$6109e2907f86231a);\nfunction $235a5eb6b9daa8b2$var$hexCharToNumber(char) {\n    if (char < 48) throw new TypeError(`Invalid hex char ${char}`);\n    if (char < 58) // 0-9\n    return char - 48;\n    if (char < 65) throw new TypeError(`Invalid hex char ${char}`);\n    if (char < 71) // A-F\n    return char - 55;\n    if (char < 97) throw new TypeError(`Invalid hex char ${char}`);\n    if (char < 103) // a-f\n    return char - 87;\n    throw new TypeError(`Invalid hex char ${char}`);\n}\nfunction $235a5eb6b9daa8b2$export$d57f2bacc26b4249(data) {\n    let result = 0;\n    for(let i = 0; i < data.length; i += 1)result = result << 4 | $235a5eb6b9daa8b2$var$hexCharToNumber(data[i]);\n    return result;\n}\nfunction $235a5eb6b9daa8b2$export$6109e2907f86231a(buffer, index, value) {\n    const start = index;\n    index += 3;\n    while(index >= start && value > 0){\n        const digit = value & 0xf;\n        value >>= 4;\n        if (digit < 10) buffer[index] = digit + 48; // '0'\n        else buffer[index] = digit + 87; // 'a' - 10\n        index -= 1;\n    }\n    while(index >= start){\n        buffer[index] = 48; // '0'\n        index -= 1;\n    }\n}\n\n});\n\nparcelRegister(\"fXuIk\", function(module, exports) {\n\n$parcel$export(module.exports, \"NOOP\", () => $b9e430d7f1e7a460$export$5702a91a6f42969f);\n$parcel$export(module.exports, \"unreachable\", () => $b9e430d7f1e7a460$export$565e9d9bd6b6e0d4);\nconst $b9e430d7f1e7a460$export$5702a91a6f42969f = ()=>{\n// no-op\n};\nfunction $b9e430d7f1e7a460$export$565e9d9bd6b6e0d4(...args) {\n    // Trigger runtime's unhandled rejection event.\n    throw new Error(\"Unreachable. Arguments:\\n\" + args.join(\"\\n\"));\n}\n\n});\n\nparcelRegister(\"gtlgZ\", function(module, exports) {\n\n$parcel$export(module.exports, \"sequenceEqual\", () => $bfdfdb21e3c32026$export$d0a07e60ae428313);\nfunction $bfdfdb21e3c32026$export$d0a07e60ae428313(a, b) {\n    if (a.length !== b.length) return false;\n    for(let i = 0; i < a.length; i += 1){\n        if (a[i] !== b[i]) return false;\n    }\n    return true;\n}\n\n});\n\n\n\nparcelRegister(\"ezTiR\", function(module, exports) {\n$parcel$export(module.exports, \"AdbSubprocess\", () => (parcelRequire(\"5jHg5\")).AdbSubprocess);\n$parcel$export(module.exports, \"AdbSubprocessShellProtocol\", () => (parcelRequire(\"23OH0\")).AdbSubprocessShellProtocol);\n$parcel$export(module.exports, \"escapeArg\", () => (parcelRequire(\"beA73\")).escapeArg);\nparcelRequire(\"5jHg5\");\nparcelRequire(\"cv2l6\");\nparcelRequire(\"beA73\");\n\n});\nparcelRegister(\"5jHg5\", function(module, exports) {\n\n$parcel$export(module.exports, \"AdbSubprocess\", () => $3df04856ab447e80$export$7a6597f9fb12f14e);\nparcelRequire(\"7edQJ\");\nvar $k61Wg = parcelRequire(\"k61Wg\");\nvar $koQVx = parcelRequire(\"koQVx\");\n\nvar $2TOFC = parcelRequire(\"2TOFC\");\nparcelRequire(\"cv2l6\");\nvar $co9iz = parcelRequire(\"co9iz\");\nvar $23OH0 = parcelRequire(\"23OH0\");\nconst $3df04856ab447e80$var$DEFAULT_OPTIONS = {\n    protocols: [\n        (0, $23OH0.AdbSubprocessShellProtocol),\n        (0, $co9iz.AdbSubprocessNoneProtocol)\n    ]\n};\nclass $3df04856ab447e80$export$7a6597f9fb12f14e extends (0, $2TOFC.AdbCommandBase) {\n    async #createProtocol(mode, command, options) {\n        const { protocols: protocols } = {\n            ...$3df04856ab447e80$var$DEFAULT_OPTIONS,\n            ...options\n        };\n        let Constructor;\n        for (const item of protocols)// It's async so can't use `Array#find`\n        if (await item.isSupported(this.adb)) {\n            Constructor = item;\n            break;\n        }\n        if (!Constructor) throw new Error(\"No specified protocol is supported by the device\");\n        if (Array.isArray(command)) command = command.join(\" \");\n        else if (command === undefined) // spawn the default shell\n        command = \"\";\n        return await Constructor[mode](this.adb, command);\n    }\n    /**\n     * Spawns an executable in PTY mode.\n     *\n     * Redirection mode is enough for most simple commands, but PTY mode is required for\n     * commands that manipulate the terminal, such as `vi` and `less`.\n     * @param command The command to run. If omitted, the default shell will be spawned.\n     * @param options The options for creating the `AdbSubprocessProtocol`\n     * @returns A new `AdbSubprocessProtocol` instance connecting to the spawned process.\n     */ shell(command, options) {\n        return this.#createProtocol(\"pty\", command, options);\n    }\n    /**\n     * Spawns an executable and redirect the standard input/output stream.\n     *\n     * Redirection mode is enough for most simple commands, but PTY mode is required for\n     * commands that manipulate the terminal, such as `vi` and `less`.\n     * @param command The command to run, or an array of strings containing both command and args.\n     * @param options The options for creating the `AdbSubprocessProtocol`\n     * @returns A new `AdbSubprocessProtocol` instance connecting to the spawned process.\n     */ spawn(command, options) {\n        return this.#createProtocol(\"raw\", command, options);\n    }\n    /**\n     * Spawns a new process, waits until it exits, and returns the entire output.\n     * @param command The command to run\n     * @param options The options for creating the `AdbSubprocessProtocol`\n     * @returns The entire output of the command\n     */ async spawnAndWait(command, options) {\n        const process = await this.spawn(command, options);\n        const [stdout, stderr, exitCode] = await Promise.all([\n            process.stdout.pipeThrough(new (0, $koQVx.TextDecoderStream)()).pipeThrough(new (0, $k61Wg.ConcatStringStream)()),\n            process.stderr.pipeThrough(new (0, $koQVx.TextDecoderStream)()).pipeThrough(new (0, $k61Wg.ConcatStringStream)()),\n            process.exit\n        ]);\n        return {\n            stdout: stdout,\n            stderr: stderr,\n            exitCode: exitCode\n        };\n    }\n    /**\n     * Spawns a new process, waits until it exits, and returns the entire output.\n     * @param command The command to run\n     * @returns The entire output of the command\n     */ async spawnAndWaitLegacy(command) {\n        const { stdout: stdout } = await this.spawnAndWait(command, {\n            protocols: [\n                (0, $co9iz.AdbSubprocessNoneProtocol)\n            ]\n        });\n        return stdout;\n    }\n}\n\n});\nparcelRegister(\"cv2l6\", function(module, exports) {\n$parcel$export(module.exports, \"AdbSubprocessNoneProtocol\", () => (parcelRequire(\"co9iz\")).AdbSubprocessNoneProtocol);\n$parcel$export(module.exports, \"AdbSubprocessShellProtocol\", () => (parcelRequire(\"23OH0\")).AdbSubprocessShellProtocol);\nparcelRequire(\"co9iz\");\nparcelRequire(\"23OH0\");\nparcelRequire(\"cUsti\");\n\n});\nparcelRegister(\"co9iz\", function(module, exports) {\n\n$parcel$export(module.exports, \"AdbSubprocessNoneProtocol\", () => $904ef069d7a99ac4$export$d83482397cfbf8db);\nparcelRequire(\"7edQJ\");\nvar $6NYMu = parcelRequire(\"6NYMu\");\nparcelRequire(\"5lBQi\");\nvar $fXuIk = parcelRequire(\"fXuIk\");\nclass $904ef069d7a99ac4$export$d83482397cfbf8db {\n    static isSupported() {\n        return true;\n    }\n    static async pty(adb, command) {\n        return new $904ef069d7a99ac4$export$d83482397cfbf8db(await adb.createSocket(`shell:${command}`));\n    }\n    static async raw(adb, command) {\n        // `shell,raw:${command}` also triggers raw mode,\n        // But is not supported on Android version <7.\n        return new $904ef069d7a99ac4$export$d83482397cfbf8db(await adb.createSocket(`exec:${command}`));\n    }\n    #socket;\n    // Legacy shell forwards all data to stdin.\n    get stdin() {\n        return this.#socket.writable;\n    }\n    /**\n     * Legacy shell mixes stdout and stderr.\n     */ get stdout() {\n        return this.#socket.readable;\n    }\n    #stderr;\n    /**\n     * `stderr` will always be empty.\n     */ get stderr() {\n        return this.#stderr;\n    }\n    #exit;\n    get exit() {\n        return this.#exit;\n    }\n    constructor(socket){\n        this.#socket = socket;\n        this.#stderr = new (0, $6NYMu.ReadableStream)({\n            start: (controller)=>{\n                this.#socket.closed.then(()=>controller.close()).catch((0, $fXuIk.unreachable));\n            }\n        });\n        this.#exit = socket.closed.then(()=>0);\n    }\n    resize() {\n    // Not supported, but don't throw.\n    }\n    async kill() {\n        await this.#socket.close();\n    }\n}\n\n});\n\nparcelRegister(\"23OH0\", function(module, exports) {\n\n$parcel$export(module.exports, \"AdbSubprocessShellProtocol\", () => $18032f121c93c39a$export$6810084fa64eee3f);\nparcelRequire(\"kV55x\");\nvar $aHKds = parcelRequire(\"aHKds\");\nparcelRequire(\"7edQJ\");\nvar $jEctC = parcelRequire(\"jEctC\");\nvar $fnPEF = parcelRequire(\"fnPEF\");\nvar $ebpYL = parcelRequire(\"ebpYL\");\nvar $6NYMu = parcelRequire(\"6NYMu\");\nparcelRequire(\"hr1EK\");\nvar $9LJSP = parcelRequire(\"9LJSP\");\nvar $6Savq = parcelRequire(\"6Savq\");\n\nvar $drR7i = parcelRequire(\"drR7i\");\nparcelRequire(\"5lBQi\");\nvar $6Savq = parcelRequire(\"6Savq\");\nvar $18032f121c93c39a$export$4e6123448c357dfc;\n(function(AdbShellProtocolId) {\n    AdbShellProtocolId[AdbShellProtocolId[\"Stdin\"] = 0] = \"Stdin\";\n    AdbShellProtocolId[AdbShellProtocolId[\"Stdout\"] = 1] = \"Stdout\";\n    AdbShellProtocolId[AdbShellProtocolId[\"Stderr\"] = 2] = \"Stderr\";\n    AdbShellProtocolId[AdbShellProtocolId[\"Exit\"] = 3] = \"Exit\";\n    AdbShellProtocolId[AdbShellProtocolId[\"CloseStdin\"] = 4] = \"CloseStdin\";\n    AdbShellProtocolId[AdbShellProtocolId[\"WindowSizeChange\"] = 5] = \"WindowSizeChange\";\n})($18032f121c93c39a$export$4e6123448c357dfc || ($18032f121c93c39a$export$4e6123448c357dfc = {}));\n// This packet format is used in both direction.\nconst $18032f121c93c39a$var$AdbShellProtocolPacket = new (0, $9LJSP.Struct)({\n    littleEndian: true\n}).uint8(\"id\", (0, $6Savq.placeholder)()).uint32(\"length\").uint8Array(\"data\", {\n    lengthField: \"length\"\n});\nclass $18032f121c93c39a$export$6810084fa64eee3f {\n    static isSupported(adb) {\n        return adb.canUseFeature((0, $drR7i.AdbFeature).ShellV2);\n    }\n    static async pty(adb, command) {\n        // TODO: AdbShellSubprocessProtocol: Support setting `XTERM` environment variable\n        return new $18032f121c93c39a$export$6810084fa64eee3f(await adb.createSocket(`shell,v2,pty:${command}`));\n    }\n    static async raw(adb, command) {\n        return new $18032f121c93c39a$export$6810084fa64eee3f(await adb.createSocket(`shell,v2,raw:${command}`));\n    }\n    #socket;\n    #writer;\n    #stdin;\n    get stdin() {\n        return this.#stdin;\n    }\n    #stdout;\n    get stdout() {\n        return this.#stdout;\n    }\n    #stderr;\n    get stderr() {\n        return this.#stderr;\n    }\n    #exit = new (0, $aHKds.PromiseResolver)();\n    get exit() {\n        return this.#exit.promise;\n    }\n    constructor(socket){\n        this.#socket = socket;\n        let stdoutController;\n        let stderrController;\n        this.#stdout = new (0, $fnPEF.PushReadableStream)((controller)=>{\n            stdoutController = controller;\n        });\n        this.#stderr = new (0, $fnPEF.PushReadableStream)((controller)=>{\n            stderrController = controller;\n        });\n        socket.readable.pipeThrough(new (0, $ebpYL.StructDeserializeStream)($18032f121c93c39a$var$AdbShellProtocolPacket)).pipeTo(new (0, $6NYMu.WritableStream)({\n            write: async (chunk)=>{\n                switch(chunk.id){\n                    case $18032f121c93c39a$export$4e6123448c357dfc.Exit:\n                        this.#exit.resolve(chunk.data[0]);\n                        break;\n                    case $18032f121c93c39a$export$4e6123448c357dfc.Stdout:\n                        if (!stdoutController.abortSignal.aborted) await stdoutController.enqueue(chunk.data);\n                        break;\n                    case $18032f121c93c39a$export$4e6123448c357dfc.Stderr:\n                        if (!stderrController.abortSignal.aborted) await stderrController.enqueue(chunk.data);\n                        break;\n                }\n            }\n        })).then(()=>{\n            stdoutController.close();\n            stderrController.close();\n            // If `#exit` has already resolved, this will be a no-op\n            this.#exit.reject(new Error(\"Socket ended without exit message\"));\n        }, (e)=>{\n            stdoutController.error(e);\n            stderrController.error(e);\n            // If `#exit` has already resolved, this will be a no-op\n            this.#exit.reject(e);\n        });\n        this.#writer = this.#socket.writable.getWriter();\n        this.#stdin = new (0, $jEctC.MaybeConsumable).WritableStream({\n            write: async (chunk)=>{\n                await this.#writer.write($18032f121c93c39a$var$AdbShellProtocolPacket.serialize({\n                    id: $18032f121c93c39a$export$4e6123448c357dfc.Stdin,\n                    data: chunk\n                }));\n            }\n        });\n    }\n    async resize(rows, cols) {\n        await this.#writer.write($18032f121c93c39a$var$AdbShellProtocolPacket.serialize({\n            id: $18032f121c93c39a$export$4e6123448c357dfc.WindowSizeChange,\n            // The \"correct\" format is `${rows}x${cols},${x_pixels}x${y_pixels}`\n            // However, according to https://linux.die.net/man/4/tty_ioctl\n            // `x_pixels` and `y_pixels` are unused, so always sending `0` should be fine.\n            data: (0, $6Savq.encodeUtf8)(`${rows}x${cols},0x0\\0`)\n        }));\n    }\n    kill() {\n        return this.#socket.close();\n    }\n}\n\n});\nparcelRegister(\"drR7i\", function(module, exports) {\n\n$parcel$export(module.exports, \"AdbFeature\", () => $9ca6ffdb312d84ef$export$e05918f35b7c5680);\n// The order follows\n// https://cs.android.com/android/platform/superproject/+/master:packages/modules/adb/transport.cpp;l=77;drc=6d14d35d0241f6fee145f8e54ffd77252e8d29fd\nvar $9ca6ffdb312d84ef$export$e05918f35b7c5680;\n(function(AdbFeature) {\n    AdbFeature[\"ShellV2\"] = \"shell_v2\";\n    AdbFeature[\"Cmd\"] = \"cmd\";\n    AdbFeature[\"StatV2\"] = \"stat_v2\";\n    AdbFeature[\"ListV2\"] = \"ls_v2\";\n    AdbFeature[\"FixedPushMkdir\"] = \"fixed_push_mkdir\";\n    AdbFeature[\"Abb\"] = \"abb\";\n    AdbFeature[\"AbbExec\"] = \"abb_exec\";\n    AdbFeature[\"SendReceiveV2\"] = \"sendrecv_v2\";\n    AdbFeature[\"DelayedAck\"] = \"delayed_ack\";\n})($9ca6ffdb312d84ef$export$e05918f35b7c5680 || ($9ca6ffdb312d84ef$export$e05918f35b7c5680 = {}));\n\n});\n\n\nparcelRegister(\"cUsti\", function(module, exports) {\n\n});\n\n\n\nparcelRegister(\"beA73\", function(module, exports) {\n\n$parcel$export(module.exports, \"escapeArg\", () => $82dd03c0c08ee971$export$3470675a0ff86e89);\nfunction $82dd03c0c08ee971$export$3470675a0ff86e89(s) {\n    let result = \"\";\n    result += `'`;\n    let base = 0;\n    while(true){\n        const found = s.indexOf(`'`, base);\n        if (found === -1) {\n            result += s.substring(base);\n            break;\n        }\n        result += s.substring(base, found);\n        // a'b becomes a'\\'b (the backslash is not a escape character)\n        result += String.raw`'\\''`;\n        base = found + 1;\n    }\n    result += `'`;\n    return result;\n}\n\n});\n\n\nparcelRegister(\"3HODG\", function(module, exports) {\n$parcel$export(module.exports, \"AdbSync\", () => (parcelRequire(\"aBc50\")).AdbSync);\nparcelRequire(\"9QwYX\");\nparcelRequire(\"6cK2h\");\nparcelRequire(\"awO9J\");\nparcelRequire(\"j6zCo\");\nparcelRequire(\"h4v6J\");\nparcelRequire(\"3JkOU\");\nparcelRequire(\"9for9\");\nparcelRequire(\"aBc50\");\n\n});\nparcelRegister(\"9QwYX\", function(module, exports) {\n\n$parcel$export(module.exports, \"adbSyncOpenDir\", () => $72b28df151d1adcb$export$1579339099549b64);\nparcelRequire(\"hr1EK\");\nvar $9LJSP = parcelRequire(\"9LJSP\");\n\nvar $j6zCo = parcelRequire(\"j6zCo\");\n\nvar $h4v6J = parcelRequire(\"h4v6J\");\n\nvar $9for9 = parcelRequire(\"9for9\");\nconst $72b28df151d1adcb$export$9f58ebc0d39b84a0 = new (0, $9LJSP.Struct)({\n    littleEndian: true\n}).concat((0, $9for9.AdbSyncLstatResponse)).uint32(\"nameLength\").string(\"name\", {\n    lengthField: \"nameLength\"\n});\nconst $72b28df151d1adcb$export$f3f12bd93e4611be = new (0, $9LJSP.Struct)({\n    littleEndian: true\n}).concat((0, $9for9.AdbSyncStatResponse)).uint32(\"nameLength\").string(\"name\", {\n    lengthField: \"nameLength\"\n});\nasync function* $72b28df151d1adcb$export$17741d8e2b8c93(socket, path) {\n    const locked = await socket.lock();\n    try {\n        await (0, $j6zCo.adbSyncWriteRequest)(locked, (0, $j6zCo.AdbSyncRequestId).ListV2, path);\n        for await (const item of (0, $h4v6J.adbSyncReadResponses)(locked, (0, $h4v6J.AdbSyncResponseId).Entry2, $72b28df151d1adcb$export$f3f12bd93e4611be)){\n            // `LST2` can return error codes for failed `lstat` calls.\n            // `LIST` just ignores them.\n            // But they only contain `name` so still pretty useless.\n            if (item.error !== (0, $9for9.AdbSyncStatErrorCode).SUCCESS) continue;\n            yield item;\n        }\n    } finally{\n        locked.release();\n    }\n}\nasync function* $72b28df151d1adcb$export$b83665dbb067898b(socket, path) {\n    const locked = await socket.lock();\n    try {\n        await (0, $j6zCo.adbSyncWriteRequest)(locked, (0, $j6zCo.AdbSyncRequestId).List, path);\n        for await (const item of (0, $h4v6J.adbSyncReadResponses)(locked, (0, $h4v6J.AdbSyncResponseId).Entry, $72b28df151d1adcb$export$9f58ebc0d39b84a0))yield item;\n    } finally{\n        locked.release();\n    }\n}\nasync function* $72b28df151d1adcb$export$1579339099549b64(socket, path, v2) {\n    if (v2) yield* $72b28df151d1adcb$export$17741d8e2b8c93(socket, path);\n    else for await (const item of $72b28df151d1adcb$export$b83665dbb067898b(socket, path))// Convert to same format as `AdbSyncEntry2Response` for easier consumption.\n    // However it will add some overhead.\n    yield {\n        mode: item.mode,\n        size: BigInt(item.size),\n        mtime: BigInt(item.mtime),\n        get type () {\n            return item.type;\n        },\n        get permission () {\n            return item.permission;\n        },\n        name: item.name\n    };\n}\n\n});\nparcelRegister(\"j6zCo\", function(module, exports) {\n\n$parcel$export(module.exports, \"AdbSyncRequestId\", () => $de8a34e0882318f6$export$5322f80b7c65656e);\n$parcel$export(module.exports, \"adbSyncWriteRequest\", () => $de8a34e0882318f6$export$9fbb2f6d9716c879);\nparcelRequire(\"hr1EK\");\nvar $9LJSP = parcelRequire(\"9LJSP\");\nparcelRequire(\"5lBQi\");\nvar $6Savq = parcelRequire(\"6Savq\");\n\nvar $h4v6J = parcelRequire(\"h4v6J\");\nvar $de8a34e0882318f6$export$5322f80b7c65656e;\n(function(AdbSyncRequestId) {\n    AdbSyncRequestId.List = (0, $h4v6J.adbSyncEncodeId)(\"LIST\");\n    AdbSyncRequestId.ListV2 = (0, $h4v6J.adbSyncEncodeId)(\"LIS2\");\n    AdbSyncRequestId.Send = (0, $h4v6J.adbSyncEncodeId)(\"SEND\");\n    AdbSyncRequestId.SendV2 = (0, $h4v6J.adbSyncEncodeId)(\"SND2\");\n    AdbSyncRequestId.Lstat = (0, $h4v6J.adbSyncEncodeId)(\"STAT\");\n    AdbSyncRequestId.Stat = (0, $h4v6J.adbSyncEncodeId)(\"STA2\");\n    AdbSyncRequestId.LstatV2 = (0, $h4v6J.adbSyncEncodeId)(\"LST2\");\n    AdbSyncRequestId.Data = (0, $h4v6J.adbSyncEncodeId)(\"DATA\");\n    AdbSyncRequestId.Done = (0, $h4v6J.adbSyncEncodeId)(\"DONE\");\n    AdbSyncRequestId.Receive = (0, $h4v6J.adbSyncEncodeId)(\"RECV\");\n})($de8a34e0882318f6$export$5322f80b7c65656e || ($de8a34e0882318f6$export$5322f80b7c65656e = {}));\nconst $de8a34e0882318f6$export$31b0bdfb146abfd4 = new (0, $9LJSP.Struct)({\n    littleEndian: true\n}).uint32(\"id\").uint32(\"arg\");\nasync function $de8a34e0882318f6$export$9fbb2f6d9716c879(writable, id, value) {\n    if (typeof id === \"string\") id = (0, $h4v6J.adbSyncEncodeId)(id);\n    if (typeof value === \"number\") {\n        await writable.write($de8a34e0882318f6$export$31b0bdfb146abfd4.serialize({\n            id: id,\n            arg: value\n        }));\n        return;\n    }\n    if (typeof value === \"string\") value = (0, $6Savq.encodeUtf8)(value);\n    // `writable` is buffered, it copies inputs to an internal buffer,\n    // so don't concatenate headers and data here, that will be an unnecessary copy.\n    await writable.write($de8a34e0882318f6$export$31b0bdfb146abfd4.serialize({\n        id: id,\n        arg: value.length\n    }));\n    await writable.write(value);\n}\n\n});\nparcelRegister(\"h4v6J\", function(module, exports) {\n\n$parcel$export(module.exports, \"adbSyncEncodeId\", () => $c6daf0b886b3d547$export$e5f795408780cc7c);\n$parcel$export(module.exports, \"AdbSyncResponseId\", () => $c6daf0b886b3d547$export$cb117bc133363ddb);\n$parcel$export(module.exports, \"adbSyncReadResponse\", () => $c6daf0b886b3d547$export$2cf93447a6456640);\n$parcel$export(module.exports, \"adbSyncReadResponses\", () => $c6daf0b886b3d547$export$59ff2512fa71dc09);\nparcelRequire(\"cOond\");\nvar $h4MAN = parcelRequire(\"h4MAN\");\nparcelRequire(\"hr1EK\");\nvar $6Savq = parcelRequire(\"6Savq\");\nvar $9LJSP = parcelRequire(\"9LJSP\");\nfunction $c6daf0b886b3d547$var$encodeAsciiUnchecked(value) {\n    const result = new Uint8Array(value.length);\n    for(let i = 0; i < value.length; i += 1)result[i] = value.charCodeAt(i);\n    return result;\n}\nfunction $c6daf0b886b3d547$export$e5f795408780cc7c(value) {\n    const buffer = $c6daf0b886b3d547$var$encodeAsciiUnchecked(value);\n    return (0, $h4MAN.getUint32LittleEndian)(buffer, 0);\n}\nvar $c6daf0b886b3d547$export$cb117bc133363ddb;\n(function(AdbSyncResponseId) {\n    AdbSyncResponseId.Entry = $c6daf0b886b3d547$export$e5f795408780cc7c(\"DENT\");\n    AdbSyncResponseId.Entry2 = $c6daf0b886b3d547$export$e5f795408780cc7c(\"DNT2\");\n    AdbSyncResponseId.Lstat = $c6daf0b886b3d547$export$e5f795408780cc7c(\"STAT\");\n    AdbSyncResponseId.Stat = $c6daf0b886b3d547$export$e5f795408780cc7c(\"STA2\");\n    AdbSyncResponseId.Lstat2 = $c6daf0b886b3d547$export$e5f795408780cc7c(\"LST2\");\n    AdbSyncResponseId.Done = $c6daf0b886b3d547$export$e5f795408780cc7c(\"DONE\");\n    AdbSyncResponseId.Data = $c6daf0b886b3d547$export$e5f795408780cc7c(\"DATA\");\n    AdbSyncResponseId.Ok = $c6daf0b886b3d547$export$e5f795408780cc7c(\"OKAY\");\n    AdbSyncResponseId.Fail = $c6daf0b886b3d547$export$e5f795408780cc7c(\"FAIL\");\n})($c6daf0b886b3d547$export$cb117bc133363ddb || ($c6daf0b886b3d547$export$cb117bc133363ddb = {}));\nclass $c6daf0b886b3d547$export$ad50f5a23743360b extends Error {\n}\nconst $c6daf0b886b3d547$export$bf28540d1ad84211 = new (0, $9LJSP.Struct)({\n    littleEndian: true\n}).uint32(\"messageLength\").string(\"message\", {\n    lengthField: \"messageLength\"\n}).postDeserialize((object)=>{\n    throw new $c6daf0b886b3d547$export$ad50f5a23743360b(object.message);\n});\nasync function $c6daf0b886b3d547$export$2cf93447a6456640(stream, id, type) {\n    if (typeof id === \"string\") id = $c6daf0b886b3d547$export$e5f795408780cc7c(id);\n    const buffer = await stream.readExactly(4);\n    switch((0, $h4MAN.getUint32LittleEndian)(buffer, 0)){\n        case $c6daf0b886b3d547$export$cb117bc133363ddb.Fail:\n            await $c6daf0b886b3d547$export$bf28540d1ad84211.deserialize(stream);\n            throw new Error(\"Unreachable\");\n        case id:\n            return await type.deserialize(stream);\n        default:\n            throw new Error(`Expected '${id}', but got '${(0, $6Savq.decodeUtf8)(buffer)}'`);\n    }\n}\nasync function* $c6daf0b886b3d547$export$59ff2512fa71dc09(stream, id, type) {\n    if (typeof id === \"string\") id = $c6daf0b886b3d547$export$e5f795408780cc7c(id);\n    while(true){\n        const buffer = await stream.readExactly(4);\n        switch((0, $h4MAN.getUint32LittleEndian)(buffer, 0)){\n            case $c6daf0b886b3d547$export$cb117bc133363ddb.Fail:\n                await $c6daf0b886b3d547$export$bf28540d1ad84211.deserialize(stream);\n                throw new Error(\"Unreachable\");\n            case $c6daf0b886b3d547$export$cb117bc133363ddb.Done:\n                // `DONE` responses' size are always same as the request's normal response.\n                //\n                // For example, `DONE` responses for `LIST` requests are 16 bytes (same as `DENT` responses),\n                // but `DONE` responses for `STAT` requests are 12 bytes (same as `STAT` responses).\n                await stream.readExactly(type.size);\n                return;\n            case id:\n                yield await type.deserialize(stream);\n                break;\n            default:\n                throw new Error(`Expected '${id}' or '${$c6daf0b886b3d547$export$cb117bc133363ddb.Done}', but got '${(0, $6Savq.decodeUtf8)(buffer)}'`);\n        }\n    }\n}\n\n});\n\n\nparcelRegister(\"9for9\", function(module, exports) {\n\n$parcel$export(module.exports, \"LinuxFileType\", () => $6bb87868c5b7aa85$export$6b5fe9b0a9be762e);\n$parcel$export(module.exports, \"AdbSyncLstatResponse\", () => $6bb87868c5b7aa85$export$4091d821a4f90167);\n$parcel$export(module.exports, \"AdbSyncStatErrorCode\", () => $6bb87868c5b7aa85$export$e93cb33d37e1d1a3);\n$parcel$export(module.exports, \"AdbSyncStatResponse\", () => $6bb87868c5b7aa85$export$32343a08ff41df91);\n$parcel$export(module.exports, \"adbSyncLstat\", () => $6bb87868c5b7aa85$export$2241dc001bbd3624);\n$parcel$export(module.exports, \"adbSyncStat\", () => $6bb87868c5b7aa85$export$9b51c155441928f2);\nparcelRequire(\"hr1EK\");\nvar $9LJSP = parcelRequire(\"9LJSP\");\nvar $6Savq = parcelRequire(\"6Savq\");\n\nvar $j6zCo = parcelRequire(\"j6zCo\");\n\nvar $h4v6J = parcelRequire(\"h4v6J\");\nvar $6bb87868c5b7aa85$export$6b5fe9b0a9be762e;\n(function(LinuxFileType) {\n    LinuxFileType[LinuxFileType[\"Directory\"] = 4] = \"Directory\";\n    LinuxFileType[LinuxFileType[\"File\"] = 8] = \"File\";\n    LinuxFileType[LinuxFileType[\"Link\"] = 10] = \"Link\";\n})($6bb87868c5b7aa85$export$6b5fe9b0a9be762e || ($6bb87868c5b7aa85$export$6b5fe9b0a9be762e = {}));\nconst $6bb87868c5b7aa85$export$4091d821a4f90167 = new (0, $9LJSP.Struct)({\n    littleEndian: true\n}).int32(\"mode\").int32(\"size\").int32(\"mtime\").extra({\n    get type () {\n        return this.mode >> 12;\n    },\n    get permission () {\n        return this.mode & 4095;\n    }\n}).postDeserialize((object)=>{\n    if (object.mode === 0 && object.size === 0 && object.mtime === 0) throw new Error(\"lstat error\");\n});\nvar $6bb87868c5b7aa85$export$e93cb33d37e1d1a3;\n(function(AdbSyncStatErrorCode) {\n    AdbSyncStatErrorCode[AdbSyncStatErrorCode[\"SUCCESS\"] = 0] = \"SUCCESS\";\n    AdbSyncStatErrorCode[AdbSyncStatErrorCode[\"EACCES\"] = 13] = \"EACCES\";\n    AdbSyncStatErrorCode[AdbSyncStatErrorCode[\"EEXIST\"] = 17] = \"EEXIST\";\n    AdbSyncStatErrorCode[AdbSyncStatErrorCode[\"EFAULT\"] = 14] = \"EFAULT\";\n    AdbSyncStatErrorCode[AdbSyncStatErrorCode[\"EFBIG\"] = 27] = \"EFBIG\";\n    AdbSyncStatErrorCode[AdbSyncStatErrorCode[\"EINTR\"] = 4] = \"EINTR\";\n    AdbSyncStatErrorCode[AdbSyncStatErrorCode[\"EINVAL\"] = 22] = \"EINVAL\";\n    AdbSyncStatErrorCode[AdbSyncStatErrorCode[\"EIO\"] = 5] = \"EIO\";\n    AdbSyncStatErrorCode[AdbSyncStatErrorCode[\"EISDIR\"] = 21] = \"EISDIR\";\n    AdbSyncStatErrorCode[AdbSyncStatErrorCode[\"ELOOP\"] = 40] = \"ELOOP\";\n    AdbSyncStatErrorCode[AdbSyncStatErrorCode[\"EMFILE\"] = 24] = \"EMFILE\";\n    AdbSyncStatErrorCode[AdbSyncStatErrorCode[\"ENAMETOOLONG\"] = 36] = \"ENAMETOOLONG\";\n    AdbSyncStatErrorCode[AdbSyncStatErrorCode[\"ENFILE\"] = 23] = \"ENFILE\";\n    AdbSyncStatErrorCode[AdbSyncStatErrorCode[\"ENOENT\"] = 2] = \"ENOENT\";\n    AdbSyncStatErrorCode[AdbSyncStatErrorCode[\"ENOMEM\"] = 12] = \"ENOMEM\";\n    AdbSyncStatErrorCode[AdbSyncStatErrorCode[\"ENOSPC\"] = 28] = \"ENOSPC\";\n    AdbSyncStatErrorCode[AdbSyncStatErrorCode[\"ENOTDIR\"] = 20] = \"ENOTDIR\";\n    AdbSyncStatErrorCode[AdbSyncStatErrorCode[\"EOVERFLOW\"] = 75] = \"EOVERFLOW\";\n    AdbSyncStatErrorCode[AdbSyncStatErrorCode[\"EPERM\"] = 1] = \"EPERM\";\n    AdbSyncStatErrorCode[AdbSyncStatErrorCode[\"EROFS\"] = 30] = \"EROFS\";\n    AdbSyncStatErrorCode[AdbSyncStatErrorCode[\"ETXTBSY\"] = 26] = \"ETXTBSY\";\n})($6bb87868c5b7aa85$export$e93cb33d37e1d1a3 || ($6bb87868c5b7aa85$export$e93cb33d37e1d1a3 = {}));\nconst $6bb87868c5b7aa85$export$32343a08ff41df91 = new (0, $9LJSP.Struct)({\n    littleEndian: true\n}).uint32(\"error\", (0, $6Savq.placeholder)()).uint64(\"dev\").uint64(\"ino\").uint32(\"mode\").uint32(\"nlink\").uint32(\"uid\").uint32(\"gid\").uint64(\"size\").uint64(\"atime\").uint64(\"mtime\").uint64(\"ctime\").extra({\n    get type () {\n        return this.mode >> 12;\n    },\n    get permission () {\n        return this.mode & 4095;\n    }\n}).postDeserialize((object)=>{\n    if (object.error) throw new Error($6bb87868c5b7aa85$export$e93cb33d37e1d1a3[object.error]);\n});\nasync function $6bb87868c5b7aa85$export$2241dc001bbd3624(socket, path, v2) {\n    const locked = await socket.lock();\n    try {\n        if (v2) {\n            await (0, $j6zCo.adbSyncWriteRequest)(locked, (0, $j6zCo.AdbSyncRequestId).LstatV2, path);\n            return await (0, $h4v6J.adbSyncReadResponse)(locked, (0, $h4v6J.AdbSyncResponseId).Lstat2, $6bb87868c5b7aa85$export$32343a08ff41df91);\n        } else {\n            await (0, $j6zCo.adbSyncWriteRequest)(locked, (0, $j6zCo.AdbSyncRequestId).Lstat, path);\n            const response = await (0, $h4v6J.adbSyncReadResponse)(locked, (0, $h4v6J.AdbSyncResponseId).Lstat, $6bb87868c5b7aa85$export$4091d821a4f90167);\n            return {\n                mode: response.mode,\n                // Convert to `BigInt` to make it compatible with `AdbSyncStatResponse`\n                size: BigInt(response.size),\n                mtime: BigInt(response.mtime),\n                get type () {\n                    return response.type;\n                },\n                get permission () {\n                    return response.permission;\n                }\n            };\n        }\n    } finally{\n        locked.release();\n    }\n}\nasync function $6bb87868c5b7aa85$export$9b51c155441928f2(socket, path) {\n    const locked = await socket.lock();\n    try {\n        await (0, $j6zCo.adbSyncWriteRequest)(locked, (0, $j6zCo.AdbSyncRequestId).Stat, path);\n        return await (0, $h4v6J.adbSyncReadResponse)(locked, (0, $h4v6J.AdbSyncResponseId).Stat, $6bb87868c5b7aa85$export$32343a08ff41df91);\n    } finally{\n        locked.release();\n    }\n}\n\n});\n\n\nparcelRegister(\"6cK2h\", function(module, exports) {\n\n$parcel$export(module.exports, \"adbSyncPull\", () => $484792ce1371d406$export$b2722bc5a41c81be);\nparcelRequire(\"7edQJ\");\nvar $fnPEF = parcelRequire(\"fnPEF\");\nparcelRequire(\"hr1EK\");\nvar $9LJSP = parcelRequire(\"9LJSP\");\n\nvar $j6zCo = parcelRequire(\"j6zCo\");\n\nvar $h4v6J = parcelRequire(\"h4v6J\");\nconst $484792ce1371d406$export$c364285c7f62b15f = new (0, $9LJSP.Struct)({\n    littleEndian: true\n}).uint32(\"dataLength\").uint8Array(\"data\", {\n    lengthField: \"dataLength\"\n});\nasync function* $484792ce1371d406$export$e4f995c0cb69297d(socket, path) {\n    const locked = await socket.lock();\n    let done = false;\n    try {\n        await (0, $j6zCo.adbSyncWriteRequest)(locked, (0, $j6zCo.AdbSyncRequestId).Receive, path);\n        for await (const packet of (0, $h4v6J.adbSyncReadResponses)(locked, (0, $h4v6J.AdbSyncResponseId).Data, $484792ce1371d406$export$c364285c7f62b15f))yield packet.data;\n        done = true;\n    } catch (e) {\n        done = true;\n        throw e;\n    } finally{\n        if (!done) {\n            // sync pull can't be cancelled, so we have to read all data\n            for await (const packet of (0, $h4v6J.adbSyncReadResponses)(locked, (0, $h4v6J.AdbSyncResponseId).Data, $484792ce1371d406$export$c364285c7f62b15f));\n        }\n        locked.release();\n    }\n}\nfunction $484792ce1371d406$export$b2722bc5a41c81be(socket, path) {\n    // TODO: use `ReadableStream.from` when it's supported\n    return new (0, $fnPEF.PushReadableStream)(async (controller)=>{\n        for await (const data of $484792ce1371d406$export$e4f995c0cb69297d(socket, path))await controller.enqueue(data);\n    });\n}\n\n});\n\nparcelRegister(\"awO9J\", function(module, exports) {\n\n$parcel$export(module.exports, \"adbSyncPush\", () => $7aa3cc788c769a7c$export$68c559ba4f0f11a4);\nparcelRequire(\"7edQJ\");\nvar $6NYMu = parcelRequire(\"6NYMu\");\nvar $b5TnZ = parcelRequire(\"b5TnZ\");\nvar $jEctC = parcelRequire(\"jEctC\");\nparcelRequire(\"hr1EK\");\nvar $9LJSP = parcelRequire(\"9LJSP\");\nvar $6Savq = parcelRequire(\"6Savq\");\nparcelRequire(\"5lBQi\");\nvar $fXuIk = parcelRequire(\"fXuIk\");\n\nvar $j6zCo = parcelRequire(\"j6zCo\");\n\nvar $h4v6J = parcelRequire(\"h4v6J\");\n\nvar $9for9 = parcelRequire(\"9for9\");\nconst $7aa3cc788c769a7c$export$199544395e854c07 = 65536;\nconst $7aa3cc788c769a7c$export$de38b4566403a6ea = new (0, $9LJSP.Struct)({\n    littleEndian: true\n}).uint32(\"unused\");\nasync function $7aa3cc788c769a7c$var$pipeFileData(locked, file, packetSize, mtime) {\n    // Read and write in parallel,\n    // allow error response to abort the write.\n    const abortController = new (0, $6NYMu.AbortController)();\n    file.pipeThrough(new (0, $b5TnZ.DistributionStream)(packetSize, true)).pipeTo(new (0, $jEctC.MaybeConsumable).WritableStream({\n        write: async (chunk)=>{\n            await (0, $j6zCo.adbSyncWriteRequest)(locked, (0, $j6zCo.AdbSyncRequestId).Data, chunk);\n        }\n    }), {\n        signal: abortController.signal\n    }).then(async ()=>{\n        await (0, $j6zCo.adbSyncWriteRequest)(locked, (0, $j6zCo.AdbSyncRequestId).Done, mtime);\n        await locked.flush();\n    }, (0, $fXuIk.NOOP));\n    await (0, $h4v6J.adbSyncReadResponse)(locked, (0, $h4v6J.AdbSyncResponseId).Ok, $7aa3cc788c769a7c$export$de38b4566403a6ea).catch((e)=>{\n        abortController.abort();\n        throw e;\n    });\n}\nasync function $7aa3cc788c769a7c$export$97096e9859e22356({ socket: socket, filename: filename, file: file, type: type = (0, $9for9.LinuxFileType).File, permission: permission = 438, mtime: mtime = Date.now() / 1000 | 0, packetSize: packetSize = $7aa3cc788c769a7c$export$199544395e854c07 }) {\n    const locked = await socket.lock();\n    try {\n        const mode = type << 12 | permission;\n        const pathAndMode = `${filename},${mode.toString()}`;\n        await (0, $j6zCo.adbSyncWriteRequest)(locked, (0, $j6zCo.AdbSyncRequestId).Send, pathAndMode);\n        await $7aa3cc788c769a7c$var$pipeFileData(locked, file, packetSize, mtime);\n    } finally{\n        locked.release();\n    }\n}\nvar $7aa3cc788c769a7c$export$b4c20861ad50fe86;\n(function(AdbSyncSendV2Flags) {\n    AdbSyncSendV2Flags[AdbSyncSendV2Flags[\"None\"] = 0] = \"None\";\n    AdbSyncSendV2Flags[AdbSyncSendV2Flags[\"Brotli\"] = 1] = \"Brotli\";\n    /**\n     * 2\n     */ AdbSyncSendV2Flags[AdbSyncSendV2Flags[\"Lz4\"] = 2] = \"Lz4\";\n    /**\n     * 4\n     */ AdbSyncSendV2Flags[AdbSyncSendV2Flags[\"Zstd\"] = 4] = \"Zstd\";\n    AdbSyncSendV2Flags[AdbSyncSendV2Flags[\"DryRun\"] = 2147483648] = \"DryRun\";\n})($7aa3cc788c769a7c$export$b4c20861ad50fe86 || ($7aa3cc788c769a7c$export$b4c20861ad50fe86 = {}));\nconst $7aa3cc788c769a7c$export$36fe31421b981962 = new (0, $9LJSP.Struct)({\n    littleEndian: true\n}).uint32(\"id\").uint32(\"mode\").uint32(\"flags\", (0, $6Savq.placeholder)());\nasync function $7aa3cc788c769a7c$export$65eec66d09c9751b({ socket: socket, filename: filename, file: file, type: type = (0, $9for9.LinuxFileType).File, permission: permission = 438, mtime: mtime = Date.now() / 1000 | 0, packetSize: packetSize = $7aa3cc788c769a7c$export$199544395e854c07, dryRun: dryRun = false }) {\n    const locked = await socket.lock();\n    try {\n        await (0, $j6zCo.adbSyncWriteRequest)(locked, (0, $j6zCo.AdbSyncRequestId).SendV2, filename);\n        const mode = type << 12 | permission;\n        let flags = $7aa3cc788c769a7c$export$b4c20861ad50fe86.None;\n        if (dryRun) flags |= $7aa3cc788c769a7c$export$b4c20861ad50fe86.DryRun;\n        await locked.write($7aa3cc788c769a7c$export$36fe31421b981962.serialize({\n            id: (0, $j6zCo.AdbSyncRequestId).SendV2,\n            mode: mode,\n            flags: flags\n        }));\n        await $7aa3cc788c769a7c$var$pipeFileData(locked, file, packetSize, mtime);\n    } finally{\n        locked.release();\n    }\n}\nfunction $7aa3cc788c769a7c$export$68c559ba4f0f11a4(options) {\n    if (options.v2) return $7aa3cc788c769a7c$export$65eec66d09c9751b(options);\n    if (options.dryRun) throw new Error(\"dryRun is not supported in v1\");\n    return $7aa3cc788c769a7c$export$97096e9859e22356(options);\n}\n\n});\n\nparcelRegister(\"3JkOU\", function(module, exports) {\n\n$parcel$export(module.exports, \"AdbSyncSocket\", () => $2b75b983ed1aaf9f$export$5ab9b68fbce86ef6);\nparcelRequire(\"7edQJ\");\nvar $b5TnZ = parcelRequire(\"b5TnZ\");\nvar $bJSM1 = parcelRequire(\"bJSM1\");\nvar $5Ywqs = parcelRequire(\"5Ywqs\");\nparcelRequire(\"5lBQi\");\nvar $5SRHv = parcelRequire(\"5SRHv\");\nclass $2b75b983ed1aaf9f$export$7224dd8d1cb774a1 {\n    #writer;\n    #readable;\n    #socketLock;\n    #writeLock = new (0, $5SRHv.AutoResetEvent)();\n    #combiner;\n    get position() {\n        return this.#readable.position;\n    }\n    constructor(writer, readable, bufferSize, lock){\n        this.#writer = writer;\n        this.#readable = readable;\n        this.#socketLock = lock;\n        this.#combiner = new (0, $b5TnZ.BufferCombiner)(bufferSize);\n    }\n    async #write(buffer) {\n        // `#combiner` will reuse the buffer, so we need to use the Consumable pattern\n        await (0, $5Ywqs.Consumable).WritableStream.write(this.#writer, buffer);\n    }\n    async flush() {\n        try {\n            await this.#writeLock.wait();\n            const buffer = this.#combiner.flush();\n            if (buffer) await this.#write(buffer);\n        } finally{\n            this.#writeLock.notifyOne();\n        }\n    }\n    async write(data) {\n        try {\n            await this.#writeLock.wait();\n            for (const buffer of this.#combiner.push(data))await this.#write(buffer);\n        } finally{\n            this.#writeLock.notifyOne();\n        }\n    }\n    async readExactly(length) {\n        // The request may still be in the internal buffer.\n        // Call `flush` to send it before starting reading\n        await this.flush();\n        return await this.#readable.readExactly(length);\n    }\n    release() {\n        // In theory, the writer shouldn't leave anything in the buffer,\n        // but to be safe, call `flush` to throw away any remaining data.\n        this.#combiner.flush();\n        this.#socketLock.notifyOne();\n    }\n    async close() {\n        await this.#readable.cancel();\n    }\n}\nclass $2b75b983ed1aaf9f$export$5ab9b68fbce86ef6 {\n    #lock = new (0, $5SRHv.AutoResetEvent)();\n    #socket;\n    #locked;\n    constructor(socket, bufferSize){\n        this.#socket = socket;\n        this.#locked = new $2b75b983ed1aaf9f$export$7224dd8d1cb774a1(socket.writable.getWriter(), new (0, $bJSM1.BufferedReadableStream)(socket.readable), bufferSize, this.#lock);\n    }\n    async lock() {\n        await this.#lock.wait();\n        return this.#locked;\n    }\n    async close() {\n        await this.#locked.close();\n        await this.#socket.close();\n    }\n}\n\n});\n\nparcelRegister(\"aBc50\", function(module, exports) {\n\n$parcel$export(module.exports, \"AdbSync\", () => $7b76badbaf65e5be$export$c7d21bab4b5606f3);\nparcelRequire(\"hpom2\");\nvar $aGQPd = parcelRequire(\"aGQPd\");\n\nvar $drR7i = parcelRequire(\"drR7i\");\nparcelRequire(\"ezTiR\");\nvar $beA73 = parcelRequire(\"beA73\");\n\nvar $9QwYX = parcelRequire(\"9QwYX\");\n\nvar $6cK2h = parcelRequire(\"6cK2h\");\n\nvar $awO9J = parcelRequire(\"awO9J\");\n\nvar $3JkOU = parcelRequire(\"3JkOU\");\n\nvar $9for9 = parcelRequire(\"9for9\");\nfunction $7b76badbaf65e5be$export$7f7b8152cc673abe(path) {\n    const end = path.lastIndexOf(\"/\");\n    if (end === -1) throw new Error(`Invalid path`);\n    if (end === 0) return \"/\";\n    return path.substring(0, end);\n}\nclass $7b76badbaf65e5be$export$c7d21bab4b5606f3 extends (0, $aGQPd.AutoDisposable) {\n    _adb;\n    _socket;\n    #supportsStat;\n    #supportsListV2;\n    #fixedPushMkdir;\n    #supportsSendReceiveV2;\n    #needPushMkdirWorkaround;\n    get supportsStat() {\n        return this.#supportsStat;\n    }\n    get supportsListV2() {\n        return this.#supportsListV2;\n    }\n    get fixedPushMkdir() {\n        return this.#fixedPushMkdir;\n    }\n    get supportsSendReceiveV2() {\n        return this.#supportsSendReceiveV2;\n    }\n    get needPushMkdirWorkaround() {\n        return this.#needPushMkdirWorkaround;\n    }\n    constructor(adb, socket){\n        super();\n        this._adb = adb;\n        this._socket = new (0, $3JkOU.AdbSyncSocket)(socket, adb.maxPayloadSize);\n        this.#supportsStat = adb.canUseFeature((0, $drR7i.AdbFeature).StatV2);\n        this.#supportsListV2 = adb.canUseFeature((0, $drR7i.AdbFeature).ListV2);\n        this.#fixedPushMkdir = adb.canUseFeature((0, $drR7i.AdbFeature).FixedPushMkdir);\n        this.#supportsSendReceiveV2 = adb.canUseFeature((0, $drR7i.AdbFeature).SendReceiveV2);\n        // https://android.googlesource.com/platform/packages/modules/adb/+/91768a57b7138166e0a3d11f79cd55909dda7014/client/file_sync_client.cpp#1361\n        this.#needPushMkdirWorkaround = this._adb.canUseFeature((0, $drR7i.AdbFeature).ShellV2) && !this.fixedPushMkdir;\n    }\n    /**\n     * Gets information of a file or folder.\n     *\n     * If `path` points to a symbolic link, the returned information is about the link itself (with `type` being `LinuxFileType.Link`).\n     */ async lstat(path) {\n        return await (0, $9for9.adbSyncLstat)(this._socket, path, this.#supportsStat);\n    }\n    /**\n     * Gets the information of a file or folder.\n     *\n     * If `path` points to a symbolic link, it will be resolved and the returned information is about the target (with `type` being `LinuxFileType.File` or `LinuxFileType.Directory`).\n     */ async stat(path) {\n        if (!this.#supportsStat) throw new Error(\"Not supported\");\n        return await (0, $9for9.adbSyncStat)(this._socket, path);\n    }\n    /**\n     * Checks if `path` is a directory, or a symbolic link to a directory.\n     *\n     * This uses `lstat` internally, thus works on all Android versions.\n     */ async isDirectory(path) {\n        try {\n            await this.lstat(path + \"/\");\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n    opendir(path) {\n        return (0, $9QwYX.adbSyncOpenDir)(this._socket, path, this.supportsListV2);\n    }\n    async readdir(path) {\n        const results = [];\n        for await (const entry of this.opendir(path))results.push(entry);\n        return results;\n    }\n    /**\n     * Reads the content of a file on device.\n     *\n     * @param filename The full path of the file on device to read.\n     * @returns A `ReadableStream` that contains the file content.\n     */ read(filename) {\n        return (0, $6cK2h.adbSyncPull)(this._socket, filename);\n    }\n    /**\n     * Writes a file on device. If the file name already exists, it will be overwritten.\n     *\n     * @param options The content and options of the file to write.\n     */ async write(options) {\n        if (this.needPushMkdirWorkaround) // It may fail if `filename` already exists.\n        // Ignore the result.\n        // TODO: sync: test push mkdir workaround (need an Android 8 device)\n        await this._adb.subprocess.spawnAndWait([\n            \"mkdir\",\n            \"-p\",\n            (0, $beA73.escapeArg)($7b76badbaf65e5be$export$7f7b8152cc673abe(options.filename))\n        ]);\n        await (0, $awO9J.adbSyncPush)({\n            v2: this.supportsSendReceiveV2,\n            socket: this._socket,\n            ...options\n        });\n    }\n    lockSocket() {\n        return this._socket.lock();\n    }\n    async dispose() {\n        super.dispose();\n        await this._socket.close();\n    }\n}\n\n});\n\n\nparcelRegister(\"liel6\", function(module, exports) {\n\n$parcel$export(module.exports, \"AdbTcpIpCommand\", () => $f80666ec7843035b$export$9d7ae67b2874bc2a);\n\nvar $2TOFC = parcelRequire(\"2TOFC\");\nclass $f80666ec7843035b$export$9d7ae67b2874bc2a extends (0, $2TOFC.AdbCommandBase) {\n    #parsePort(value) {\n        if (!value || value === \"0\") return undefined;\n        return Number.parseInt(value, 10);\n    }\n    async getListenAddresses() {\n        const serviceListenAddresses = await this.adb.getProp(\"service.adb.listen_addrs\");\n        const servicePort = await this.adb.getProp(\"service.adb.tcp.port\");\n        const persistPort = await this.adb.getProp(\"persist.adb.tcp.port\");\n        return {\n            serviceListenAddresses: serviceListenAddresses != \"\" ? serviceListenAddresses.split(\",\") : [],\n            servicePort: this.#parsePort(servicePort),\n            persistPort: this.#parsePort(persistPort)\n        };\n    }\n    async setPort(port) {\n        if (port <= 0) throw new TypeError(`Invalid port ${port}`);\n        const output = await this.adb.createSocketAndWait(`tcpip:${port}`);\n        if (output !== `restarting in TCP mode port: ${port}\\n`) throw new Error(output);\n        return output;\n    }\n    async disable() {\n        const output = await this.adb.createSocketAndWait(\"usb:\");\n        if (output !== \"restarting in USB mode\\n\") throw new Error(output);\n        return output;\n    }\n}\n\n});\n\n\n\nparcelRegister(\"bFpy9\", function(module, exports) {\n\n$parcel$export(module.exports, \"AdbBanner\", () => $87e757b1771fca0a$export$25d495fe2ebd5375);\nvar $87e757b1771fca0a$export$23f5f7103a6c0e54;\n(function(AdbBannerKey) {\n    AdbBannerKey[\"Product\"] = \"ro.product.name\";\n    AdbBannerKey[\"Model\"] = \"ro.product.model\";\n    AdbBannerKey[\"Device\"] = \"ro.product.device\";\n    AdbBannerKey[\"Features\"] = \"features\";\n})($87e757b1771fca0a$export$23f5f7103a6c0e54 || ($87e757b1771fca0a$export$23f5f7103a6c0e54 = {}));\nclass $87e757b1771fca0a$export$25d495fe2ebd5375 {\n    static parse(banner) {\n        let product;\n        let model;\n        let device;\n        let features = [];\n        const pieces = banner.split(\"::\");\n        if (pieces.length > 1) {\n            const props = pieces[1];\n            for (const prop of props.split(\";\")){\n                // istanbul ignore if\n                if (!prop) continue;\n                const keyValue = prop.split(\"=\");\n                if (keyValue.length !== 2) continue;\n                const [key, value] = keyValue;\n                switch(key){\n                    case $87e757b1771fca0a$export$23f5f7103a6c0e54.Product:\n                        product = value;\n                        break;\n                    case $87e757b1771fca0a$export$23f5f7103a6c0e54.Model:\n                        model = value;\n                        break;\n                    case $87e757b1771fca0a$export$23f5f7103a6c0e54.Device:\n                        device = value;\n                        break;\n                    case $87e757b1771fca0a$export$23f5f7103a6c0e54.Features:\n                        features = value.split(\",\");\n                        break;\n                }\n            }\n        }\n        return new $87e757b1771fca0a$export$25d495fe2ebd5375(product, model, device, features);\n    }\n    #product;\n    get product() {\n        return this.#product;\n    }\n    #model;\n    get model() {\n        return this.#model;\n    }\n    #device;\n    get device() {\n        return this.#device;\n    }\n    #features = [];\n    get features() {\n        return this.#features;\n    }\n    constructor(product, model, device, features){\n        this.#product = product;\n        this.#model = model;\n        this.#device = device;\n        this.#features = features;\n    }\n}\n\n});\n\nparcelRegister(\"7gpwK\", function(module, exports) {\n$parcel$export(module.exports, \"AdbPacketHeader\", () => (parcelRequire(\"2lmjj\")).AdbPacketHeader);\n$parcel$export(module.exports, \"AdbPacketSerializeStream\", () => (parcelRequire(\"2lmjj\")).AdbPacketSerializeStream);\n$parcel$export(module.exports, \"AdbDaemonTransport\", () => (parcelRequire(\"aIHw7\")).AdbDaemonTransport);\nparcelRequire(\"gYm23\");\nparcelRequire(\"7qLAG\");\nparcelRequire(\"1hhal\");\nparcelRequire(\"cb2uE\");\nparcelRequire(\"2lmjj\");\nparcelRequire(\"5BaNe\");\nparcelRequire(\"aIHw7\");\n\n});\nparcelRegister(\"gYm23\", function(module, exports) {\n\n$parcel$export(module.exports, \"ADB_DEFAULT_AUTHENTICATORS\", () => $c5b35711f7a6189a$export$485fb103785b43ab);\n$parcel$export(module.exports, \"AdbAuthenticationProcessor\", () => $c5b35711f7a6189a$export$e4e9c85a581bb39f);\nparcelRequire(\"kV55x\");\nvar $aHKds = parcelRequire(\"aHKds\");\nparcelRequire(\"hr1EK\");\nvar $j4unN = parcelRequire(\"j4unN\");\nparcelRequire(\"5lBQi\");\nvar $2kccq = parcelRequire(\"2kccq\");\nvar $6Savq = parcelRequire(\"6Savq\");\n\nvar $7qLAG = parcelRequire(\"7qLAG\");\n\nvar $2lmjj = parcelRequire(\"2lmjj\");\nvar $c5b35711f7a6189a$export$2e65721f4f5c7298;\n(function(AdbAuthType) {\n    AdbAuthType[AdbAuthType[\"Token\"] = 1] = \"Token\";\n    AdbAuthType[AdbAuthType[\"Signature\"] = 2] = \"Signature\";\n    AdbAuthType[AdbAuthType[\"PublicKey\"] = 3] = \"PublicKey\";\n})($c5b35711f7a6189a$export$2e65721f4f5c7298 || ($c5b35711f7a6189a$export$2e65721f4f5c7298 = {}));\nconst $c5b35711f7a6189a$export$6db9d4c500eaa91b = async function*(credentialStore, getNextRequest) {\n    for await (const key of credentialStore.iterateKeys()){\n        const packet = await getNextRequest();\n        if (packet.arg0 !== $c5b35711f7a6189a$export$2e65721f4f5c7298.Token) return;\n        const signature = (0, $7qLAG.rsaSign)(key.buffer, packet.payload);\n        yield {\n            command: (0, $2lmjj.AdbCommand).Auth,\n            arg0: $c5b35711f7a6189a$export$2e65721f4f5c7298.Signature,\n            arg1: 0,\n            payload: signature\n        };\n    }\n};\nconst $c5b35711f7a6189a$export$d4b89a035405944 = async function*(credentialStore, getNextRequest) {\n    const packet = await getNextRequest();\n    if (packet.arg0 !== $c5b35711f7a6189a$export$2e65721f4f5c7298.Token) return;\n    let privateKey;\n    for await (const key of credentialStore.iterateKeys()){\n        privateKey = key;\n        break;\n    }\n    if (!privateKey) privateKey = await credentialStore.generateKey();\n    const publicKeyLength = (0, $7qLAG.adbGetPublicKeySize)();\n    const [publicKeyBase64Length] = (0, $2kccq.calculateBase64EncodedLength)(publicKeyLength);\n    const nameBuffer = privateKey.name?.length ? (0, $6Savq.encodeUtf8)(privateKey.name) : (0, $j4unN.EMPTY_UINT8_ARRAY);\n    const publicKeyBuffer = new Uint8Array(publicKeyBase64Length + (nameBuffer.length ? nameBuffer.length + 1 : 0) + // Space character + name\n    1);\n    (0, $7qLAG.adbGeneratePublicKey)(privateKey.buffer, publicKeyBuffer);\n    (0, $2kccq.encodeBase64)(publicKeyBuffer.subarray(0, publicKeyLength), publicKeyBuffer);\n    if (nameBuffer.length) {\n        publicKeyBuffer[publicKeyBase64Length] = 0x20;\n        publicKeyBuffer.set(nameBuffer, publicKeyBase64Length + 1);\n    }\n    yield {\n        command: (0, $2lmjj.AdbCommand).Auth,\n        arg0: $c5b35711f7a6189a$export$2e65721f4f5c7298.PublicKey,\n        arg1: 0,\n        payload: publicKeyBuffer\n    };\n};\nconst $c5b35711f7a6189a$export$485fb103785b43ab = [\n    $c5b35711f7a6189a$export$6db9d4c500eaa91b,\n    $c5b35711f7a6189a$export$d4b89a035405944\n];\nclass $c5b35711f7a6189a$export$e4e9c85a581bb39f {\n    authenticators;\n    #credentialStore;\n    #pendingRequest = new (0, $aHKds.PromiseResolver)();\n    #iterator;\n    constructor(authenticators, credentialStore){\n        this.authenticators = authenticators;\n        this.#credentialStore = credentialStore;\n    }\n    #getNextRequest = ()=>{\n        return this.#pendingRequest.promise;\n    };\n    async *#invokeAuthenticator() {\n        for (const authenticator of this.authenticators)for await (const packet of authenticator(this.#credentialStore, this.#getNextRequest)){\n            // If the authenticator yielded a response\n            // Prepare `nextRequest` for next authentication request\n            this.#pendingRequest = new (0, $aHKds.PromiseResolver)();\n            // Yield the response to outer layer\n            yield packet;\n        }\n    }\n    async process(packet) {\n        if (!this.#iterator) this.#iterator = this.#invokeAuthenticator();\n        this.#pendingRequest.resolve(packet);\n        const result = await this.#iterator.next();\n        if (result.done) throw new Error(\"No authenticator can handle the request\");\n        return result.value;\n    }\n    dispose() {\n        this.#iterator?.return?.();\n    }\n}\n\n});\nparcelRegister(\"7qLAG\", function(module, exports) {\n\n$parcel$export(module.exports, \"adbGetPublicKeySize\", () => $568fe0a3a1a6b938$export$847074fb5f64c4e1);\n$parcel$export(module.exports, \"adbGeneratePublicKey\", () => $568fe0a3a1a6b938$export$8699f7714545d1a1);\n$parcel$export(module.exports, \"rsaSign\", () => $568fe0a3a1a6b938$export$97e3cdd046452c80);\nparcelRequire(\"cOond\");\nvar $jzfEx = parcelRequire(\"jzfEx\");\nvar $duafd = parcelRequire(\"duafd\");\nfunction $568fe0a3a1a6b938$export$19ed8bf0faa0c9c(array, byteOffset, length) {\n    let result = 0n;\n    // Currently `length` must be a multiplication of 8\n    // Support for arbitrary length can be easily added\n    for(let i = byteOffset; i < byteOffset + length; i += 8){\n        result <<= 64n;\n        const value = (0, $jzfEx.getUint64BigEndian)(array, i);\n        result |= value;\n    }\n    return result;\n}\nfunction $568fe0a3a1a6b938$export$1fd10df48a397f51(array, byteOffset, length, value, littleEndian) {\n    if (littleEndian) while(value > 0n){\n        (0, $duafd.setInt64LittleEndian)(array, byteOffset, value);\n        byteOffset += 8;\n        value >>= 64n;\n    }\n    else {\n        let position = byteOffset + length - 8;\n        while(value > 0n){\n            (0, $duafd.setInt64BigEndian)(array, position, value);\n            position -= 8;\n            value >>= 64n;\n        }\n    }\n}\n// These values are correct only if\n// modulus length is 2048 and\n// public exponent (e) is 65537\n// Anyway, that's how this library generates keys\n// To support other parameters,\n// a proper ASN.1 parser can be used\n// References:\n//\n//   https://tools.ietf.org/html/rfc8017#appendix-A.1.2\n//   PKCS #1: RSA Cryptography Specifications Version 2.2\n//     A.1.2.  RSA Private Key Syntax\n//\n//   https://lapo.it/asn1js/\n//   https://github.com/lapo-luchini/asn1js\n//   ASN.1 JavaScript decoder\n//\n//   https://www.itu.int/rec/T-REC-X.690-201508-I/en\n//   X.690: Specification of Distinguished Encoding Rules (DER)\nconst $568fe0a3a1a6b938$var$RsaPrivateKeyNOffset = 38;\nconst $568fe0a3a1a6b938$var$RsaPrivateKeyNLength = 256;\nconst $568fe0a3a1a6b938$var$RsaPrivateKeyDOffset = 303;\nconst $568fe0a3a1a6b938$var$RsaPrivateKeyDLength = 256;\nfunction $568fe0a3a1a6b938$export$5c1dc4cd37ff603(key) {\n    const n = $568fe0a3a1a6b938$export$19ed8bf0faa0c9c(key, $568fe0a3a1a6b938$var$RsaPrivateKeyNOffset, $568fe0a3a1a6b938$var$RsaPrivateKeyNLength);\n    const d = $568fe0a3a1a6b938$export$19ed8bf0faa0c9c(key, $568fe0a3a1a6b938$var$RsaPrivateKeyDOffset, $568fe0a3a1a6b938$var$RsaPrivateKeyDLength);\n    return [\n        n,\n        d\n    ];\n}\nfunction $568fe0a3a1a6b938$var$nonNegativeMod(m, d) {\n    const r = m % d;\n    if (r > 0) return r;\n    return r + (d > 0 ? d : -d);\n}\nfunction $568fe0a3a1a6b938$export$f085ad9052472793(a, m) {\n    a = $568fe0a3a1a6b938$var$nonNegativeMod(a, m);\n    if (!a || m < 2) return NaN; // invalid input\n    // find the gcd\n    const s = [];\n    let b = m;\n    while(b){\n        [a, b] = [\n            b,\n            a % b\n        ];\n        s.push({\n            a: a,\n            b: b\n        });\n    }\n    /* istanbul ignore next */ if (a !== 1) return NaN; // inverse does not exists\n    // find the inverse\n    let x = 1;\n    let y = 0;\n    for(let i = s.length - 2; i >= 0; i -= 1)[x, y] = [\n        y,\n        x - y * Math.floor(s[i].a / s[i].b)\n    ];\n    return $568fe0a3a1a6b938$var$nonNegativeMod(y, m);\n}\nconst $568fe0a3a1a6b938$var$ModulusLengthInBytes = 256;\nconst $568fe0a3a1a6b938$var$ModulusLengthInWords = $568fe0a3a1a6b938$var$ModulusLengthInBytes / 4;\nfunction $568fe0a3a1a6b938$export$847074fb5f64c4e1() {\n    return 8 + $568fe0a3a1a6b938$var$ModulusLengthInBytes + $568fe0a3a1a6b938$var$ModulusLengthInBytes + 4;\n}\nfunction $568fe0a3a1a6b938$export$8699f7714545d1a1(privateKey, output) {\n    // cspell: ignore: mincrypt\n    // Android 6 and earlier has its own encryption library called mincrypt\n    // This is the RSA public key format used by mincrypt:\n    // https://android.googlesource.com/platform/system/core/+/bb0c180e62703c2068a1b2c9f8ba6d634bf1553c/include/mincrypt/rsa.h#46\n    // `n0inv` and `rr` are pre-calculated to speed up RSA operations\n    // Android 7 switched its encryption library to BoringSSL, but still keeps the key format:\n    // https://android.googlesource.com/platform/system/core.git/+/91784040db2b9273687f88d8b95f729d4a61ecc2/libcrypto_utils/android_pubkey.cpp#38\n    // Except when reading a key, `n0inv` and `rr` are ignored (they are still populated when generating a key):\n    // https://android.googlesource.com/platform/system/core.git/+/91784040db2b9273687f88d8b95f729d4a61ecc2/libcrypto_utils/android_pubkey.cpp#55\n    // The public key is a struct (in little endian) of:\n    //\n    // [\n    //   modulusLengthInWords, // 32-bit integer, a \"word\" is 32-bit so it must be 2048 / 8 / 4\n    //                         // (the comment in Android source code is incorrect saying \"This must be ANDROID_PUBKEY_MODULUS_SIZE\")\n    //   n0inv,                // 32-bit integer, the modular inverse of (lower 32 bits of `n`)\n    //   modulus,              // `n`\n    //   rr,                   // Montgomery parameter R^2\n    //   exponent,             // 32-bit integer, must be 3 or 65537\n    // ]\n    let outputType;\n    const outputLength = $568fe0a3a1a6b938$export$847074fb5f64c4e1();\n    if (!output) {\n        output = new Uint8Array(outputLength);\n        outputType = \"Uint8Array\";\n    } else {\n        if (output.length < outputLength) throw new TypeError(\"output buffer is too small\");\n        outputType = \"number\";\n    }\n    const outputView = new DataView(output.buffer, output.byteOffset, output.length);\n    let outputOffset = 0;\n    // modulusLengthInWords\n    outputView.setUint32(outputOffset, $568fe0a3a1a6b938$var$ModulusLengthInWords, true);\n    outputOffset += 4;\n    // extract `n` from private key\n    const [n] = $568fe0a3a1a6b938$export$5c1dc4cd37ff603(privateKey);\n    // Calculate `n0inv`\n    const n0inv = -$568fe0a3a1a6b938$export$f085ad9052472793(Number(n % 2n ** 32n), 2 ** 32);\n    outputView.setInt32(outputOffset, n0inv, true);\n    outputOffset += 4;\n    // Write `n` (a.k.a. `modulus`)\n    $568fe0a3a1a6b938$export$1fd10df48a397f51(output, outputOffset, $568fe0a3a1a6b938$var$ModulusLengthInBytes, n, true);\n    outputOffset += $568fe0a3a1a6b938$var$ModulusLengthInBytes;\n    // Calculate rr = (2 ** (rsa_size)) ** 2 % n\n    const rr = 2n ** 4096n % n;\n    $568fe0a3a1a6b938$export$1fd10df48a397f51(output, outputOffset, $568fe0a3a1a6b938$var$ModulusLengthInBytes, rr, true);\n    outputOffset += $568fe0a3a1a6b938$var$ModulusLengthInBytes;\n    // exponent\n    outputView.setUint32(outputOffset, 65537, true);\n    outputOffset += 4;\n    if (outputType === \"Uint8Array\") return output;\n    else return outputLength;\n}\nfunction $568fe0a3a1a6b938$export$a871ce58ee56241a(base, exponent, modulus) {\n    if (modulus === 1n) return 0n;\n    let r = 1n;\n    base = base % modulus;\n    while(exponent > 0n){\n        if (BigInt.asUintN(1, exponent) === 1n) r = r * base % modulus;\n        base = base * base % modulus;\n        exponent >>= 1n;\n    }\n    return r;\n}\nconst $568fe0a3a1a6b938$export$f2deb3df359a068d = 20;\nconst $568fe0a3a1a6b938$export$35b3d451b440c51 = 0x30;\nconst $568fe0a3a1a6b938$export$f44bb4e033b660f9 = 0x04;\nconst $568fe0a3a1a6b938$export$3d2259b791fdf8f1 = 0x05;\nconst $568fe0a3a1a6b938$export$6307913b6c4d9e66 = 0x06;\nconst $568fe0a3a1a6b938$export$1025a137f1840fa1 = new Uint8Array([\n    $568fe0a3a1a6b938$export$35b3d451b440c51,\n    0x0d + $568fe0a3a1a6b938$export$f2deb3df359a068d,\n    $568fe0a3a1a6b938$export$35b3d451b440c51,\n    0x09,\n    // SHA-1 (1 3 14 3 2 26)\n    $568fe0a3a1a6b938$export$6307913b6c4d9e66,\n    0x05,\n    43,\n    14,\n    3,\n    2,\n    26,\n    $568fe0a3a1a6b938$export$3d2259b791fdf8f1,\n    0x00,\n    $568fe0a3a1a6b938$export$f44bb4e033b660f9,\n    $568fe0a3a1a6b938$export$f2deb3df359a068d\n]);\nfunction $568fe0a3a1a6b938$export$97e3cdd046452c80(privateKey, data) {\n    const [n, d] = $568fe0a3a1a6b938$export$5c1dc4cd37ff603(privateKey);\n    // PKCS#1 padding\n    const padded = new Uint8Array(256);\n    let index = 0;\n    padded[index] = 0;\n    index += 1;\n    padded[index] = 1;\n    index += 1;\n    const fillLength = padded.length - $568fe0a3a1a6b938$export$1025a137f1840fa1.length - data.length - 1;\n    while(index < fillLength){\n        padded[index] = 0xff;\n        index += 1;\n    }\n    padded[index] = 0;\n    index += 1;\n    padded.set($568fe0a3a1a6b938$export$1025a137f1840fa1, index);\n    index += $568fe0a3a1a6b938$export$1025a137f1840fa1.length;\n    padded.set(data, index);\n    // Encryption\n    // signature = padded ** d % n\n    const signature = $568fe0a3a1a6b938$export$a871ce58ee56241a($568fe0a3a1a6b938$export$19ed8bf0faa0c9c(padded, 0, padded.length), d, n);\n    // `padded` is not used anymore,\n    // re-use the buffer to store the result\n    $568fe0a3a1a6b938$export$1fd10df48a397f51(padded, 0, padded.length, signature, false);\n    return padded;\n}\n\n});\n\nparcelRegister(\"2lmjj\", function(module, exports) {\n\n$parcel$export(module.exports, \"AdbCommand\", () => $1b4ed9515c9d7ed1$export$5d836449dc8c8870);\n$parcel$export(module.exports, \"AdbPacketHeader\", () => $1b4ed9515c9d7ed1$export$96ac7b5be108186d);\n$parcel$export(module.exports, \"calculateChecksum\", () => $1b4ed9515c9d7ed1$export$b0943743069d64df);\n$parcel$export(module.exports, \"AdbPacketSerializeStream\", () => $1b4ed9515c9d7ed1$export$4f57c42a69edaa4d);\nparcelRequire(\"7edQJ\");\nvar $5Ywqs = parcelRequire(\"5Ywqs\");\nvar $6NYMu = parcelRequire(\"6NYMu\");\nparcelRequire(\"hr1EK\");\nvar $9LJSP = parcelRequire(\"9LJSP\");\nvar $1b4ed9515c9d7ed1$export$5d836449dc8c8870;\n(function(AdbCommand) {\n    AdbCommand[AdbCommand[\"Auth\"] = 1213486401] = \"Auth\";\n    AdbCommand[AdbCommand[\"Close\"] = 1163086915] = \"Close\";\n    AdbCommand[AdbCommand[\"Connect\"] = 1314410051] = \"Connect\";\n    AdbCommand[AdbCommand[\"Okay\"] = 1497451343] = \"Okay\";\n    AdbCommand[AdbCommand[\"Open\"] = 1313165391] = \"Open\";\n    AdbCommand[AdbCommand[\"Write\"] = 1163154007] = \"Write\";\n})($1b4ed9515c9d7ed1$export$5d836449dc8c8870 || ($1b4ed9515c9d7ed1$export$5d836449dc8c8870 = {}));\nconst $1b4ed9515c9d7ed1$export$96ac7b5be108186d = new (0, $9LJSP.Struct)({\n    littleEndian: true\n}).uint32(\"command\").uint32(\"arg0\").uint32(\"arg1\").uint32(\"payloadLength\").uint32(\"checksum\").int32(\"magic\");\nconst $1b4ed9515c9d7ed1$export$5a43c2ea262f9c91 = new (0, $9LJSP.Struct)({\n    littleEndian: true\n}).concat($1b4ed9515c9d7ed1$export$96ac7b5be108186d).uint8Array(\"payload\", {\n    lengthField: \"payloadLength\"\n});\nfunction $1b4ed9515c9d7ed1$export$b0943743069d64df(payload) {\n    return payload.reduce((result, item)=>result + item, 0);\n}\nclass $1b4ed9515c9d7ed1$export$4f57c42a69edaa4d extends (0, $6NYMu.TransformStream) {\n    constructor(){\n        const headerBuffer = new Uint8Array($1b4ed9515c9d7ed1$export$96ac7b5be108186d.size);\n        super({\n            transform: async (chunk, controller)=>{\n                await chunk.tryConsume(async (chunk)=>{\n                    const init = chunk;\n                    init.payloadLength = init.payload.length;\n                    await (0, $5Ywqs.Consumable).ReadableStream.enqueue(controller, $1b4ed9515c9d7ed1$export$96ac7b5be108186d.serialize(init, headerBuffer));\n                    if (init.payloadLength) // USB protocol preserves packet boundaries,\n                    // so we must write payload separately as native ADB does,\n                    // otherwise the read operation on device will fail.\n                    await (0, $5Ywqs.Consumable).ReadableStream.enqueue(controller, init.payload);\n                });\n            }\n        });\n    }\n}\n\n});\n\n\nparcelRegister(\"1hhal\", function(module, exports) {\n\n});\n\nparcelRegister(\"cb2uE\", function(module, exports) {\n\n$parcel$export(module.exports, \"AdbPacketDispatcher\", () => $8dd872409796e78b$export$d634de534db06769);\nparcelRequire(\"kV55x\");\nvar $1PmPk = parcelRequire(\"1PmPk\");\nvar $5OCzC = parcelRequire(\"5OCzC\");\nvar $aHKds = parcelRequire(\"aHKds\");\nparcelRequire(\"cOond\");\nvar $h4MAN = parcelRequire(\"h4MAN\");\nparcelRequire(\"7edQJ\");\nvar $6NYMu = parcelRequire(\"6NYMu\");\nvar $5Ywqs = parcelRequire(\"5Ywqs\");\nparcelRequire(\"hr1EK\");\nvar $6Savq = parcelRequire(\"6Savq\");\nvar $j4unN = parcelRequire(\"j4unN\");\n\nvar $2lmjj = parcelRequire(\"2lmjj\");\n\nvar $5BaNe = parcelRequire(\"5BaNe\");\nclass $8dd872409796e78b$export$d634de534db06769 {\n    // ADB socket id starts from 1\n    // (0 means open failed)\n    #initializers = new (0, $1PmPk.AsyncOperationManager)(1);\n    /**\n     * Socket local ID to the socket controller.\n     */ #sockets = new Map();\n    #writer;\n    options;\n    #closed = false;\n    #disconnected = new (0, $aHKds.PromiseResolver)();\n    get disconnected() {\n        return this.#disconnected.promise;\n    }\n    #incomingSocketHandlers = new Map();\n    #readAbortController = new (0, $6NYMu.AbortController)();\n    constructor(connection, options){\n        this.options = options;\n        // Don't allow negative values in dispatcher\n        if (this.options.initialDelayedAckBytes < 0) this.options.initialDelayedAckBytes = 0;\n        connection.readable.pipeTo(new (0, $6NYMu.WritableStream)({\n            write: async (packet)=>{\n                switch(packet.command){\n                    case (0, $2lmjj.AdbCommand).Close:\n                        await this.#handleClose(packet);\n                        break;\n                    case (0, $2lmjj.AdbCommand).Okay:\n                        this.#handleOkay(packet);\n                        break;\n                    case (0, $2lmjj.AdbCommand).Open:\n                        await this.#handleOpen(packet);\n                        break;\n                    case (0, $2lmjj.AdbCommand).Write:\n                        await this.#handleWrite(packet);\n                        break;\n                    default:\n                        // Junk data may only appear in the authentication phase,\n                        // since the dispatcher only works after authentication,\n                        // all packets should have a valid command.\n                        // (although it's possible that Adb added new commands in the future)\n                        throw new Error(`Unknown command: ${packet.command.toString(16)}`);\n                }\n            }\n        }), {\n            preventCancel: options.preserveConnection ?? false,\n            signal: this.#readAbortController.signal\n        }).then(()=>{\n            this.#dispose();\n        }, (e)=>{\n            if (!this.#closed) this.#disconnected.reject(e);\n            this.#dispose();\n        });\n        this.#writer = connection.writable.getWriter();\n    }\n    async #handleClose(packet) {\n        // If the socket is still pending\n        if (packet.arg0 === 0 && this.#initializers.reject(packet.arg1, new Error(\"Socket open failed\"))) // Device failed to create the socket\n        // (unknown service string, failed to execute command, etc.)\n        // it doesn't break the connection,\n        // so only reject the socket creation promise,\n        // don't throw an error here.\n        return;\n        // From https://android.googlesource.com/platform/packages/modules/adb/+/65d18e2c1cc48b585811954892311b28a4c3d188/adb.cpp#459\n        /* According to protocol.txt, p->msg.arg0 might be 0 to indicate\n         * a failed OPEN only. However, due to a bug in previous ADB\n         * versions, CLOSE(0, remote-id, \"\") was also used for normal\n         * CLOSE() operations.\n         */ // Ignore `arg0` and search for the socket\n        const socket = this.#sockets.get(packet.arg1);\n        if (socket) {\n            await socket.close();\n            socket.dispose();\n            this.#sockets.delete(packet.arg1);\n            return;\n        }\n    // TODO: adb: is double closing an socket a catastrophic error?\n    // If the client sends two `CLSE` packets for one socket,\n    // the device may also respond with two `CLSE` packets.\n    }\n    #handleOkay(packet) {\n        let ackBytes;\n        if (this.options.initialDelayedAckBytes !== 0) {\n            if (packet.payload.length !== 4) throw new Error(\"Invalid OKAY packet. Payload size should be 4\");\n            ackBytes = (0, $h4MAN.getUint32LittleEndian)(packet.payload, 0);\n        } else {\n            if (packet.payload.length !== 0) throw new Error(\"Invalid OKAY packet. Payload size should be 0\");\n            ackBytes = Infinity;\n        }\n        if (this.#initializers.resolve(packet.arg1, {\n            remoteId: packet.arg0,\n            availableWriteBytes: ackBytes\n        })) // Device successfully created the socket\n        return;\n        const socket = this.#sockets.get(packet.arg1);\n        if (socket) {\n            // When delayed ack is enabled, `ackBytes` is a positive number represents\n            // how many bytes the device has received from this socket.\n            // When delayed ack is disabled, `ackBytes` is always `Infinity` represents\n            // the device has received last `WRTE` packet from the socket.\n            socket.ack(ackBytes);\n            return;\n        }\n        // Maybe the device is responding to a packet of last connection\n        // Tell the device to close the socket\n        this.sendPacket((0, $2lmjj.AdbCommand).Close, packet.arg1, packet.arg0, (0, $j4unN.EMPTY_UINT8_ARRAY));\n    }\n    #sendOkay(localId, remoteId, ackBytes) {\n        let payload;\n        if (this.options.initialDelayedAckBytes !== 0) {\n            // TODO: try reusing this buffer to reduce memory allocation\n            // However, that requires blocking reentrance of `sendOkay`, which might be more expensive\n            payload = new Uint8Array(4);\n            (0, $h4MAN.setUint32LittleEndian)(payload, 0, ackBytes);\n        } else payload = (0, $j4unN.EMPTY_UINT8_ARRAY);\n        return this.sendPacket((0, $2lmjj.AdbCommand).Okay, localId, remoteId, payload);\n    }\n    async #handleOpen(packet) {\n        // Allocate a local ID for the socket from `#initializers`.\n        // `AsyncOperationManager` doesn't directly support returning the next ID,\n        // so use `add` + `resolve` to simulate this\n        const [localId] = this.#initializers.add();\n        this.#initializers.resolve(localId, undefined);\n        const remoteId = packet.arg0;\n        let availableWriteBytes = packet.arg1;\n        let service = (0, $6Savq.decodeUtf8)(packet.payload);\n        // ADB Daemon still adds a null character to the service string\n        if (service.endsWith(\"\\0\")) service = service.substring(0, service.length - 1);\n        // Check remote delayed ack enablement is consistent with local\n        if (this.options.initialDelayedAckBytes === 0) {\n            if (availableWriteBytes !== 0) throw new Error(\"Invalid OPEN packet. arg1 should be 0\");\n            availableWriteBytes = Infinity;\n        } else {\n            if (availableWriteBytes === 0) throw new Error(\"Invalid OPEN packet. arg1 should be greater than 0\");\n        }\n        const handler = this.#incomingSocketHandlers.get(service);\n        if (!handler) {\n            await this.sendPacket((0, $2lmjj.AdbCommand).Close, 0, remoteId, (0, $j4unN.EMPTY_UINT8_ARRAY));\n            return;\n        }\n        const controller = new (0, $5BaNe.AdbDaemonSocketController)({\n            dispatcher: this,\n            localId: localId,\n            remoteId: remoteId,\n            localCreated: false,\n            service: service,\n            availableWriteBytes: availableWriteBytes\n        });\n        try {\n            await handler(controller.socket);\n            this.#sockets.set(localId, controller);\n            await this.#sendOkay(localId, remoteId, this.options.initialDelayedAckBytes);\n        } catch (e) {\n            await this.sendPacket((0, $2lmjj.AdbCommand).Close, 0, remoteId, (0, $j4unN.EMPTY_UINT8_ARRAY));\n        }\n    }\n    async #handleWrite(packet) {\n        const socket = this.#sockets.get(packet.arg1);\n        if (!socket) throw new Error(`Unknown local socket id: ${packet.arg1}`);\n        let handled = false;\n        const promises = [\n            (async ()=>{\n                await socket.enqueue(packet.payload);\n                await this.#sendOkay(packet.arg1, packet.arg0, packet.payload.length);\n                handled = true;\n            })()\n        ];\n        if (this.options.readTimeLimit) promises.push((async ()=>{\n            await (0, $5OCzC.delay)(this.options.readTimeLimit);\n            if (!handled) throw new Error(`readable of \\`${socket.service}\\` has stalled for ${this.options.readTimeLimit} milliseconds`);\n        })());\n        await Promise.race(promises);\n    }\n    async createSocket(service) {\n        if (this.options.appendNullToServiceString) service += \"\\0\";\n        const [localId, initializer] = this.#initializers.add();\n        await this.sendPacket((0, $2lmjj.AdbCommand).Open, localId, this.options.initialDelayedAckBytes, service);\n        // Fulfilled by `handleOkay`\n        const { remoteId: remoteId, availableWriteBytes: availableWriteBytes } = await initializer;\n        const controller = new (0, $5BaNe.AdbDaemonSocketController)({\n            dispatcher: this,\n            localId: localId,\n            remoteId: remoteId,\n            localCreated: true,\n            service: service,\n            availableWriteBytes: availableWriteBytes\n        });\n        this.#sockets.set(localId, controller);\n        return controller.socket;\n    }\n    addReverseTunnel(service, handler) {\n        this.#incomingSocketHandlers.set(service, handler);\n    }\n    removeReverseTunnel(address) {\n        this.#incomingSocketHandlers.delete(address);\n    }\n    clearReverseTunnels() {\n        this.#incomingSocketHandlers.clear();\n    }\n    async sendPacket(command, arg0, arg1, // PERF: It's slightly faster to not use default parameter values\n    payload) {\n        if (typeof payload === \"string\") payload = (0, $6Savq.encodeUtf8)(payload);\n        if (payload.length > this.options.maxPayloadSize) throw new TypeError(\"payload too large\");\n        await (0, $5Ywqs.Consumable).WritableStream.write(this.#writer, {\n            command: command,\n            arg0: arg0,\n            arg1: arg1,\n            payload: payload,\n            checksum: this.options.calculateChecksum ? (0, $2lmjj.calculateChecksum)(payload) : 0,\n            magic: command ^ 0xffffffff\n        });\n    }\n    async close() {\n        // Send `CLSE` packets for all sockets\n        await Promise.all(Array.from(this.#sockets.values(), (socket)=>socket.close()));\n        // Stop receiving\n        // It's possible that we haven't received all `CLSE` confirm packets,\n        // but it doesn't matter, the next connection can cope with them.\n        this.#closed = true;\n        this.#readAbortController.abort();\n        if (this.options.preserveConnection) this.#writer.releaseLock();\n        else await this.#writer.close();\n    // `pipe().then()` will call `dispose`\n    }\n    #dispose() {\n        for (const socket of this.#sockets.values())socket.dispose();\n        this.#disconnected.resolve();\n    }\n}\n\n});\nparcelRegister(\"5BaNe\", function(module, exports) {\n\n$parcel$export(module.exports, \"AdbDaemonSocketController\", () => $4138c7bd76e67256$export$f061bb53e3f17c7c);\nparcelRequire(\"kV55x\");\nvar $aHKds = parcelRequire(\"aHKds\");\nparcelRequire(\"7edQJ\");\nvar $jEctC = parcelRequire(\"jEctC\");\nvar $fnPEF = parcelRequire(\"fnPEF\");\nparcelRequire(\"hr1EK\");\nvar $j4unN = parcelRequire(\"j4unN\");\n\nvar $2lmjj = parcelRequire(\"2lmjj\");\nclass $4138c7bd76e67256$export$f061bb53e3f17c7c {\n    #dispatcher;\n    localId;\n    remoteId;\n    localCreated;\n    service;\n    #readable;\n    #readableController;\n    get readable() {\n        return this.#readable;\n    }\n    #writableController;\n    writable;\n    #closed = false;\n    #closedPromise = new (0, $aHKds.PromiseResolver)();\n    get closed() {\n        return this.#closedPromise.promise;\n    }\n    #socket;\n    get socket() {\n        return this.#socket;\n    }\n    #availableWriteBytesChanged;\n    /**\n     * When delayed ack is disabled, returns `Infinity` if the socket is ready to write\n     * (exactly one packet can be written no matter how large it is), or `-1` if the socket\n     * is waiting for ack message.\n     *\n     * When delayed ack is enabled, returns a non-negative finite number indicates the number of\n     * bytes that can be written to the socket before waiting for ack message.\n     */ #availableWriteBytes = 0;\n    constructor(options){\n        this.#dispatcher = options.dispatcher;\n        this.localId = options.localId;\n        this.remoteId = options.remoteId;\n        this.localCreated = options.localCreated;\n        this.service = options.service;\n        this.#readable = new (0, $fnPEF.PushReadableStream)((controller)=>{\n            this.#readableController = controller;\n        });\n        this.writable = new (0, $jEctC.MaybeConsumable).WritableStream({\n            start: (controller)=>{\n                this.#writableController = controller;\n                controller.signal.addEventListener(\"abort\", ()=>{\n                    this.#availableWriteBytesChanged?.reject(controller.signal.reason);\n                });\n            },\n            write: async (data)=>{\n                const size = data.length;\n                const chunkSize = this.#dispatcher.options.maxPayloadSize;\n                for(let start = 0, end = chunkSize; start < size; start = end, end += chunkSize){\n                    const chunk = data.subarray(start, end);\n                    await this.#writeChunk(chunk);\n                }\n            }\n        });\n        this.#socket = new $4138c7bd76e67256$export$8f6ff11549e9fecf(this);\n        this.#availableWriteBytes = options.availableWriteBytes;\n    }\n    async #writeChunk(data) {\n        const length = data.length;\n        while(this.#availableWriteBytes < length){\n            // Only one lock is required because Web Streams API guarantees\n            // that `write` is not reentrant.\n            const resolver = new (0, $aHKds.PromiseResolver)();\n            this.#availableWriteBytesChanged = resolver;\n            await resolver.promise;\n        }\n        if (this.#availableWriteBytes === Infinity) this.#availableWriteBytes = -1;\n        else this.#availableWriteBytes -= length;\n        await this.#dispatcher.sendPacket((0, $2lmjj.AdbCommand).Write, this.localId, this.remoteId, data);\n    }\n    async enqueue(data) {\n        // Consumers can `cancel` the `readable` if they are not interested in future data.\n        // Throw away the data if that happens.\n        if (this.#readableController.abortSignal.aborted) return;\n        try {\n            await this.#readableController.enqueue(data);\n        } catch (e) {\n            if (this.#readableController.abortSignal.aborted) return;\n            throw e;\n        }\n    }\n    ack(bytes) {\n        this.#availableWriteBytes += bytes;\n        this.#availableWriteBytesChanged?.resolve();\n    }\n    async close() {\n        if (this.#closed) return;\n        this.#closed = true;\n        this.#availableWriteBytesChanged?.reject(new Error(\"Socket closed\"));\n        try {\n            this.#writableController.error(new Error(\"Socket closed\"));\n        } catch  {\n        // ignore\n        }\n        await this.#dispatcher.sendPacket((0, $2lmjj.AdbCommand).Close, this.localId, this.remoteId, (0, $j4unN.EMPTY_UINT8_ARRAY));\n    }\n    dispose() {\n        try {\n            this.#readableController.close();\n        } catch  {\n        // ignore\n        }\n        this.#closedPromise.resolve();\n    }\n}\nclass $4138c7bd76e67256$export$8f6ff11549e9fecf {\n    #controller;\n    get localId() {\n        return this.#controller.localId;\n    }\n    get remoteId() {\n        return this.#controller.remoteId;\n    }\n    get localCreated() {\n        return this.#controller.localCreated;\n    }\n    get service() {\n        return this.#controller.service;\n    }\n    get readable() {\n        return this.#controller.readable;\n    }\n    get writable() {\n        return this.#controller.writable;\n    }\n    get closed() {\n        return this.#controller.closed;\n    }\n    constructor(controller){\n        this.#controller = controller;\n    }\n    close() {\n        return this.#controller.close();\n    }\n}\n\n});\n\n\nparcelRegister(\"aIHw7\", function(module, exports) {\n\n$parcel$export(module.exports, \"AdbDaemonTransport\", () => $7cdfc506af36bd48$export$7d98e1b80c4a2dc2);\nparcelRequire(\"kV55x\");\nvar $aHKds = parcelRequire(\"aHKds\");\nparcelRequire(\"7edQJ\");\nvar $6NYMu = parcelRequire(\"6NYMu\");\nvar $5Ywqs = parcelRequire(\"5Ywqs\");\nparcelRequire(\"hr1EK\");\nvar $6Savq = parcelRequire(\"6Savq\");\n\nvar $bFpy9 = parcelRequire(\"bFpy9\");\n\nvar $drR7i = parcelRequire(\"drR7i\");\n\nvar $gYm23 = parcelRequire(\"gYm23\");\n\nvar $cb2uE = parcelRequire(\"cb2uE\");\n\nvar $2lmjj = parcelRequire(\"2lmjj\");\nconst $7cdfc506af36bd48$export$9bf5b66cfd38320b = 0x01000001;\nconst $7cdfc506af36bd48$export$a9b40d5d0c7f809b = [\n    (0, $drR7i.AdbFeature).ShellV2,\n    (0, $drR7i.AdbFeature).Cmd,\n    (0, $drR7i.AdbFeature).StatV2,\n    (0, $drR7i.AdbFeature).ListV2,\n    (0, $drR7i.AdbFeature).FixedPushMkdir,\n    \"apex\",\n    (0, $drR7i.AdbFeature).Abb,\n    // only tells the client the symlink timestamp issue in `adb push --sync` has been fixed.\n    // No special handling required.\n    \"fixed_push_symlink_timestamp\",\n    (0, $drR7i.AdbFeature).AbbExec,\n    \"remount_shell\",\n    \"track_app\",\n    (0, $drR7i.AdbFeature).SendReceiveV2,\n    \"sendrecv_v2_brotli\",\n    \"sendrecv_v2_lz4\",\n    \"sendrecv_v2_zstd\",\n    \"sendrecv_v2_dry_run_send\",\n    (0, $drR7i.AdbFeature).DelayedAck\n];\nconst $7cdfc506af36bd48$export$c0c61e0faab919ab = 33554432;\nclass $7cdfc506af36bd48$export$7d98e1b80c4a2dc2 {\n    /**\n     * Authenticates the connection and creates an `AdbDaemonTransport` instance\n     * that can be used by `Adb` class.\n     *\n     * If an authentication process failed,\n     * no matter which value the `preserveConnection` option has,\n     * the `connection` is always kept open, so it can be used in another `authenticate` call.\n     */ static async authenticate({ serial: serial, connection: connection, credentialStore: credentialStore, authenticators: authenticators = (0, $gYm23.ADB_DEFAULT_AUTHENTICATORS), features: features = $7cdfc506af36bd48$export$a9b40d5d0c7f809b, initialDelayedAckBytes: initialDelayedAckBytes = $7cdfc506af36bd48$export$c0c61e0faab919ab, ...options }) {\n        // Initially, set to highest-supported version and payload size.\n        let version = 0x01000001;\n        // Android 4: 4K, Android 7: 256K, Android 9: 1M\n        let maxPayloadSize = 1048576;\n        const resolver = new (0, $aHKds.PromiseResolver)();\n        const authProcessor = new (0, $gYm23.AdbAuthenticationProcessor)(authenticators, credentialStore);\n        // Here is similar to `AdbPacketDispatcher`,\n        // But the received packet types and send packet processing are different.\n        const abortController = new (0, $6NYMu.AbortController)();\n        const pipe = connection.readable.pipeTo(new (0, $6NYMu.WritableStream)({\n            async write (packet) {\n                switch(packet.command){\n                    case (0, $2lmjj.AdbCommand).Connect:\n                        version = Math.min(version, packet.arg0);\n                        maxPayloadSize = Math.min(maxPayloadSize, packet.arg1);\n                        resolver.resolve((0, $6Savq.decodeUtf8)(packet.payload));\n                        break;\n                    case (0, $2lmjj.AdbCommand).Auth:\n                        {\n                            const response = await authProcessor.process(packet);\n                            await sendPacket(response);\n                            break;\n                        }\n                    default:\n                        break;\n                }\n            }\n        }), {\n            // Don't cancel the source ReadableStream on AbortSignal abort.\n            preventCancel: true,\n            signal: abortController.signal\n        }).then(()=>{\n            // If `resolver` is already settled, call `reject` won't do anything.\n            resolver.reject(new Error(\"Connection closed unexpectedly\"));\n        }, (e)=>{\n            resolver.reject(e);\n        });\n        const writer = connection.writable.getWriter();\n        async function sendPacket(init) {\n            // Always send checksum in auth steps\n            // Because we don't know if the device needs it or not.\n            init.checksum = (0, $2lmjj.calculateChecksum)(init.payload);\n            init.magic = init.command ^ 0xffffffff;\n            await (0, $5Ywqs.Consumable).WritableStream.write(writer, init);\n        }\n        const actualFeatures = features.slice();\n        if (initialDelayedAckBytes <= 0) {\n            const index = features.indexOf((0, $drR7i.AdbFeature).DelayedAck);\n            if (index !== -1) actualFeatures.splice(index, 1);\n        }\n        let banner;\n        try {\n            await sendPacket({\n                command: (0, $2lmjj.AdbCommand).Connect,\n                arg0: version,\n                arg1: maxPayloadSize,\n                // The terminating `;` is required in formal definition\n                // But ADB daemon (all versions) can still work without it\n                payload: (0, $6Savq.encodeUtf8)(`host::features=${actualFeatures.join(\",\")}`)\n            });\n            banner = await resolver.promise;\n        } finally{\n            // When failed, release locks on `connection` so the caller can try again.\n            // When success, also release locks so `AdbPacketDispatcher` can use them.\n            abortController.abort();\n            writer.releaseLock();\n            // Wait until pipe stops (`ReadableStream` lock released)\n            await pipe;\n        }\n        return new $7cdfc506af36bd48$export$7d98e1b80c4a2dc2({\n            serial: serial,\n            connection: connection,\n            version: version,\n            maxPayloadSize: maxPayloadSize,\n            banner: banner,\n            features: actualFeatures,\n            initialDelayedAckBytes: initialDelayedAckBytes,\n            ...options\n        });\n    }\n    #connection;\n    get connection() {\n        return this.#connection;\n    }\n    #dispatcher;\n    #serial;\n    get serial() {\n        return this.#serial;\n    }\n    #protocolVersion;\n    get protocolVersion() {\n        return this.#protocolVersion;\n    }\n    get maxPayloadSize() {\n        return this.#dispatcher.options.maxPayloadSize;\n    }\n    #banner;\n    get banner() {\n        return this.#banner;\n    }\n    get disconnected() {\n        return this.#dispatcher.disconnected;\n    }\n    #clientFeatures;\n    get clientFeatures() {\n        return this.#clientFeatures;\n    }\n    constructor({ serial: serial, connection: connection, version: version, banner: banner, features: features = $7cdfc506af36bd48$export$a9b40d5d0c7f809b, initialDelayedAckBytes: initialDelayedAckBytes, ...options }){\n        this.#serial = serial;\n        this.#connection = connection;\n        this.#banner = (0, $bFpy9.AdbBanner).parse(banner);\n        this.#clientFeatures = features;\n        if (features.includes((0, $drR7i.AdbFeature).DelayedAck)) {\n            if (initialDelayedAckBytes <= 0) throw new TypeError(\"`initialDelayedAckBytes` must be greater than 0 when DelayedAck feature is enabled.\");\n            if (!this.#banner.features.includes((0, $drR7i.AdbFeature).DelayedAck)) initialDelayedAckBytes = 0;\n        } else initialDelayedAckBytes = 0;\n        let calculateChecksum;\n        let appendNullToServiceString;\n        if (version >= $7cdfc506af36bd48$export$9bf5b66cfd38320b) {\n            calculateChecksum = false;\n            appendNullToServiceString = false;\n        } else {\n            calculateChecksum = true;\n            appendNullToServiceString = true;\n        }\n        this.#dispatcher = new (0, $cb2uE.AdbPacketDispatcher)(connection, {\n            calculateChecksum: calculateChecksum,\n            appendNullToServiceString: appendNullToServiceString,\n            initialDelayedAckBytes: initialDelayedAckBytes,\n            ...options\n        });\n        this.#protocolVersion = version;\n    }\n    connect(service) {\n        return this.#dispatcher.createSocket(service);\n    }\n    addReverseTunnel(handler, address) {\n        if (!address) {\n            const id = Math.random().toString().substring(2);\n            address = `localabstract:reverse_${id}`;\n        }\n        this.#dispatcher.addReverseTunnel(address, handler);\n        return address;\n    }\n    removeReverseTunnel(address) {\n        this.#dispatcher.removeReverseTunnel(address);\n    }\n    clearReverseTunnels() {\n        this.#dispatcher.clearReverseTunnels();\n    }\n    close() {\n        return this.#dispatcher.close();\n    }\n}\n\n});\n\n\nparcelRegister(\"jBeoN\", function(module, exports) {\nparcelRequire(\"iHRUW\");\nparcelRequire(\"btVdk\");\n\n});\nparcelRegister(\"iHRUW\", function(module, exports) {\n// cspell:ignore tport\nparcelRequire(\"kV55x\");\nvar $aHKds = parcelRequire(\"aHKds\");\nparcelRequire(\"cOond\");\nvar $jzfEx = parcelRequire(\"jzfEx\");\nparcelRequire(\"7edQJ\");\nvar $bJSM1 = parcelRequire(\"bJSM1\");\nvar $jEctC = parcelRequire(\"jEctC\");\nvar $67qk3 = parcelRequire(\"67qk3\");\nparcelRequire(\"hr1EK\");\nvar $6Savq = parcelRequire(\"6Savq\");\nvar $j4unN = parcelRequire(\"j4unN\");\nvar $6yg6p = parcelRequire(\"6yg6p\");\n\nvar $bFpy9 = parcelRequire(\"bFpy9\");\nparcelRequire(\"5lBQi\");\nvar $32bmk = parcelRequire(\"32bmk\");\nvar $fXuIk = parcelRequire(\"fXuIk\");\nvar $gtlgZ = parcelRequire(\"gtlgZ\");\n\nvar $btVdk = parcelRequire(\"btVdk\");\nconst $d9e611074e4605d2$var$OKAY = (0, $6Savq.encodeUtf8)(\"OKAY\");\nconst $d9e611074e4605d2$var$FAIL = (0, $6Savq.encodeUtf8)(\"FAIL\");\nclass $d9e611074e4605d2$var$AdbServerStream {\n    #connection;\n    #buffered;\n    #writer;\n    constructor(connection){\n        this.#connection = connection;\n        this.#buffered = new (0, $bJSM1.BufferedReadableStream)(connection.readable);\n        this.#writer = connection.writable.getWriter();\n    }\n    readExactly(length) {\n        return this.#buffered.readExactly(length);\n    }\n    readString() {\n        return (0, $6yg6p.SyncPromise).try(()=>this.readExactly(4)).then((buffer)=>{\n            const length = (0, $32bmk.hexToNumber)(buffer);\n            if (length === 0) return 0, $j4unN.EMPTY_UINT8_ARRAY;\n            else return this.readExactly(length);\n        }).then((buffer)=>{\n            // TODO: Investigate using stream mode `TextDecoder` for long strings.\n            // Because concatenating strings uses rope data structure,\n            // which only points to the original strings and doesn't copy the data,\n            // it's more efficient than concatenating `Uint8Array`s.\n            //\n            // ```\n            // const decoder = new TextDecoder();\n            // let result = '';\n            // for await (const chunk of stream.iterateExactly(length)) {\n            //     result += decoder.decode(chunk, { stream: true });\n            // }\n            // result += decoder.decode();\n            // return result;\n            // ```\n            //\n            // Although, it will be super complex to use `SyncPromise` with async iterator,\n            // `stream.iterateExactly` need to return an\n            // `Iterator<Uint8Array | Promise<Uint8Array>>` instead of a true async iterator.\n            // Maybe `SyncPromise` should support async iterators directly.\n            return (0, $6Savq.decodeUtf8)(buffer);\n        }).valueOrPromise();\n    }\n    async writeString(value) {\n        // TODO: investigate using `encodeUtf8(\"0000\" + value)` then modifying the length\n        // That way allocates a new string (hopefully only a rope) instead of a new buffer\n        const encoded = (0, $6Savq.encodeUtf8)(value);\n        const buffer = new Uint8Array(4 + encoded.length);\n        (0, $32bmk.write4HexDigits)(buffer, 0, encoded.length);\n        buffer.set(encoded, 4);\n        await this.#writer.write(buffer);\n    }\n    async readOkay() {\n        const response = await this.readExactly(4);\n        if ((0, $gtlgZ.sequenceEqual)(response, $d9e611074e4605d2$var$OKAY)) // `OKAY` is followed by data length and data\n        // But different services want to parse the data differently\n        // So don't read the data here\n        return;\n        if ((0, $gtlgZ.sequenceEqual)(response, $d9e611074e4605d2$var$FAIL)) {\n            const reason = await this.readString();\n            throw new Error(reason);\n        }\n        throw new Error(`Unexpected response: ${(0, $6Savq.decodeUtf8)(response)}`);\n    }\n    release() {\n        this.#writer.releaseLock();\n        return {\n            readable: this.#buffered.release(),\n            writable: this.#connection.writable,\n            closed: this.#connection.closed,\n            close: ()=>this.#connection.close()\n        };\n    }\n    async dispose() {\n        await this.#buffered.cancel().catch((0, $fXuIk.NOOP));\n        await this.#writer.close().catch((0, $fXuIk.NOOP));\n        try {\n            await this.#connection.close();\n        } catch  {\n        // ignore\n        }\n    }\n}\nclass $d9e611074e4605d2$export$21bea6a433f41b7c {\n    static VERSION = 41;\n    connector;\n    wireless = new $d9e611074e4605d2$export$21bea6a433f41b7c.WirelessCommands(this);\n    mDns = new $d9e611074e4605d2$export$21bea6a433f41b7c.MDnsCommands(this);\n    constructor(connection){\n        this.connector = connection;\n    }\n    async createConnection(request, options) {\n        const connection = await this.connector.connect(options);\n        const stream = new $d9e611074e4605d2$var$AdbServerStream(connection);\n        try {\n            await stream.writeString(request);\n        } catch (e) {\n            await stream.dispose();\n            throw e;\n        }\n        try {\n            // `raceSignal` throws when the signal is aborted,\n            // so the `catch` block can close the connection.\n            await $d9e611074e4605d2$export$76ed3709e60def45(()=>stream.readOkay(), options?.signal);\n            return stream;\n        } catch (e) {\n            await stream.dispose();\n            throw e;\n        }\n    }\n    /**\n     * `adb version`\n     */ async getVersion() {\n        const connection = await this.createConnection(\"host:version\");\n        try {\n            const length = (0, $32bmk.hexToNumber)(await connection.readExactly(4));\n            const version = (0, $32bmk.hexToNumber)(await connection.readExactly(length));\n            return version;\n        } finally{\n            await connection.dispose();\n        }\n    }\n    async validateVersion() {\n        const version = await this.getVersion();\n        if (version !== $d9e611074e4605d2$export$21bea6a433f41b7c.VERSION) throw new Error(`adb server version (${version}) doesn't match this client (${$d9e611074e4605d2$export$21bea6a433f41b7c.VERSION})`);\n    }\n    /**\n     * `adb kill-server`\n     */ async killServer() {\n        const connection = await this.createConnection(\"host:kill\");\n        await connection.dispose();\n    }\n    /**\n     * `adb host-features`\n     */ async getServerFeatures() {\n        const connection = await this.createConnection(\"host:host-features\");\n        try {\n            const response = await connection.readString();\n            return response.split(\",\");\n        } finally{\n            await connection.dispose();\n        }\n    }\n    parseDeviceList(value) {\n        const devices = [];\n        for (const line of value.split(\"\\n\")){\n            if (!line) continue;\n            const parts = line.split(\" \").filter(Boolean);\n            const serial = parts[0];\n            const status = parts[1];\n            if (status !== \"device\" && status !== \"unauthorized\") continue;\n            let product;\n            let model;\n            let device;\n            let transportId;\n            for(let i = 2; i < parts.length; i += 1){\n                const [key, value] = parts[i].split(\":\");\n                switch(key){\n                    case \"product\":\n                        product = value;\n                        break;\n                    case \"model\":\n                        model = value;\n                        break;\n                    case \"device\":\n                        device = value;\n                        break;\n                    case \"transport_id\":\n                        transportId = BigInt(value);\n                        break;\n                }\n            }\n            if (!transportId) throw new Error(`No transport id for device ${serial}`);\n            devices.push({\n                serial: serial,\n                authenticating: status === \"unauthorized\",\n                product: product,\n                model: model,\n                device: device,\n                transportId: transportId\n            });\n        }\n        return devices;\n    }\n    /**\n     * `adb devices -l`\n     */ async getDevices() {\n        const connection = await this.createConnection(\"host:devices-l\");\n        try {\n            const response = await connection.readString();\n            return this.parseDeviceList(response);\n        } finally{\n            await connection.dispose();\n        }\n    }\n    /**\n     * Track the device list.\n     *\n     * @param signal An optional `AbortSignal` to stop tracking\n     *\n     * When `signal` is aborted, `trackDevices` will return normally, instead of throwing `signal.reason`.\n     */ async *trackDevices(signal) {\n        const connection = await this.createConnection(\"host:track-devices-l\");\n        try {\n            while(true){\n                const response = await $d9e611074e4605d2$export$76ed3709e60def45(async ()=>await connection.readString(), signal);\n                const devices = this.parseDeviceList(response);\n                yield devices;\n            }\n        } catch (e) {\n            if (e === signal?.reason) return;\n        } finally{\n            await connection.dispose();\n        }\n    }\n    formatDeviceService(device, command) {\n        if (!device) return `host:${command}`;\n        if (\"transportId\" in device) return `host-transport-id:${device.transportId}:${command}`;\n        if (\"serial\" in device) return `host-serial:${device.serial}:${command}`;\n        if (\"usb\" in device) return `host-usb:${command}`;\n        if (\"tcp\" in device) return `host-local:${command}`;\n        throw new TypeError(\"Invalid device selector\");\n    }\n    /**\n     * `adb -s <device> reconnect` or `adb reconnect offline`\n     */ async reconnectDevice(device) {\n        const connection = await this.createConnection(device === \"offline\" ? \"host:reconnect-offline\" : this.formatDeviceService(device, \"reconnect\"));\n        try {\n            await connection.readString();\n        } finally{\n            await connection.dispose();\n        }\n    }\n    /**\n     * Gets the features supported by the device.\n     * The transport ID of the selected device is also returned,\n     * so the caller can execute other commands against the same device.\n     * @param device The device selector\n     * @returns The transport ID of the selected device, and the features supported by the device.\n     */ async getDeviceFeatures(device) {\n        // On paper, `host:features` is a host service (device features are cached in host),\n        // so it shouldn't use `createDeviceConnection`,\n        // which is used to forward the service to the device.\n        //\n        // However, `createDeviceConnection` is a two step process:\n        //\n        //    1. Send a switch device service to host, to switch the connection to the device.\n        //    2. Send the actual service to host, let it forward the service to the device.\n        //\n        // In step 2, the host only forward the service to device if the service is unknown to host.\n        // If the service is a host service, it's still handled by host.\n        //\n        // Even better, if the service needs a device selector, but the selector is not provided,\n        // the service will be executed against the device selected by the switch device service.\n        // So we can use all device selector formats for the host service,\n        // and get the transport ID in the same time.\n        const connection = await this.createDeviceConnection(device, \"host:features\");\n        // Luckily `AdbServerClient.Socket` is compatible with `AdbServerClient.ServerConnection`\n        const stream = new $d9e611074e4605d2$var$AdbServerStream(connection);\n        try {\n            const featuresString = await stream.readString();\n            const features = featuresString.split(\",\");\n            return {\n                transportId: connection.transportId,\n                features: features\n            };\n        } finally{\n            await stream.dispose();\n        }\n    }\n    /**\n     * Creates a connection that will forward the service to device.\n     * @param device The device selector\n     * @param service The service to forward\n     * @returns An `AdbServerClient.Socket` that can be used to communicate with the service\n     */ async createDeviceConnection(device, service) {\n        await this.validateVersion();\n        let switchService;\n        let transportId;\n        if (!device) switchService = `host:tport:any`;\n        else if (\"transportId\" in device) {\n            switchService = `host:transport-id:${device.transportId}`;\n            transportId = device.transportId;\n        } else if (\"serial\" in device) switchService = `host:tport:serial:${device.serial}`;\n        else if (\"usb\" in device) switchService = `host:tport:usb`;\n        else if (\"tcp\" in device) switchService = `host:tport:local`;\n        else throw new TypeError(\"Invalid device selector\");\n        const connection = await this.createConnection(switchService);\n        try {\n            await connection.writeString(service);\n        } catch (e) {\n            await connection.dispose();\n            throw e;\n        }\n        try {\n            if (transportId === undefined) {\n                const array = await connection.readExactly(8);\n                transportId = (0, $jzfEx.getUint64LittleEndian)(array, 0);\n            }\n            await connection.readOkay();\n            const socket = connection.release();\n            return {\n                transportId: transportId,\n                service: service,\n                readable: socket.readable,\n                writable: new (0, $67qk3.WrapWritableStream)(socket.writable).bePipedThroughFrom(new (0, $jEctC.MaybeConsumable).UnwrapStream()),\n                get closed () {\n                    return socket.closed;\n                },\n                async close () {\n                    await socket.close();\n                }\n            };\n        } catch (e) {\n            await connection.dispose();\n            throw e;\n        }\n    }\n    /**\n     * Wait for a device to be connected or disconnected.\n     *\n     * `adb wait-for-<state>`\n     *\n     * @param device The device selector\n     * @param state The state to wait for\n     * @param options The options\n     * @returns A promise that resolves when the condition is met.\n     */ async waitFor(device, state, options) {\n        let type;\n        if (!device) type = \"any\";\n        else if (\"transportId\" in device) type = \"any\";\n        else if (\"serial\" in device) type = \"any\";\n        else if (\"usb\" in device) type = \"usb\";\n        else if (\"tcp\" in device) type = \"local\";\n        else throw new TypeError(\"Invalid device selector\");\n        // `waitFor` can't use `connectDevice`, because the device\n        // might not be available yet.\n        const service = this.formatDeviceService(device, `wait-for-${type}-${state}`);\n        const connection = await this.createConnection(service, options);\n        try {\n            await connection.readOkay();\n        } finally{\n            await connection.dispose();\n        }\n    }\n    async createTransport(device) {\n        const { transportId: transportId, features: features } = await this.getDeviceFeatures(device);\n        const devices = await this.getDevices();\n        const info = devices.find((device)=>device.transportId === transportId);\n        const banner = new (0, $bFpy9.AdbBanner)(info?.product, info?.model, info?.device, features);\n        return new (0, $btVdk.AdbServerTransport)(this, info?.serial ?? \"\", banner, transportId);\n    }\n}\nasync function $d9e611074e4605d2$export$76ed3709e60def45(callback, ...signals) {\n    const abortPromise = new (0, $aHKds.PromiseResolver)();\n    function abort() {\n        abortPromise.reject(this.reason);\n    }\n    try {\n        for (const signal of signals){\n            if (!signal) continue;\n            if (signal.aborted) throw signal.reason;\n            signal.addEventListener(\"abort\", abort);\n        }\n        return await Promise.race([\n            callback(),\n            abortPromise.promise\n        ]);\n    } finally{\n        for (const signal of signals){\n            if (!signal) continue;\n            signal.removeEventListener(\"abort\", abort);\n        }\n    }\n}\n(function(AdbServerClient) {\n    class NetworkError extends Error {\n        constructor(message){\n            super(message);\n            this.name = \"NetworkError\";\n        }\n    }\n    AdbServerClient.NetworkError = NetworkError;\n    class UnauthorizedError extends Error {\n        constructor(message){\n            super(message);\n            this.name = \"UnauthorizedError\";\n        }\n    }\n    AdbServerClient.UnauthorizedError = UnauthorizedError;\n    class AlreadyConnectedError extends Error {\n        constructor(message){\n            super(message);\n            this.name = \"AlreadyConnectedError\";\n        }\n    }\n    AdbServerClient.AlreadyConnectedError = AlreadyConnectedError;\n    class WirelessCommands {\n        #client;\n        constructor(client){\n            this.#client = client;\n        }\n        /**\n         * `adb pair <password> <address>`\n         */ async pair(address, password) {\n            const connection = await this.#client.createConnection(`host:pair:${password}:${address}`);\n            try {\n                const response = await connection.readExactly(4);\n                // `response` is either `FAIL`, or 4 hex digits for length of the string\n                if ((0, $gtlgZ.sequenceEqual)(response, $d9e611074e4605d2$var$FAIL)) throw new Error(await connection.readString());\n                const length = (0, $32bmk.hexToNumber)(response);\n                // Ignore the string as it's always `Successful ...`\n                await connection.readExactly(length);\n            } finally{\n                await connection.dispose();\n            }\n        }\n        /**\n         * `adb connect <address>`\n         */ async connect(address) {\n            const connection = await this.#client.createConnection(`host:connect:${address}`);\n            try {\n                const response = await connection.readString();\n                switch(response){\n                    case `already connected to ${address}`:\n                        throw new AdbServerClient.AlreadyConnectedError(response);\n                    case `failed to connect to ${address}`:\n                    case `failed to authenticate to ${address}`:\n                        throw new AdbServerClient.UnauthorizedError(response);\n                    case `connected to ${address}`:\n                        return;\n                    default:\n                        throw new AdbServerClient.NetworkError(response);\n                }\n            } finally{\n                await connection.dispose();\n            }\n        }\n        /**\n         * `adb disconnect <address>`\n         */ async disconnect(address) {\n            const connection = await this.#client.createConnection(`host:disconnect:${address}`);\n            try {\n                await connection.readString();\n            } finally{\n                await connection.dispose();\n            }\n        }\n    }\n    AdbServerClient.WirelessCommands = WirelessCommands;\n    class MDnsCommands {\n        #client;\n        constructor(client){\n            this.#client = client;\n        }\n        async check() {\n            const connection = await this.#client.createConnection(\"host:mdns:check\");\n            try {\n                const response = await connection.readString();\n                return !response.startsWith(\"ERROR:\");\n            } finally{\n                await connection.dispose();\n            }\n        }\n        async getServices() {\n            const connection = await this.#client.createConnection(\"host:mdns:services\");\n            try {\n                const response = await connection.readString();\n                return response.split(\"\\n\").filter(Boolean).map((line)=>{\n                    const parts = line.split(\"\t\");\n                    return {\n                        name: parts[0],\n                        service: parts[1],\n                        address: parts[2]\n                    };\n                });\n            } finally{\n                await connection.dispose();\n            }\n        }\n    }\n    AdbServerClient.MDnsCommands = MDnsCommands;\n})($d9e611074e4605d2$export$21bea6a433f41b7c || ($d9e611074e4605d2$export$21bea6a433f41b7c = {}));\n\n});\nparcelRegister(\"btVdk\", function(module, exports) {\n\n$parcel$export(module.exports, \"AdbServerTransport\", () => $85bec8a2f163a989$export$7c1775a424a7d7ad);\nparcelRequire(\"kV55x\");\nvar $aHKds = parcelRequire(\"aHKds\");\nparcelRequire(\"7edQJ\");\nvar $6NYMu = parcelRequire(\"6NYMu\");\n\nvar $drR7i = parcelRequire(\"drR7i\");\nconst $85bec8a2f163a989$export$7c2347b5f1ca1982 = [\n    (0, $drR7i.AdbFeature).ShellV2,\n    (0, $drR7i.AdbFeature).Cmd,\n    (0, $drR7i.AdbFeature).StatV2,\n    (0, $drR7i.AdbFeature).ListV2,\n    (0, $drR7i.AdbFeature).FixedPushMkdir,\n    \"apex\",\n    (0, $drR7i.AdbFeature).Abb,\n    // only tells the client the symlink timestamp issue in `adb push --sync` has been fixed.\n    // No special handling required.\n    \"fixed_push_symlink_timestamp\",\n    (0, $drR7i.AdbFeature).AbbExec,\n    \"remount_shell\",\n    \"track_app\",\n    (0, $drR7i.AdbFeature).SendReceiveV2,\n    \"sendrecv_v2_brotli\",\n    \"sendrecv_v2_lz4\",\n    \"sendrecv_v2_zstd\",\n    \"sendrecv_v2_dry_run_send\"\n];\nclass $85bec8a2f163a989$export$7c1775a424a7d7ad {\n    #client;\n    serial;\n    transportId;\n    maxPayloadSize = 1048576;\n    banner;\n    #closed = new (0, $aHKds.PromiseResolver)();\n    #waitAbortController = new (0, $6NYMu.AbortController)();\n    disconnected;\n    get clientFeatures() {\n        // No need to get host features (features supported by ADB server)\n        // Because we create all ADB packets ourselves\n        return $85bec8a2f163a989$export$7c2347b5f1ca1982;\n    }\n    constructor(client, serial, banner, transportId){\n        this.#client = client;\n        this.serial = serial;\n        this.banner = banner;\n        this.transportId = transportId;\n        this.disconnected = Promise.race([\n            this.#closed.promise,\n            client.waitFor({\n                transportId: transportId\n            }, \"disconnect\", {\n                signal: this.#waitAbortController.signal,\n                unref: true\n            })\n        ]);\n    }\n    async connect(service) {\n        return await this.#client.createDeviceConnection({\n            transportId: this.transportId\n        }, service);\n    }\n    async addReverseTunnel(handler, address) {\n        return await this.#client.connector.addReverseTunnel(handler, address);\n    }\n    async removeReverseTunnel(address) {\n        await this.#client.connector.removeReverseTunnel(address);\n    }\n    async clearReverseTunnels() {\n        await this.#client.connector.clearReverseTunnels();\n    }\n    close() {\n        this.#closed.resolve();\n        this.#waitAbortController.abort();\n    }\n}\n\n});\n\n\n\n\nparcelRegister(\"byTpg\", function(module, exports) {\n\n$parcel$export(module.exports, \"isErrorName\", () => $86add9489fa853fa$export$9c7d51c3d5b5355e);\n$parcel$export(module.exports, \"findUsbAlternateInterface\", () => $86add9489fa853fa$export$a36c2d3c1065d369);\n$parcel$export(module.exports, \"getSerialNumber\", () => $86add9489fa853fa$export$94caf855bf00ca69);\nfunction $86add9489fa853fa$export$9c7d51c3d5b5355e(e, name) {\n    // node-usb package doesn't use `DOMException`,\n    // so use a looser check\n    // https://github.com/node-usb/node-usb/issues/573\n    return typeof e === \"object\" && e !== null && \"name\" in e && e.name === name;\n}\nfunction $86add9489fa853fa$var$alternateMatchesFilter(alternate, filters) {\n    return filters.some((filter)=>alternate.interfaceClass === filter.classCode && alternate.interfaceSubclass === filter.subclassCode && alternate.interfaceProtocol === filter.protocolCode);\n}\nfunction $86add9489fa853fa$export$a36c2d3c1065d369(device, filters) {\n    for (const configuration of device.configurations){\n        for (const interface_ of configuration.interfaces)for (const alternate of interface_.alternates){\n            if ($86add9489fa853fa$var$alternateMatchesFilter(alternate, filters)) return {\n                configuration: configuration,\n                interface_: interface_,\n                alternate: alternate\n            };\n        }\n    }\n    throw new TypeError(\"No matched alternate interface found\");\n}\nfunction $86add9489fa853fa$var$padNumber(value) {\n    return value.toString(16).padStart(4, \"0\");\n}\nfunction $86add9489fa853fa$export$94caf855bf00ca69(device) {\n    if (device.serialNumber) return device.serialNumber;\n    return $86add9489fa853fa$var$padNumber(device.vendorId) + \"x\" + $86add9489fa853fa$var$padNumber(device.productId);\n}\n\n});\n\n\nparcelRegister(\"aI8PJ\", function(module, exports) {\n\n$parcel$export(module.exports, \"AdbDaemonWebUsbDeviceManager\", () => $7cc4dd8e8afc9fca$export$b13bb639ae0909dd);\n\nvar $dGdCH = parcelRequire(\"dGdCH\");\n\nvar $byTpg = parcelRequire(\"byTpg\");\nclass $7cc4dd8e8afc9fca$export$b13bb639ae0909dd {\n    /**\n     * Gets the instance of {@link AdbDaemonWebUsbDeviceManager} using browser WebUSB implementation.\n     *\n     * May be `undefined` if current runtime does not support WebUSB.\n     */ static BROWSER = typeof globalThis.navigator !== \"undefined\" && !!globalThis.navigator.usb ? new $7cc4dd8e8afc9fca$export$b13bb639ae0909dd(globalThis.navigator.usb) : undefined;\n    #usbManager;\n    /**\n     * Create a new instance of {@link AdbDaemonWebUsbDeviceManager} using the specified WebUSB implementation.\n     * @param usbManager A WebUSB compatible interface.\n     */ constructor(usbManager){\n        this.#usbManager = usbManager;\n    }\n    /**\n     * Request access to a connected device.\n     * This is a convince method for `usb.requestDevice()`.\n     * @param filters\n     * The filters to apply to the device list.\n     *\n     * It must have `classCode`, `subclassCode` and `protocolCode` fields for selecting the ADB interface,\n     * but might also have `vendorId`, `productId` or `serialNumber` fields to limit the displayed device list.\n     *\n     * Defaults to {@link ADB_DEFAULT_DEVICE_FILTER}.\n     * @returns An {@link AdbDaemonWebUsbDevice} instance if the user selected a device,\n     * or `undefined` if the user cancelled the device picker.\n     */ async requestDevice(options = {}) {\n        if (!options.filters) options.filters = [\n            (0, $dGdCH.ADB_DEFAULT_DEVICE_FILTER)\n        ];\n        else if (options.filters.length === 0) throw new TypeError(\"filters must not be empty\");\n        try {\n            const device = await this.#usbManager.requestDevice(options);\n            return new (0, $dGdCH.AdbDaemonWebUsbDevice)(device, options.filters, this.#usbManager);\n        } catch (e) {\n            // No device selected\n            if ((0, $byTpg.isErrorName)(e, \"NotFoundError\")) return undefined;\n            throw e;\n        }\n    }\n    /**\n     * Get all connected and authenticated devices.\n     * This is a convince method for `usb.getDevices()`.\n     * @param filters\n     * The filters to apply to the device list.\n     *\n     * It must have `classCode`, `subclassCode` and `protocolCode` fields for selecting the ADB interface,\n     * but might also have `vendorId`, `productId` or `serialNumber` fields to limit the device list.\n     *\n     * Defaults to {@link ADB_DEFAULT_DEVICE_FILTER}.\n     * @returns An array of {@link AdbDaemonWebUsbDevice} instances for all connected and authenticated devices.\n     */ async getDevices(filters = [\n        (0, $dGdCH.ADB_DEFAULT_DEVICE_FILTER)\n    ]) {\n        if (filters.length === 0) throw new TypeError(\"filters must not be empty\");\n        const devices = await this.#usbManager.getDevices();\n        return devices.filter((device)=>{\n            for (const filter of filters){\n                if (\"vendorId\" in filter && device.vendorId !== filter.vendorId) continue;\n                if (\"productId\" in filter && device.productId !== filter.productId) continue;\n                if (\"serialNumber\" in filter && (0, $byTpg.getSerialNumber)(device) !== filter.serialNumber) continue;\n                try {\n                    (0, $byTpg.findUsbAlternateInterface)(device, filters);\n                    return true;\n                } catch  {\n                    continue;\n                }\n            }\n            return false;\n        }).map((device)=>new (0, $dGdCH.AdbDaemonWebUsbDevice)(device, filters, this.#usbManager));\n    }\n}\n\n});\n\nparcelRegister(\"7wgv6\", function(module, exports) {\nclass $5798523fb16f23f6$export$a03a0d59dcbcc7 {\n    #callback;\n    #usbManager;\n    constructor(callback, usb){\n        this.#callback = callback;\n        this.#usbManager = usb;\n        this.#usbManager.addEventListener(\"connect\", this.#handleConnect);\n        this.#usbManager.addEventListener(\"disconnect\", this.#handleDisconnect);\n    }\n    dispose() {\n        this.#usbManager.removeEventListener(\"connect\", this.#handleConnect);\n        this.#usbManager.removeEventListener(\"disconnect\", this.#handleDisconnect);\n    }\n    #handleConnect = (e)=>{\n        this.#callback(e.device.serialNumber);\n    };\n    #handleDisconnect = ()=>{\n        this.#callback();\n    };\n}\n\n});\n\n\nparcelRegister(\"jhyqS\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => $e09a507438314e34$export$2e2bcd8739ae039);\n// cspell: ignore RSASSA\nfunction $e09a507438314e34$var$openDatabase() {\n    return new Promise((resolve, reject)=>{\n        const request = indexedDB.open(\"Tango\", 1);\n        request.onerror = ()=>{\n            reject(request.error);\n        };\n        request.onupgradeneeded = ()=>{\n            const db = request.result;\n            db.createObjectStore(\"Authentication\", {\n                autoIncrement: true\n            });\n        };\n        request.onsuccess = ()=>{\n            const db = request.result;\n            resolve(db);\n        };\n    });\n}\nasync function $e09a507438314e34$var$saveKey(key) {\n    const db = await $e09a507438314e34$var$openDatabase();\n    return new Promise((resolve, reject)=>{\n        const transaction = db.transaction(\"Authentication\", \"readwrite\");\n        const store = transaction.objectStore(\"Authentication\");\n        const putRequest = store.add(key);\n        putRequest.onerror = ()=>{\n            reject(putRequest.error);\n        };\n        putRequest.onsuccess = ()=>{\n            resolve();\n        };\n        transaction.onerror = ()=>{\n            reject(transaction.error);\n        };\n        transaction.oncomplete = ()=>{\n            db.close();\n        };\n    });\n}\nasync function $e09a507438314e34$var$getAllKeys() {\n    const db = await $e09a507438314e34$var$openDatabase();\n    return new Promise((resolve, reject)=>{\n        const transaction = db.transaction(\"Authentication\", \"readonly\");\n        const store = transaction.objectStore(\"Authentication\");\n        const getRequest = store.getAll();\n        getRequest.onerror = ()=>{\n            reject(getRequest.error);\n        };\n        getRequest.onsuccess = ()=>{\n            resolve(getRequest.result);\n        };\n        transaction.onerror = ()=>{\n            reject(transaction.error);\n        };\n        transaction.oncomplete = ()=>{\n            db.close();\n        };\n    });\n}\nclass $e09a507438314e34$export$2e2bcd8739ae039 {\n    #appName;\n    constructor(appName = \"Tango\"){\n        this.#appName = appName;\n    }\n    /**\n     * Generates a RSA private key and store it into LocalStorage.\n     *\n     * Calling this method multiple times will overwrite the previous key.\n     *\n     * @returns The private key in PKCS #8 format.\n     */ async generateKey() {\n        const { privateKey: cryptoKey } = await crypto.subtle.generateKey({\n            name: \"RSASSA-PKCS1-v1_5\",\n            modulusLength: 2048,\n            // 65537\n            publicExponent: new Uint8Array([\n                0x01,\n                0x00,\n                0x01\n            ]),\n            hash: \"SHA-1\"\n        }, true, [\n            \"sign\",\n            \"verify\"\n        ]);\n        const privateKey = new Uint8Array(await crypto.subtle.exportKey(\"pkcs8\", cryptoKey));\n        await $e09a507438314e34$var$saveKey(privateKey);\n        return {\n            buffer: privateKey,\n            name: `${this.#appName}@${globalThis.location.hostname}`\n        };\n    }\n    /**\n     * Yields the stored RSA private key.\n     *\n     * This method returns a generator, so `for await...of...` loop should be used to read the key.\n     */ async *iterateKeys() {\n        for (const key of (await $e09a507438314e34$var$getAllKeys()))yield {\n            buffer: key,\n            name: `${this.#appName}@${globalThis.location.hostname}`\n        };\n    }\n}\n\n});\n\n\n\n//# sourceMappingURL=index.44060ccf.js.map\n","import { AdbDaemonWebUsbDeviceManager } from \"@yume-chan/adb-daemon-webusb\";\nimport { ADB_DEFAULT_DEVICE_FILTER } from \"@yume-chan/adb-daemon-webusb\";\nimport AdbWebCredentialStore from \"@yume-chan/adb-credential-web\";\nimport { AdbDaemonTransport, Adb, AdbSubprocessShellProtocol } from \"@yume-chan/adb\";\n\nconst konsole = document.querySelector(\"#konsole\");\nconst CredentialStore = new AdbWebCredentialStore();\n\nconsole.log(\"hi friend!\");\nlog(navigator.usb)\nconst Manager = AdbDaemonWebUsbDeviceManager.BROWSER;\n\nif (!Manager) {\n  alert(\"WebUSB is not supported in this browser!\\nWe need WebUSB in order to function.\\nPlease try again with Google Chrome.\");\n  return;\n} else {\n  log(\"Yay, you have WebUSB!\");\n}\n\nlet device = null;\nlet devices = null;\nlet connection = null;\nlet adb = null;\nexport let onmonitor = null;\nexport let dev_list = null;\nexport let autoconnect_enabled = localStorage[\"autoconnect_enabled\"] || \"true\";\n// switch (localStorage[\"autoconnect_enabled\"]){\n//   case \"true\":\n//     autoconnect_enabled = true;\n//     break;\n//   case \"false\":\n//     autoconnect_enabled = false;\n//     break;\n//   default:\n//     set_autoconnect(true);\n//     break;\n// }\n\n\nexport function is_device() {\n  return !!(device);\n}\n\nexport function is_connected() {\n  return !!(connection)\n}\n\nexport async function pair_device() {\n  await Manager.requestDevice({\n    filters: [\n      {\n        ...ADB_DEFAULT_DEVICE_FILTER,\n        vendorId: 0x19D2,\n        productId: 0x0452\n      }\n    ]\n  });\n  await autoconnect();\n}\n\nexport async function list_existing() {\n  devices = await Manager.getDevices(\n    [\n      {\n        ...ADB_DEFAULT_DEVICE_FILTER,\n        vendorId: 0x19D2,\n        productId: 0x0452\n      }\n    ]\n  );\n  return devices;\n}\n\nexport function select_existing(serial) {\n  device = devices.filter(dev => { return dev.serial == serial; });\n  console.log(device);\n  if (device.length < 1) {\n    device = null;\n    return;\n  }\n  device = device[0];\n  if (get_autoconnect()) {\n    connect_device();\n  }\n}\n\nexport async function disconnect() {\n  if (!device) {\n    log(\"No device connected!\")\n    return;\n  }\n  try {\n    await adb.close();\n  } catch (e) {\n    log(\"Error when closing adb\");\n    console.error(e);\n  }\n  log(\"ADB session closed\");\n  adb = null;\n  try {\n    await device.raw.close();\n  } catch (e) {\n    log(\"Error when closing connection\");\n    console.error(e);\n  }\n  log(\"Connection closed\");\n  connection = null;\n  device = null;\n  if (dev_list) {\n    await draw_device_list();\n  }\n  if (onmonitor) {\n    onmonitor();\n  }\n}\n\nexport async function autoconnect() {\n  await list_existing();\n  if (device && devices.filter(dev => { return dev.serial == device.serial }).length < 1) {\n    device = null;\n  }\n  console.log(devices);\n  // if (devices.length == 0) return [];\n  if (!device && get_autoconnect() && devices.length > 0) {\n    device = devices[0]\n    await connect_device();\n    if (onmonitor) {\n      onmonitor();\n    }\n  }\n  if (dev_list) {\n    await draw_device_list();\n  }\n  return devices;\n}\n\nexport function set_autoconnect(val) {\n  val = \"\" + val;\n  autoconnect_enabled = val;\n  localStorage[\"autoconnect_enabled\"] = val;\n}\n\nexport function get_autoconnect() {\n  return autoconnect_enabled == \"true\";\n}\n\nexport function monitor_usb(dev_list_p, onmonitor_p) {\n  dev_list = dev_list_p;\n  onmonitor = onmonitor_p;\n  navigator.usb.addEventListener(\"connect\", () => {\n    log(\"Connect event received, updating devices...\");\n    autoconnect();\n  });\n  navigator.usb.addEventListener(\"disconnect\", () => {\n    log(\"Disconnect event received, updating devices...\");\n    autoconnect();\n  });\n  log(\"Checking devices due to start...\");\n  autoconnect();\n}\n\nexport async function draw_device_list() {\n  const list_elem = dev_list;\n  if (!devices) {\n    await list_existing();\n  }\n  // log(devices.toString());\n  list_elem.innerHTML = `<option value=\"null\">No device</option>`;\n  for (const dev of devices) {\n    const opt = document.createElement(\"option\");\n    opt.textContent = `${dev.raw.productName}\\t${dev.raw.manufacturerName}\\t${dev.serial}`;\n    opt.value = dev.serial;\n    list_elem.appendChild(opt);\n  }\n  if (device) {\n    list_elem.value = device.serial;\n  } else {\n    list_elem.value = \"null\";\n  }\n}\n\nexport async function connect_device() {\n  console.log(\"connect dev\")\n  if (!device) {\n    console.log(\"Device is null\");\n    alert(\"Device is null\");\n    return;\n  }\n  connection = await device.connect();\n  log(\"Device connection opened...\")\n  const transport = await AdbDaemonTransport.authenticate({\n    serial: device.serial,\n    connection,\n    credentialStore: CredentialStore,\n  });\n  log(\"ADB transport opened...\")\n  adb = new Adb(transport);\n  log(\"ADB connection created!\");\n  // console.log(adb);\n  log(\"Android version: \" + await adb.getProp(\"ro.build.version.release\"));\n  if (onmonitor) {\n    onmonitor();\n  }\n}\n\nexport async function exploit_gabb() {\n  let res = null;\n  await godo(\"am switch-user 0\");\n  res = await godo(\"pm list users\");\n  const mmus = res.stdout.matchAll(/(?<uid>\\d+):MaintenanceModeUser:/g);\n  for (const mmu of mmus) {\n    if (mmu.groups.uid) {\n      await godo(\"pm remove-user \" + mmu.groups.uid);\n    }\n  }\n  await godo(\"pm disable-user --user 0 com.gabb.packageupdater\");\n  log(\"Exploited (if no errors above, lol)!\");\n}\n\nexport async function install_app(file, user) {\n  if (!user) {\n    user = \"current\";\n  }\n  //const file_input = document.querySelector(\"#apk\");\n  //const file = file_input.files[0];\n  log(\"Acquiring sync...\");\n  const sync = await adb.sync();\n  log(\"Sending APK...\");\n  await sync.write({ filename: \"/data/local/tmp/temp.apk\", file: file.stream() });\n  sync.dispose();\n  log(\"APK sent!\");\n  let res = null;\n  log(\"Installing...\");\n  res = await godo(\"pm install-create --user \" + user);\n  const session = res.stdout.split(\"[\")[1].split(\"]\")[0];\n  await godo(`pm install-write ${session} tomato /data/local/tmp/temp.apk`);\n  await godo(`pm install-commit ${session}`);\n  await adb.rm(\"/data/local/tmp/temp.apk\");\n}\n\nexport async function send_command_and_get_response(command, ignore_errors, silence_logs) {\n  const process = await adb.subprocess.spawnAndWait(command, {\n    protocols: [AdbSubprocessShellProtocol]\n  });\n  if (process.stderr) {\n    if (!silence_logs) {\n      log(process.stderr);\n    }\n    if (!ignore_errors) {\n      throw process.stderr;\n    }\n  }\n  if (!silence_logs) {\n    log(process.stdout);\n  }\n  return process;\n}\n\nexport async function send_to_device(file) {\n  log(\"Acquiring sync...\");\n  const sync = await adb.sync();\n  log(\"Sending...\");\n  await sync.write({ filename: \"/sdcard/Download/\" + file.name, file: file.stream() });\n  await sync.dispose();\n  log(\"Sent!\");\n}\n\nexport const godo = send_command_and_get_response;\n\nexport function log(msg) {\n  if (konsole) {\n    konsole.textContent += `[${(new Date()).toLocaleString()}] ${msg}\\n`\n    konsole.scrollTo(0, konsole.scrollHeight);\n  } else {\n    console.log(msg);\n  }\n  return msg;\n}","export * from \"./device.js\";\nexport * from \"./manager.js\";\nexport * from \"./utils.js\";\nexport * from \"./watcher.js\";\n","import { AdbPacketHeader, AdbPacketSerializeStream, unreachable, } from \"@yume-chan/adb\";\nimport { DuplexStreamFactory, MaybeConsumable, ReadableStream, pipeFrom, } from \"@yume-chan/stream-extra\";\nimport { EMPTY_UINT8_ARRAY } from \"@yume-chan/struct\";\nimport { findUsbAlternateInterface, getSerialNumber, isErrorName, } from \"./utils.js\";\n/**\n * The default filter for ADB devices, as defined by Google.\n */\nexport const ADB_DEFAULT_DEVICE_FILTER = {\n    classCode: 0xff,\n    subclassCode: 0x42,\n    protocolCode: 1,\n};\n/**\n * Find the first pair of input and output endpoints from an alternate interface.\n *\n * ADB interface only has two endpoints, one for input and one for output.\n */\nfunction findUsbEndpoints(endpoints) {\n    if (endpoints.length === 0) {\n        throw new TypeError(\"No endpoints given\");\n    }\n    let inEndpoint;\n    let outEndpoint;\n    for (const endpoint of endpoints) {\n        switch (endpoint.direction) {\n            case \"in\":\n                inEndpoint = endpoint;\n                if (outEndpoint) {\n                    return { inEndpoint, outEndpoint };\n                }\n                break;\n            case \"out\":\n                outEndpoint = endpoint;\n                if (inEndpoint) {\n                    return { inEndpoint, outEndpoint };\n                }\n                break;\n        }\n    }\n    if (!inEndpoint) {\n        throw new TypeError(\"No input endpoint found.\");\n    }\n    if (!outEndpoint) {\n        throw new TypeError(\"No output endpoint found.\");\n    }\n    throw new Error(\"unreachable\");\n}\nclass Uint8ArrayExactReadable {\n    #data;\n    #position;\n    get position() {\n        return this.#position;\n    }\n    constructor(data) {\n        this.#data = data;\n        this.#position = 0;\n    }\n    readExactly(length) {\n        const result = this.#data.subarray(this.#position, this.#position + length);\n        this.#position += length;\n        return result;\n    }\n}\nexport class AdbDaemonWebUsbConnection {\n    #device;\n    get device() {\n        return this.#device;\n    }\n    #inEndpoint;\n    get inEndpoint() {\n        return this.#inEndpoint;\n    }\n    #outEndpoint;\n    get outEndpoint() {\n        return this.#outEndpoint;\n    }\n    #readable;\n    get readable() {\n        return this.#readable;\n    }\n    #writable;\n    get writable() {\n        return this.#writable;\n    }\n    constructor(device, inEndpoint, outEndpoint, usbManager) {\n        this.#device = device;\n        this.#inEndpoint = inEndpoint;\n        this.#outEndpoint = outEndpoint;\n        let closed = false;\n        const duplex = new DuplexStreamFactory({\n            close: async () => {\n                try {\n                    closed = true;\n                    await device.raw.close();\n                }\n                catch {\n                    /* device may have already disconnected */\n                }\n            },\n            dispose: () => {\n                closed = true;\n                usbManager.removeEventListener(\"disconnect\", handleUsbDisconnect);\n            },\n        });\n        function handleUsbDisconnect(e) {\n            if (e.device === device.raw) {\n                duplex.dispose().catch(unreachable);\n            }\n        }\n        usbManager.addEventListener(\"disconnect\", handleUsbDisconnect);\n        this.#readable = duplex.wrapReadable(new ReadableStream({\n            pull: async (controller) => {\n                const packet = await this.#transferIn();\n                if (packet) {\n                    controller.enqueue(packet);\n                }\n                else {\n                    controller.close();\n                }\n            },\n        }, { highWaterMark: 0 }));\n        const zeroMask = outEndpoint.packetSize - 1;\n        this.#writable = pipeFrom(duplex.createWritable(new MaybeConsumable.WritableStream({\n            write: async (chunk) => {\n                try {\n                    await device.raw.transferOut(outEndpoint.endpointNumber, chunk);\n                    // In USB protocol, a not-full packet indicates the end of a transfer.\n                    // If the payload size is a multiple of the packet size,\n                    // we need to send an empty packet to indicate the end,\n                    // so the OS will send it to the device immediately.\n                    if (zeroMask && (chunk.length & zeroMask) === 0) {\n                        await device.raw.transferOut(outEndpoint.endpointNumber, EMPTY_UINT8_ARRAY);\n                    }\n                }\n                catch (e) {\n                    if (closed) {\n                        return;\n                    }\n                    throw e;\n                }\n            },\n        })), new AdbPacketSerializeStream());\n    }\n    async #transferIn() {\n        try {\n            while (true) {\n                // ADB daemon sends each packet in two parts, the 24-byte header and the payload.\n                const result = await this.#device.raw.transferIn(this.#inEndpoint.endpointNumber, this.#inEndpoint.packetSize);\n                if (result.data.byteLength !== 24) {\n                    continue;\n                }\n                // Per spec, the `result.data` always covers the whole `buffer`.\n                const buffer = new Uint8Array(result.data.buffer);\n                const stream = new Uint8ArrayExactReadable(buffer);\n                // Add `payload` field to its type, it's assigned below.\n                const packet = AdbPacketHeader.deserialize(stream);\n                if (packet.magic !== (packet.command ^ 0xffffffff)) {\n                    continue;\n                }\n                if (packet.payloadLength !== 0) {\n                    const result = await this.#device.raw.transferIn(this.#inEndpoint.endpointNumber, packet.payloadLength);\n                    packet.payload = new Uint8Array(result.data.buffer);\n                }\n                else {\n                    packet.payload = EMPTY_UINT8_ARRAY;\n                }\n                return packet;\n            }\n        }\n        catch (e) {\n            // On Windows, disconnecting the device will cause `NetworkError` to be thrown,\n            // even before the `disconnect` event is fired.\n            // We need to wait a little bit and check if the device is still connected.\n            // https://github.com/WICG/webusb/issues/219\n            if (isErrorName(e, \"NetworkError\")) {\n                await new Promise((resolve) => {\n                    setTimeout(() => {\n                        resolve();\n                    }, 100);\n                });\n                if (closed) {\n                    return undefined;\n                }\n                else {\n                    throw e;\n                }\n            }\n            throw e;\n        }\n    }\n}\nexport class AdbDaemonWebUsbDevice {\n    #filters;\n    #usbManager;\n    #raw;\n    get raw() {\n        return this.#raw;\n    }\n    #serial;\n    get serial() {\n        return this.#serial;\n    }\n    get name() {\n        return this.#raw.productName;\n    }\n    /**\n     * Create a new instance of `AdbDaemonWebUsbConnection` using a specified `USBDevice` instance\n     *\n     * @param device The `USBDevice` instance obtained elsewhere.\n     * @param filters The filters to use when searching for ADB interface. Defaults to {@link ADB_DEFAULT_DEVICE_FILTER}.\n     */\n    constructor(device, filters = [ADB_DEFAULT_DEVICE_FILTER], usbManager) {\n        this.#raw = device;\n        this.#serial = getSerialNumber(device);\n        this.#filters = filters;\n        this.#usbManager = usbManager;\n    }\n    async #claimInterface() {\n        if (!this.#raw.opened) {\n            await this.#raw.open();\n        }\n        const { configuration, interface_, alternate } = findUsbAlternateInterface(this.#raw, this.#filters);\n        if (this.#raw.configuration?.configurationValue !==\n            configuration.configurationValue) {\n            // Note: Switching configuration is not supported on Windows,\n            // but Android devices should always expose ADB function at the first (default) configuration.\n            await this.#raw.selectConfiguration(configuration.configurationValue);\n        }\n        if (!interface_.claimed) {\n            await this.#raw.claimInterface(interface_.interfaceNumber);\n        }\n        if (interface_.alternate.alternateSetting !== alternate.alternateSetting) {\n            await this.#raw.selectAlternateInterface(interface_.interfaceNumber, alternate.alternateSetting);\n        }\n        const { inEndpoint, outEndpoint } = findUsbEndpoints(alternate.endpoints);\n        return [inEndpoint, outEndpoint];\n    }\n    /**\n     * Claim the device and create a pair of `AdbPacket` streams to the ADB interface.\n     * @returns The pair of `AdbPacket` streams.\n     */\n    async connect() {\n        const [inEndpoint, outEndpoint] = await this.#claimInterface();\n        return new AdbDaemonWebUsbConnection(this, inEndpoint, outEndpoint, this.#usbManager);\n    }\n}\n//# sourceMappingURL=device.js.map","import type {\n    AdbDaemonDevice,\n    AdbPacketData,\n    AdbPacketInit,\n} from \"@yume-chan/adb\";\nimport {\n    AdbPacketHeader,\n    AdbPacketSerializeStream,\n    unreachable,\n} from \"@yume-chan/adb\";\nimport type {\n    Consumable,\n    ReadableWritablePair,\n    WritableStream,\n} from \"@yume-chan/stream-extra\";\nimport {\n    DuplexStreamFactory,\n    MaybeConsumable,\n    ReadableStream,\n    pipeFrom,\n} from \"@yume-chan/stream-extra\";\nimport type { ExactReadable } from \"@yume-chan/struct\";\nimport { EMPTY_UINT8_ARRAY } from \"@yume-chan/struct\";\n\nimport type { AdbDeviceFilter } from \"./utils.js\";\nimport {\n    findUsbAlternateInterface,\n    getSerialNumber,\n    isErrorName,\n} from \"./utils.js\";\n\n/**\n * The default filter for ADB devices, as defined by Google.\n */\nexport const ADB_DEFAULT_DEVICE_FILTER = {\n    classCode: 0xff,\n    subclassCode: 0x42,\n    protocolCode: 1,\n} as const satisfies AdbDeviceFilter;\n\n/**\n * Find the first pair of input and output endpoints from an alternate interface.\n *\n * ADB interface only has two endpoints, one for input and one for output.\n */\nfunction findUsbEndpoints(endpoints: USBEndpoint[]) {\n    if (endpoints.length === 0) {\n        throw new TypeError(\"No endpoints given\");\n    }\n\n    let inEndpoint: USBEndpoint | undefined;\n    let outEndpoint: USBEndpoint | undefined;\n\n    for (const endpoint of endpoints) {\n        switch (endpoint.direction) {\n            case \"in\":\n                inEndpoint = endpoint;\n                if (outEndpoint) {\n                    return { inEndpoint, outEndpoint };\n                }\n                break;\n            case \"out\":\n                outEndpoint = endpoint;\n                if (inEndpoint) {\n                    return { inEndpoint, outEndpoint };\n                }\n                break;\n        }\n    }\n\n    if (!inEndpoint) {\n        throw new TypeError(\"No input endpoint found.\");\n    }\n    if (!outEndpoint) {\n        throw new TypeError(\"No output endpoint found.\");\n    }\n    throw new Error(\"unreachable\");\n}\n\nclass Uint8ArrayExactReadable implements ExactReadable {\n    #data: Uint8Array;\n    #position: number;\n\n    get position() {\n        return this.#position;\n    }\n\n    constructor(data: Uint8Array) {\n        this.#data = data;\n        this.#position = 0;\n    }\n\n    readExactly(length: number): Uint8Array {\n        const result = this.#data.subarray(\n            this.#position,\n            this.#position + length,\n        );\n        this.#position += length;\n        return result;\n    }\n}\n\nexport class AdbDaemonWebUsbConnection\n    implements ReadableWritablePair<AdbPacketData, Consumable<AdbPacketInit>>\n{\n    #device: AdbDaemonWebUsbDevice;\n    get device() {\n        return this.#device;\n    }\n\n    #inEndpoint: USBEndpoint;\n    get inEndpoint() {\n        return this.#inEndpoint;\n    }\n\n    #outEndpoint: USBEndpoint;\n    get outEndpoint() {\n        return this.#outEndpoint;\n    }\n\n    #readable: ReadableStream<AdbPacketData>;\n    get readable() {\n        return this.#readable;\n    }\n\n    #writable: WritableStream<Consumable<AdbPacketInit>>;\n    get writable() {\n        return this.#writable;\n    }\n\n    constructor(\n        device: AdbDaemonWebUsbDevice,\n        inEndpoint: USBEndpoint,\n        outEndpoint: USBEndpoint,\n        usbManager: USB,\n    ) {\n        this.#device = device;\n        this.#inEndpoint = inEndpoint;\n        this.#outEndpoint = outEndpoint;\n\n        let closed = false;\n\n        const duplex = new DuplexStreamFactory<\n            AdbPacketData,\n            Consumable<Uint8Array>\n        >({\n            close: async () => {\n                try {\n                    closed = true;\n                    await device.raw.close();\n                } catch {\n                    /* device may have already disconnected */\n                }\n            },\n            dispose: () => {\n                closed = true;\n                usbManager.removeEventListener(\n                    \"disconnect\",\n                    handleUsbDisconnect,\n                );\n            },\n        });\n\n        function handleUsbDisconnect(e: USBConnectionEvent) {\n            if (e.device === device.raw) {\n                duplex.dispose().catch(unreachable);\n            }\n        }\n\n        usbManager.addEventListener(\"disconnect\", handleUsbDisconnect);\n\n        this.#readable = duplex.wrapReadable(\n            new ReadableStream<AdbPacketData>(\n                {\n                    pull: async (controller) => {\n                        const packet = await this.#transferIn();\n                        if (packet) {\n                            controller.enqueue(packet);\n                        } else {\n                            controller.close();\n                        }\n                    },\n                },\n                { highWaterMark: 0 },\n            ),\n        );\n\n        const zeroMask = outEndpoint.packetSize - 1;\n        this.#writable = pipeFrom(\n            duplex.createWritable(\n                new MaybeConsumable.WritableStream({\n                    write: async (chunk) => {\n                        try {\n                            await device.raw.transferOut(\n                                outEndpoint.endpointNumber,\n                                chunk,\n                            );\n\n                            // In USB protocol, a not-full packet indicates the end of a transfer.\n                            // If the payload size is a multiple of the packet size,\n                            // we need to send an empty packet to indicate the end,\n                            // so the OS will send it to the device immediately.\n                            if (zeroMask && (chunk.length & zeroMask) === 0) {\n                                await device.raw.transferOut(\n                                    outEndpoint.endpointNumber,\n                                    EMPTY_UINT8_ARRAY,\n                                );\n                            }\n                        } catch (e) {\n                            if (closed) {\n                                return;\n                            }\n                            throw e;\n                        }\n                    },\n                }),\n            ),\n            new AdbPacketSerializeStream(),\n        );\n    }\n\n    async #transferIn(): Promise<AdbPacketData | undefined> {\n        try {\n            while (true) {\n                // ADB daemon sends each packet in two parts, the 24-byte header and the payload.\n                const result = await this.#device.raw.transferIn(\n                    this.#inEndpoint.endpointNumber,\n                    this.#inEndpoint.packetSize,\n                );\n\n                if (result.data!.byteLength !== 24) {\n                    continue;\n                }\n\n                // Per spec, the `result.data` always covers the whole `buffer`.\n                const buffer = new Uint8Array(result.data!.buffer);\n                const stream = new Uint8ArrayExactReadable(buffer);\n\n                // Add `payload` field to its type, it's assigned below.\n                const packet = AdbPacketHeader.deserialize(\n                    stream,\n                ) as AdbPacketHeader & { payload: Uint8Array };\n\n                if (packet.magic !== (packet.command ^ 0xffffffff)) {\n                    continue;\n                }\n\n                if (packet.payloadLength !== 0) {\n                    const result = await this.#device.raw.transferIn(\n                        this.#inEndpoint.endpointNumber,\n                        packet.payloadLength,\n                    );\n                    packet.payload = new Uint8Array(result.data!.buffer);\n                } else {\n                    packet.payload = EMPTY_UINT8_ARRAY;\n                }\n\n                return packet;\n            }\n        } catch (e) {\n            // On Windows, disconnecting the device will cause `NetworkError` to be thrown,\n            // even before the `disconnect` event is fired.\n            // We need to wait a little bit and check if the device is still connected.\n            // https://github.com/WICG/webusb/issues/219\n            if (isErrorName(e, \"NetworkError\")) {\n                await new Promise<void>((resolve) => {\n                    setTimeout(() => {\n                        resolve();\n                    }, 100);\n                });\n\n                if (closed) {\n                    return undefined;\n                } else {\n                    throw e;\n                }\n            }\n\n            throw e;\n        }\n    }\n}\n\nexport class AdbDaemonWebUsbDevice implements AdbDaemonDevice {\n    #filters: AdbDeviceFilter[];\n    #usbManager: USB;\n\n    #raw: USBDevice;\n    get raw() {\n        return this.#raw;\n    }\n\n    #serial: string;\n    get serial(): string {\n        return this.#serial;\n    }\n\n    get name(): string {\n        return this.#raw.productName!;\n    }\n\n    /**\n     * Create a new instance of `AdbDaemonWebUsbConnection` using a specified `USBDevice` instance\n     *\n     * @param device The `USBDevice` instance obtained elsewhere.\n     * @param filters The filters to use when searching for ADB interface. Defaults to {@link ADB_DEFAULT_DEVICE_FILTER}.\n     */\n    constructor(\n        device: USBDevice,\n        filters: AdbDeviceFilter[] = [ADB_DEFAULT_DEVICE_FILTER],\n        usbManager: USB,\n    ) {\n        this.#raw = device;\n        this.#serial = getSerialNumber(device);\n        this.#filters = filters;\n        this.#usbManager = usbManager;\n    }\n\n    async #claimInterface(): Promise<[USBEndpoint, USBEndpoint]> {\n        if (!this.#raw.opened) {\n            await this.#raw.open();\n        }\n\n        const { configuration, interface_, alternate } =\n            findUsbAlternateInterface(this.#raw, this.#filters);\n\n        if (\n            this.#raw.configuration?.configurationValue !==\n            configuration.configurationValue\n        ) {\n            // Note: Switching configuration is not supported on Windows,\n            // but Android devices should always expose ADB function at the first (default) configuration.\n            await this.#raw.selectConfiguration(\n                configuration.configurationValue,\n            );\n        }\n\n        if (!interface_.claimed) {\n            await this.#raw.claimInterface(interface_.interfaceNumber);\n        }\n\n        if (\n            interface_.alternate.alternateSetting !== alternate.alternateSetting\n        ) {\n            await this.#raw.selectAlternateInterface(\n                interface_.interfaceNumber,\n                alternate.alternateSetting,\n            );\n        }\n\n        const { inEndpoint, outEndpoint } = findUsbEndpoints(\n            alternate.endpoints,\n        );\n        return [inEndpoint, outEndpoint];\n    }\n\n    /**\n     * Claim the device and create a pair of `AdbPacket` streams to the ADB interface.\n     * @returns The pair of `AdbPacket` streams.\n     */\n    async connect(): Promise<AdbDaemonWebUsbConnection> {\n        const [inEndpoint, outEndpoint] = await this.#claimInterface();\n        return new AdbDaemonWebUsbConnection(\n            this,\n            inEndpoint,\n            outEndpoint,\n            this.#usbManager,\n        );\n    }\n}\n","export * from \"./adb.js\";\nexport * from \"./banner.js\";\nexport * from \"./commands/index.js\";\nexport * from \"./daemon/index.js\";\nexport * from \"./features.js\";\nexport * from \"./server/index.js\";\nexport * from \"./utils/index.js\";\n","import { ConcatStringStream, TextDecoderStream } from \"@yume-chan/stream-extra\";\nimport { AdbPower, AdbReverseCommand, AdbSubprocess, AdbSync, AdbTcpIpCommand, escapeArg, framebuffer, } from \"./commands/index.js\";\nexport class Adb {\n    transport;\n    get serial() {\n        return this.transport.serial;\n    }\n    get maxPayloadSize() {\n        return this.transport.maxPayloadSize;\n    }\n    get banner() {\n        return this.transport.banner;\n    }\n    get disconnected() {\n        return this.transport.disconnected;\n    }\n    get clientFeatures() {\n        return this.transport.clientFeatures;\n    }\n    get deviceFeatures() {\n        return this.banner.features;\n    }\n    subprocess;\n    power;\n    reverse;\n    tcpip;\n    constructor(transport) {\n        this.transport = transport;\n        this.subprocess = new AdbSubprocess(this);\n        this.power = new AdbPower(this);\n        this.reverse = new AdbReverseCommand(this);\n        this.tcpip = new AdbTcpIpCommand(this);\n    }\n    canUseFeature(feature) {\n        return (this.clientFeatures.includes(feature) &&\n            this.deviceFeatures.includes(feature));\n    }\n    async createSocket(service) {\n        return this.transport.connect(service);\n    }\n    async createSocketAndWait(service) {\n        const socket = await this.createSocket(service);\n        return await socket.readable\n            .pipeThrough(new TextDecoderStream())\n            .pipeThrough(new ConcatStringStream());\n    }\n    async getProp(key) {\n        const stdout = await this.subprocess.spawnAndWaitLegacy([\n            \"getprop\",\n            key,\n        ]);\n        return stdout.trim();\n    }\n    async rm(filenames, options) {\n        const args = [\"rm\"];\n        if (options?.recursive) {\n            args.push(\"-r\");\n        }\n        if (options?.force) {\n            args.push(\"-f\");\n        }\n        if (Array.isArray(filenames)) {\n            for (const filename of filenames) {\n                args.push(escapeArg(filename));\n            }\n        }\n        else {\n            args.push(escapeArg(filenames));\n        }\n        // https://android.googlesource.com/platform/packages/modules/adb/+/1a0fb8846d4e6b671c8aa7f137a8c21d7b248716/client/adb_install.cpp#984\n        args.push(\"</dev/null\");\n        const stdout = await this.subprocess.spawnAndWaitLegacy(args);\n        return stdout;\n    }\n    async sync() {\n        const socket = await this.createSocket(\"sync:\");\n        return new AdbSync(this, socket);\n    }\n    async framebuffer() {\n        return framebuffer(this);\n    }\n    async close() {\n        await this.transport.close();\n    }\n}\n//# sourceMappingURL=adb.js.map","import type {\n    MaybeConsumable,\n    ReadableWritablePair,\n} from \"@yume-chan/stream-extra\";\nimport { ConcatStringStream, TextDecoderStream } from \"@yume-chan/stream-extra\";\nimport type { ValueOrPromise } from \"@yume-chan/struct\";\n\nimport type { AdbBanner } from \"./banner.js\";\nimport type { AdbFrameBuffer } from \"./commands/index.js\";\nimport {\n    AdbPower,\n    AdbReverseCommand,\n    AdbSubprocess,\n    AdbSync,\n    AdbTcpIpCommand,\n    escapeArg,\n    framebuffer,\n} from \"./commands/index.js\";\nimport type { AdbFeature } from \"./features.js\";\n\nexport interface Closeable {\n    close(): ValueOrPromise<void>;\n}\n\nexport interface AdbSocket\n    extends ReadableWritablePair<Uint8Array, MaybeConsumable<Uint8Array>>,\n        Closeable {\n    get service(): string;\n\n    get closed(): Promise<void>;\n}\n\nexport type AdbIncomingSocketHandler = (\n    socket: AdbSocket,\n) => ValueOrPromise<void>;\n\nexport interface AdbTransport extends Closeable {\n    readonly serial: string;\n\n    readonly maxPayloadSize: number;\n\n    readonly banner: AdbBanner;\n\n    readonly disconnected: Promise<void>;\n\n    readonly clientFeatures: readonly AdbFeature[];\n\n    connect(service: string): ValueOrPromise<AdbSocket>;\n\n    addReverseTunnel(\n        handler: AdbIncomingSocketHandler,\n        address?: string,\n    ): ValueOrPromise<string>;\n\n    removeReverseTunnel(address: string): ValueOrPromise<void>;\n\n    clearReverseTunnels(): ValueOrPromise<void>;\n}\n\nexport class Adb implements Closeable {\n    readonly transport: AdbTransport;\n\n    get serial() {\n        return this.transport.serial;\n    }\n\n    get maxPayloadSize() {\n        return this.transport.maxPayloadSize;\n    }\n\n    get banner() {\n        return this.transport.banner;\n    }\n\n    get disconnected() {\n        return this.transport.disconnected;\n    }\n\n    public get clientFeatures() {\n        return this.transport.clientFeatures;\n    }\n\n    public get deviceFeatures() {\n        return this.banner.features;\n    }\n\n    readonly subprocess: AdbSubprocess;\n    readonly power: AdbPower;\n    readonly reverse: AdbReverseCommand;\n    readonly tcpip: AdbTcpIpCommand;\n\n    constructor(transport: AdbTransport) {\n        this.transport = transport;\n\n        this.subprocess = new AdbSubprocess(this);\n        this.power = new AdbPower(this);\n        this.reverse = new AdbReverseCommand(this);\n        this.tcpip = new AdbTcpIpCommand(this);\n    }\n\n    canUseFeature(feature: AdbFeature): boolean {\n        return (\n            this.clientFeatures.includes(feature) &&\n            this.deviceFeatures.includes(feature)\n        );\n    }\n\n    async createSocket(service: string): Promise<AdbSocket> {\n        return this.transport.connect(service);\n    }\n\n    async createSocketAndWait(service: string): Promise<string> {\n        const socket = await this.createSocket(service);\n        return await socket.readable\n            .pipeThrough(new TextDecoderStream())\n            .pipeThrough(new ConcatStringStream());\n    }\n\n    async getProp(key: string): Promise<string> {\n        const stdout = await this.subprocess.spawnAndWaitLegacy([\n            \"getprop\",\n            key,\n        ]);\n        return stdout.trim();\n    }\n\n    async rm(\n        filenames: string | string[],\n        options?: { recursive?: boolean; force?: boolean },\n    ): Promise<string> {\n        const args = [\"rm\"];\n        if (options?.recursive) {\n            args.push(\"-r\");\n        }\n        if (options?.force) {\n            args.push(\"-f\");\n        }\n        if (Array.isArray(filenames)) {\n            for (const filename of filenames) {\n                args.push(escapeArg(filename));\n            }\n        } else {\n            args.push(escapeArg(filenames));\n        }\n        // https://android.googlesource.com/platform/packages/modules/adb/+/1a0fb8846d4e6b671c8aa7f137a8c21d7b248716/client/adb_install.cpp#984\n        args.push(\"</dev/null\");\n        const stdout = await this.subprocess.spawnAndWaitLegacy(args);\n        return stdout;\n    }\n\n    async sync(): Promise<AdbSync> {\n        const socket = await this.createSocket(\"sync:\");\n        return new AdbSync(this, socket);\n    }\n\n    async framebuffer(): Promise<AdbFrameBuffer> {\n        return framebuffer(this);\n    }\n\n    async close(): Promise<void> {\n        await this.transport.close();\n    }\n}\n","export * from \"./buffered-transform.js\";\nexport * from \"./buffered.js\";\nexport * from \"./concat.js\";\nexport * from \"./consumable.js\";\nexport * from \"./distribution.js\";\nexport * from \"./duplex.js\";\nexport * from \"./encoding.js\";\nexport * from \"./inspect.js\";\nexport * from \"./maybe-consumable.js\";\nexport * from \"./pipe-from.js\";\nexport * from \"./push-readable.js\";\nexport * from \"./split-string.js\";\nexport * from \"./stream.js\";\nexport * from \"./struct-deserialize.js\";\nexport * from \"./struct-serialize.js\";\nexport * from \"./task.js\";\nexport * from \"./wrap-readable.js\";\nexport * from \"./wrap-writable.js\";\n","import { StructEmptyError } from \"@yume-chan/struct\";\nimport { BufferedReadableStream } from \"./buffered.js\";\nimport { PushReadableStream } from \"./push-readable.js\";\nimport { ReadableStream, WritableStream } from \"./stream.js\";\n// TODO: BufferedTransformStream: find better implementation\nexport class BufferedTransformStream {\n    #readable;\n    get readable() {\n        return this.#readable;\n    }\n    #writable;\n    get writable() {\n        return this.#writable;\n    }\n    constructor(transform) {\n        // Convert incoming chunks to a `BufferedReadableStream`\n        let sourceStreamController;\n        const buffered = new BufferedReadableStream(new PushReadableStream((controller) => {\n            sourceStreamController = controller;\n        }));\n        this.#readable = new ReadableStream({\n            async pull(controller) {\n                try {\n                    const value = await transform(buffered);\n                    controller.enqueue(value);\n                }\n                catch (e) {\n                    // Treat `StructEmptyError` as a normal end.\n                    // If the `transform` method doesn't have enough data to return a value,\n                    // it should throw another error to indicate that.\n                    if (e instanceof StructEmptyError) {\n                        controller.close();\n                        return;\n                    }\n                    throw e;\n                }\n            },\n            cancel: (reason) => {\n                // Propagate cancel to the source stream\n                // So future writes will be rejected\n                return buffered.cancel(reason);\n            },\n        });\n        this.#writable = new WritableStream({\n            async write(chunk) {\n                await sourceStreamController.enqueue(chunk);\n            },\n            abort() {\n                sourceStreamController.close();\n            },\n            close() {\n                sourceStreamController.close();\n            },\n        });\n    }\n}\n//# sourceMappingURL=buffered-transform.js.map","import type { ValueOrPromise } from \"@yume-chan/struct\";\nimport { StructEmptyError } from \"@yume-chan/struct\";\n\nimport { BufferedReadableStream } from \"./buffered.js\";\nimport type { PushReadableStreamController } from \"./push-readable.js\";\nimport { PushReadableStream } from \"./push-readable.js\";\nimport type { ReadableWritablePair } from \"./stream.js\";\nimport { ReadableStream, WritableStream } from \"./stream.js\";\n\n// TODO: BufferedTransformStream: find better implementation\nexport class BufferedTransformStream<T>\n    implements ReadableWritablePair<T, Uint8Array>\n{\n    #readable: ReadableStream<T>;\n    get readable() {\n        return this.#readable;\n    }\n\n    #writable: WritableStream<Uint8Array>;\n    get writable() {\n        return this.#writable;\n    }\n\n    constructor(\n        transform: (stream: BufferedReadableStream) => ValueOrPromise<T>,\n    ) {\n        // Convert incoming chunks to a `BufferedReadableStream`\n        let sourceStreamController!: PushReadableStreamController<Uint8Array>;\n\n        const buffered = new BufferedReadableStream(\n            new PushReadableStream<Uint8Array>((controller) => {\n                sourceStreamController = controller;\n            }),\n        );\n\n        this.#readable = new ReadableStream<T>({\n            async pull(controller) {\n                try {\n                    const value = await transform(buffered);\n                    controller.enqueue(value);\n                } catch (e) {\n                    // Treat `StructEmptyError` as a normal end.\n                    // If the `transform` method doesn't have enough data to return a value,\n                    // it should throw another error to indicate that.\n                    if (e instanceof StructEmptyError) {\n                        controller.close();\n                        return;\n                    }\n                    throw e;\n                }\n            },\n            cancel: (reason) => {\n                // Propagate cancel to the source stream\n                // So future writes will be rejected\n                return buffered.cancel(reason);\n            },\n        });\n\n        this.#writable = new WritableStream({\n            async write(chunk) {\n                await sourceStreamController.enqueue(chunk);\n            },\n            abort() {\n                sourceStreamController.close();\n            },\n            close() {\n                sourceStreamController.close();\n            },\n        });\n    }\n}\n","declare global {\n    interface ArrayBuffer {\n        // Disallow assigning `Uint8Array` to `Arraybuffer`\n        __brand: never;\n    }\n\n    interface SharedArrayBuffer {\n        // Allow `SharedArrayBuffer` to be assigned to `ArrayBuffer`\n        __brand: never;\n    }\n}\n\nexport * from \"./basic/index.js\";\nexport * from \"./struct.js\";\nexport { Struct as default } from \"./struct.js\";\nexport * from \"./sync-promise.js\";\nexport * from \"./types/index.js\";\nexport * from \"./utils.js\";\n","export * from \"./definition.js\";\nexport * from \"./field-value.js\";\nexport * from \"./options.js\";\nexport * from \"./stream.js\";\nexport * from \"./struct-value.js\";\n","/**\n * A field definition defines how to deserialize a field.\n *\n * @template TOptions TypeScript type of this definition's `options`.\n * @template TValue TypeScript type of this field.\n * @template TOmitInitKey Optionally remove some fields from the init type. Should be a union of string literal types.\n */\nexport class StructFieldDefinition {\n    /**\n     * When `T` is a type initiated `StructFieldDefinition`,\n     * use `T['TValue']` to retrieve its `TValue` type parameter.\n     */\n    TValue;\n    /**\n     * When `T` is a type initiated `StructFieldDefinition`,\n     * use `T['TOmitInitKey']` to retrieve its `TOmitInitKey` type parameter.\n     */\n    TOmitInitKey;\n    options;\n    constructor(options) {\n        this.options = options;\n    }\n}\n//# sourceMappingURL=definition.js.map","import type { StructFieldValue } from \"./field-value.js\";\nimport type { StructOptions } from \"./options.js\";\nimport type { AsyncExactReadable, ExactReadable } from \"./stream.js\";\nimport type { StructValue } from \"./struct-value.js\";\n\n/**\n * A field definition defines how to deserialize a field.\n *\n * @template TOptions TypeScript type of this definition's `options`.\n * @template TValue TypeScript type of this field.\n * @template TOmitInitKey Optionally remove some fields from the init type. Should be a union of string literal types.\n */\nexport abstract class StructFieldDefinition<\n    TOptions = void,\n    TValue = unknown,\n    TOmitInitKey extends PropertyKey = never,\n> {\n    /**\n     * When `T` is a type initiated `StructFieldDefinition`,\n     * use `T['TValue']` to retrieve its `TValue` type parameter.\n     */\n    readonly TValue!: TValue;\n\n    /**\n     * When `T` is a type initiated `StructFieldDefinition`,\n     * use `T['TOmitInitKey']` to retrieve its `TOmitInitKey` type parameter.\n     */\n    readonly TOmitInitKey!: TOmitInitKey;\n\n    readonly options: TOptions;\n\n    constructor(options: TOptions) {\n        this.options = options;\n    }\n\n    /**\n     * When implemented in derived classes, returns the size (or minimal size if it's dynamic) of this field.\n     *\n     * Actual size can be retrieved from `StructFieldValue#getSize`\n     */\n    abstract getSize(): number;\n\n    /**\n     * When implemented in derived classes, creates a `StructFieldValue` from a given `value`.\n     */\n    abstract create(\n        options: Readonly<StructOptions>,\n        structValue: StructValue,\n        value: TValue,\n    ): StructFieldValue<this>;\n\n    /**\n     * When implemented in derived classes,It must be synchronous (returns a value) or asynchronous (returns a `Promise`) depending\n     * on the type of `stream`. reads and creates a `StructFieldValue` from `stream`.\n     *\n     *  `SyncPromise` can be used to simplify implementation.\n     */\n    abstract deserialize(\n        options: Readonly<StructOptions>,\n        stream: ExactReadable,\n        structValue: StructValue,\n    ): StructFieldValue<this>;\n    abstract deserialize(\n        options: Readonly<StructOptions>,\n        stream: AsyncExactReadable,\n        struct: StructValue,\n    ): Promise<StructFieldValue<this>>;\n}\n","/**\n * A field value defines how to serialize a field.\n *\n * It may contains extra metadata about the value which are essential or\n * helpful for the serialization process.\n */\nexport class StructFieldValue {\n    /** Gets the definition associated with this runtime value */\n    definition;\n    /** Gets the options of the associated `Struct` */\n    options;\n    /** Gets the associated `Struct` instance */\n    struct;\n    get hasCustomAccessors() {\n        return (this.get !== StructFieldValue.prototype.get ||\n            this.set !== StructFieldValue.prototype.set);\n    }\n    value;\n    constructor(definition, options, struct, value) {\n        this.definition = definition;\n        this.options = options;\n        this.struct = struct;\n        this.value = value;\n    }\n    /**\n     * Gets size of this field. By default, it returns its `definition`'s size.\n     *\n     * When overridden in derived classes, can have custom logic to calculate the actual size.\n     */\n    getSize() {\n        return this.definition.getSize();\n    }\n    /**\n     * When implemented in derived classes, reads current field's value.\n     */\n    get() {\n        return this.value;\n    }\n    /**\n     * When implemented in derived classes, updates current field's value.\n     */\n    set(value) {\n        this.value = value;\n    }\n}\n//# sourceMappingURL=field-value.js.map","import type { StructFieldDefinition } from \"./definition.js\";\nimport type { StructOptions } from \"./options.js\";\nimport type { StructValue } from \"./struct-value.js\";\n\n/**\n * A field value defines how to serialize a field.\n *\n * It may contains extra metadata about the value which are essential or\n * helpful for the serialization process.\n */\nexport abstract class StructFieldValue<\n    TDefinition extends StructFieldDefinition<unknown, unknown, PropertyKey>,\n> {\n    /** Gets the definition associated with this runtime value */\n    readonly definition: TDefinition;\n\n    /** Gets the options of the associated `Struct` */\n    readonly options: Readonly<StructOptions>;\n\n    /** Gets the associated `Struct` instance */\n    readonly struct: StructValue;\n\n    get hasCustomAccessors(): boolean {\n        return (\n            this.get !== StructFieldValue.prototype.get ||\n            this.set !== StructFieldValue.prototype.set\n        );\n    }\n\n    protected value: TDefinition[\"TValue\"];\n\n    constructor(\n        definition: TDefinition,\n        options: Readonly<StructOptions>,\n        struct: StructValue,\n        value: TDefinition[\"TValue\"],\n    ) {\n        this.definition = definition;\n        this.options = options;\n        this.struct = struct;\n        this.value = value;\n    }\n\n    /**\n     * Gets size of this field. By default, it returns its `definition`'s size.\n     *\n     * When overridden in derived classes, can have custom logic to calculate the actual size.\n     */\n    getSize(): number {\n        return this.definition.getSize();\n    }\n\n    /**\n     * When implemented in derived classes, reads current field's value.\n     */\n    get(): TDefinition[\"TValue\"] {\n        return this.value as never;\n    }\n\n    /**\n     * When implemented in derived classes, updates current field's value.\n     */\n    set(value: TDefinition[\"TValue\"]): void {\n        this.value = value;\n    }\n\n    /**\n     * When implemented in derived classes, serializes this field into `dataView` at `offset`\n     */\n    abstract serialize(\n        dataView: DataView,\n        array: Uint8Array,\n        offset: number,\n    ): void;\n}\n","export const StructDefaultOptions = {\n    littleEndian: false,\n};\n//# sourceMappingURL=options.js.map","export interface StructOptions {\n    /**\n     * Whether all multi-byte fields in this struct are little-endian encoded.\n     *\n     * @default false\n     */\n    littleEndian: boolean;\n\n    // TODO: StructOptions: investigate whether this is necessary\n    // I can't think about any other options which need to be struct wide.\n    // Even endianness can be set on a per-field basis (because it's not meaningful\n    // for some field types like `Uint8Array`, and very rarely, a struct may contain\n    // mixed endianness).\n    // It's just more common and a little more convenient to have it here.\n}\n\nexport const StructDefaultOptions: Readonly<StructOptions> = {\n    littleEndian: false,\n};\n","// TODO: allow over reading (returning a `Uint8Array`, an `offset` and a `length`) to avoid copying\nexport class ExactReadableEndedError extends Error {\n    constructor() {\n        super(\"ExactReadable ended\");\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\n//# sourceMappingURL=stream.js.map","import type { ValueOrPromise } from \"../utils.js\";\n\n// TODO: allow over reading (returning a `Uint8Array`, an `offset` and a `length`) to avoid copying\n\nexport class ExactReadableEndedError extends Error {\n    constructor() {\n        super(\"ExactReadable ended\");\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\n\nexport interface ExactReadable {\n    readonly position: number;\n\n    /**\n     * Read data from the underlying data source.\n     *\n     * The stream must return exactly `length` bytes or data. If that's not possible\n     * (due to end of file or other error condition), it must throw an {@link ExactReadableEndedError}.\n     */\n    readExactly(length: number): Uint8Array;\n}\n\nexport interface AsyncExactReadable {\n    readonly position: number;\n\n    /**\n     * Read data from the underlying data source.\n     *\n     * The stream must return exactly `length` bytes or data. If that's not possible\n     * (due to end of file or other error condition), it must throw an {@link ExactReadableEndedError}.\n     */\n    readExactly(length: number): ValueOrPromise<Uint8Array>;\n}\n","export const STRUCT_VALUE_SYMBOL = Symbol(\"struct-value\");\nexport function isStructValueInit(value) {\n    return (typeof value === \"object\" &&\n        value !== null &&\n        STRUCT_VALUE_SYMBOL in value);\n}\n/**\n * A struct value is a map between keys in a struct and their field values.\n */\nexport class StructValue {\n    /** @internal */ fieldValues = {};\n    /**\n     * Gets the result struct value object\n     */\n    value;\n    constructor(prototype) {\n        // PERF: `Object.create(extra)` is 50% faster\n        // than `Object.defineProperties(this.value, extra)`\n        this.value = Object.create(prototype);\n        // PERF: `Object.defineProperty` is slow\n        // but we need it to be non-enumerable\n        Object.defineProperty(this.value, STRUCT_VALUE_SYMBOL, {\n            enumerable: false,\n            value: this,\n        });\n    }\n    /**\n     * Sets a `StructFieldValue` for `key`\n     *\n     * @param name The field name\n     * @param fieldValue The associated `StructFieldValue`\n     */\n    set(name, fieldValue) {\n        this.fieldValues[name] = fieldValue;\n        // PERF: `Object.defineProperty` is slow\n        // use normal property when possible\n        if (fieldValue.hasCustomAccessors) {\n            Object.defineProperty(this.value, name, {\n                configurable: true,\n                enumerable: true,\n                get() {\n                    return fieldValue.get();\n                },\n                set(v) {\n                    fieldValue.set(v);\n                },\n            });\n        }\n        else {\n            this.value[name] = fieldValue.get();\n        }\n    }\n    /**\n     * Gets the `StructFieldValue` for `key`\n     *\n     * @param name The field name\n     */\n    get(name) {\n        return this.fieldValues[name];\n    }\n}\n//# sourceMappingURL=struct-value.js.map","import type { StructFieldDefinition } from \"./definition.js\";\nimport type { StructFieldValue } from \"./field-value.js\";\n\nexport const STRUCT_VALUE_SYMBOL = Symbol(\"struct-value\");\n\nexport function isStructValueInit(\n    value: unknown,\n): value is { [STRUCT_VALUE_SYMBOL]: StructValue } {\n    return (\n        typeof value === \"object\" &&\n        value !== null &&\n        STRUCT_VALUE_SYMBOL in value\n    );\n}\n\n/**\n * A struct value is a map between keys in a struct and their field values.\n */\nexport class StructValue {\n    /** @internal */ readonly fieldValues: Record<\n        PropertyKey,\n        StructFieldValue<StructFieldDefinition<unknown, unknown, PropertyKey>>\n    > = {};\n\n    /**\n     * Gets the result struct value object\n     */\n    readonly value: Record<PropertyKey, unknown>;\n\n    constructor(prototype: object) {\n        // PERF: `Object.create(extra)` is 50% faster\n        // than `Object.defineProperties(this.value, extra)`\n        this.value = Object.create(prototype) as Record<PropertyKey, unknown>;\n\n        // PERF: `Object.defineProperty` is slow\n        // but we need it to be non-enumerable\n        Object.defineProperty(this.value, STRUCT_VALUE_SYMBOL, {\n            enumerable: false,\n            value: this,\n        });\n    }\n\n    /**\n     * Sets a `StructFieldValue` for `key`\n     *\n     * @param name The field name\n     * @param fieldValue The associated `StructFieldValue`\n     */\n    set(\n        name: PropertyKey,\n        fieldValue: StructFieldValue<\n            StructFieldDefinition<unknown, unknown, PropertyKey>\n        >,\n    ): void {\n        this.fieldValues[name] = fieldValue;\n\n        // PERF: `Object.defineProperty` is slow\n        // use normal property when possible\n        if (fieldValue.hasCustomAccessors) {\n            Object.defineProperty(this.value, name, {\n                configurable: true,\n                enumerable: true,\n                get() {\n                    return fieldValue.get();\n                },\n                set(v) {\n                    fieldValue.set(v);\n                },\n            });\n        } else {\n            this.value[name] = fieldValue.get();\n        }\n    }\n\n    /**\n     * Gets the `StructFieldValue` for `key`\n     *\n     * @param name The field name\n     */\n    get(\n        name: PropertyKey,\n    ): StructFieldValue<StructFieldDefinition<unknown, unknown, PropertyKey>> {\n        return this.fieldValues[name]!;\n    }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { ExactReadableEndedError, STRUCT_VALUE_SYMBOL, StructDefaultOptions, StructValue, isStructValueInit, } from \"./basic/index.js\";\nimport { SyncPromise } from \"./sync-promise.js\";\nimport { BigIntFieldDefinition, BigIntFieldVariant, FixedLengthBufferLikeFieldDefinition, NumberFieldDefinition, NumberFieldVariant, StringBufferFieldConverter, Uint8ArrayBufferFieldConverter, VariableLengthBufferLikeFieldDefinition, } from \"./types/index.js\";\nexport class StructDeserializeError extends Error {\n    constructor(message) {\n        super(message);\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\nexport class StructNotEnoughDataError extends StructDeserializeError {\n    constructor() {\n        super(\"The underlying readable was ended before the struct was fully deserialized\");\n    }\n}\nexport class StructEmptyError extends StructDeserializeError {\n    constructor() {\n        super(\"The underlying readable doesn't contain any more struct\");\n    }\n}\nexport class Struct {\n    TFields;\n    TOmitInitKey;\n    TExtra;\n    TInit;\n    TDeserializeResult;\n    options;\n    #size = 0;\n    /**\n     * Gets the static size (exclude fields that can change size at runtime)\n     */\n    get size() {\n        return this.#size;\n    }\n    #fields = [];\n    get fields() {\n        return this.#fields;\n    }\n    #extra = {};\n    #postDeserialized;\n    constructor(options) {\n        this.options = { ...StructDefaultOptions, ...options };\n    }\n    /**\n     * Appends a `StructFieldDefinition` to the `Struct\n     */\n    field(name, definition) {\n        for (const field of this.#fields) {\n            if (field[0] === name) {\n                // Convert Symbol to string\n                const nameString = String(name);\n                throw new Error(`This struct already have a field with name '${nameString}'`);\n            }\n        }\n        this.#fields.push([name, definition]);\n        const size = definition.getSize();\n        this.#size += size;\n        // Force cast `this` to another type\n        return this;\n    }\n    /**\n     * Merges (flats) another `Struct`'s fields and extra fields into this one.\n     *\n     * `other`'s `postDeserialize` will be ignored.\n     */\n    concat(other) {\n        if (!(other instanceof Struct)) {\n            throw new TypeError(\"The other value must be a `Struct` instance\");\n        }\n        for (const field of other.#fields) {\n            this.#fields.push(field);\n        }\n        this.#size += other.#size;\n        Object.defineProperties(this.#extra, Object.getOwnPropertyDescriptors(other.#extra));\n        return this;\n    }\n    #number(name, type, typeScriptType) {\n        return this.field(name, new NumberFieldDefinition(type, typeScriptType));\n    }\n    /**\n     * Appends an `int8` field to the `Struct`\n     */\n    int8(name, typeScriptType) {\n        return this.#number(name, NumberFieldVariant.Int8, typeScriptType);\n    }\n    /**\n     * Appends an `uint8` field to the `Struct`\n     */\n    uint8(name, typeScriptType) {\n        return this.#number(name, NumberFieldVariant.Uint8, typeScriptType);\n    }\n    /**\n     * Appends an `int16` field to the `Struct`\n     */\n    int16(name, typeScriptType) {\n        return this.#number(name, NumberFieldVariant.Int16, typeScriptType);\n    }\n    /**\n     * Appends an `uint16` field to the `Struct`\n     */\n    uint16(name, typeScriptType) {\n        return this.#number(name, NumberFieldVariant.Uint16, typeScriptType);\n    }\n    /**\n     * Appends an `int32` field to the `Struct`\n     */\n    int32(name, typeScriptType) {\n        return this.#number(name, NumberFieldVariant.Int32, typeScriptType);\n    }\n    /**\n     * Appends an `uint32` field to the `Struct`\n     */\n    uint32(name, typeScriptType) {\n        return this.#number(name, NumberFieldVariant.Uint32, typeScriptType);\n    }\n    #bigint(name, type, typeScriptType) {\n        return this.field(name, new BigIntFieldDefinition(type, typeScriptType));\n    }\n    /**\n     * Appends an `int64` field to the `Struct`\n     *\n     * Requires native `BigInt` support\n     */\n    int64(name, typeScriptType) {\n        return this.#bigint(name, BigIntFieldVariant.Int64, typeScriptType);\n    }\n    /**\n     * Appends an `uint64` field to the `Struct`\n     *\n     * Requires native `BigInt` support\n     */\n    uint64(name, typeScriptType) {\n        return this.#bigint(name, BigIntFieldVariant.Uint64, typeScriptType);\n    }\n    #arrayBufferLike = (name, type, options) => {\n        if (\"length\" in options) {\n            return this.field(name, new FixedLengthBufferLikeFieldDefinition(type, options));\n        }\n        else {\n            return this.field(name, new VariableLengthBufferLikeFieldDefinition(type, options));\n        }\n    };\n    uint8Array = (name, options, typeScriptType) => {\n        return this.#arrayBufferLike(name, Uint8ArrayBufferFieldConverter.Instance, options, typeScriptType);\n    };\n    string = (name, options, typeScriptType) => {\n        return this.#arrayBufferLike(name, StringBufferFieldConverter.Instance, options, typeScriptType);\n    };\n    /**\n     * Adds some extra properties into every `Struct` value.\n     *\n     * Extra properties will not affect serialize or deserialize process.\n     *\n     * Multiple calls to `extra` will merge all properties together.\n     *\n     * @param value\n     * An object containing properties to be added to the result value. Accessors and methods are also allowed.\n     */\n    extra(value) {\n        Object.defineProperties(this.#extra, Object.getOwnPropertyDescriptors(value));\n        return this;\n    }\n    postDeserialize(callback) {\n        this.#postDeserialized = callback;\n        return this;\n    }\n    deserialize(stream) {\n        const structValue = new StructValue(this.#extra);\n        let promise = SyncPromise.resolve();\n        const startPosition = stream.position;\n        for (const [name, definition] of this.#fields) {\n            promise = promise\n                .then(() => definition.deserialize(this.options, stream, structValue))\n                .then((fieldValue) => {\n                structValue.set(name, fieldValue);\n            }, (e) => {\n                if (!(e instanceof ExactReadableEndedError)) {\n                    throw e;\n                }\n                if (stream.position === startPosition) {\n                    throw new StructEmptyError();\n                }\n                else {\n                    throw new StructNotEnoughDataError();\n                }\n            });\n        }\n        return promise\n            .then(() => {\n            const value = structValue.value;\n            // Run `postDeserialized`\n            if (this.#postDeserialized) {\n                const override = this.#postDeserialized.call(value, value);\n                // If it returns a new value, use that as result\n                // Otherwise it only inspects/mutates the object in place.\n                if (override !== undefined) {\n                    return override;\n                }\n            }\n            return value;\n        })\n            .valueOrPromise();\n    }\n    /**\n     * Serialize a struct value to a buffer.\n     * @param init Fields of the struct\n     * @param output The buffer to serialize the struct to. It must be large enough to hold the entire struct. If not provided, a new buffer will be created.\n     * @returns A view of `output` that contains the serialized struct, or a new buffer if `output` is not provided.\n     */\n    serialize(init, output) {\n        let structValue;\n        if (isStructValueInit(init)) {\n            structValue = init[STRUCT_VALUE_SYMBOL];\n            for (const [key, value] of Object.entries(init)) {\n                const fieldValue = structValue.get(key);\n                if (fieldValue) {\n                    fieldValue.set(value);\n                }\n            }\n        }\n        else {\n            structValue = new StructValue({});\n            for (const [name, definition] of this.#fields) {\n                const fieldValue = definition.create(this.options, structValue, init[name]);\n                structValue.set(name, fieldValue);\n            }\n        }\n        let structSize = 0;\n        const fieldsInfo = [];\n        for (const [name] of this.#fields) {\n            const fieldValue = structValue.get(name);\n            const size = fieldValue.getSize();\n            fieldsInfo.push({ fieldValue, size });\n            structSize += size;\n        }\n        if (!output) {\n            output = new Uint8Array(structSize);\n        }\n        else if (output.length < structSize) {\n            throw new TypeError(\"Output buffer is too small\");\n        }\n        const dataView = new DataView(output.buffer, output.byteOffset, output.byteLength);\n        let offset = 0;\n        for (const { fieldValue, size } of fieldsInfo) {\n            fieldValue.serialize(dataView, output, offset);\n            offset += size;\n        }\n        if (output.length !== structSize) {\n            return output.subarray(0, structSize);\n        }\n        else {\n            return output;\n        }\n    }\n}\n//# sourceMappingURL=struct.js.map","/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport type {\n    AsyncExactReadable,\n    ExactReadable,\n    StructFieldDefinition,\n    StructFieldValue,\n    StructOptions,\n} from \"./basic/index.js\";\nimport {\n    ExactReadableEndedError,\n    STRUCT_VALUE_SYMBOL,\n    StructDefaultOptions,\n    StructValue,\n    isStructValueInit,\n} from \"./basic/index.js\";\nimport { SyncPromise } from \"./sync-promise.js\";\nimport type {\n    BufferFieldConverter,\n    FixedLengthBufferLikeFieldOptions,\n    LengthField,\n    VariableLengthBufferLikeFieldOptions,\n} from \"./types/index.js\";\nimport {\n    BigIntFieldDefinition,\n    BigIntFieldVariant,\n    FixedLengthBufferLikeFieldDefinition,\n    NumberFieldDefinition,\n    NumberFieldVariant,\n    StringBufferFieldConverter,\n    Uint8ArrayBufferFieldConverter,\n    VariableLengthBufferLikeFieldDefinition,\n} from \"./types/index.js\";\nimport type { Evaluate, Identity, Overwrite, ValueOrPromise } from \"./utils.js\";\n\nexport interface StructLike<TValue> {\n    deserialize(stream: ExactReadable | AsyncExactReadable): Promise<TValue>;\n}\n\n/**\n * Extract the value type of the specified `Struct`\n */\nexport type StructValueType<T extends StructLike<unknown>> = Awaited<\n    ReturnType<T[\"deserialize\"]>\n>;\n\n/**\n * Create a new `Struct` type with `TDefinition` appended\n */\ntype AddFieldDescriptor<\n    TFields extends object,\n    TOmitInitKey extends PropertyKey,\n    TExtra extends object,\n    TPostDeserialized,\n    TFieldName extends PropertyKey,\n    TDefinition extends StructFieldDefinition<unknown, unknown, PropertyKey>,\n> = Identity<\n    Struct<\n        // Merge two types\n        // Evaluate immediately to optimize editor hover tooltip\n        Evaluate<TFields & Record<TFieldName, TDefinition[\"TValue\"]>>,\n        // Merge two `TOmitInitKey`s\n        TOmitInitKey | TDefinition[\"TOmitInitKey\"],\n        TExtra,\n        TPostDeserialized\n    >\n>;\n\n/**\n * Overload methods to add an array buffer like field\n */\ninterface ArrayBufferLikeFieldCreator<\n    TFields extends object,\n    TOmitInitKey extends PropertyKey,\n    TExtra extends object,\n    TPostDeserialized,\n> {\n    /**\n     * Append a fixed-length array buffer like field to the `Struct`\n     *\n     * @param name Name of the field\n     * @param type `Array.SubType.ArrayBuffer` or `Array.SubType.String`\n     * @param options Fixed-length array options\n     * @param typeScriptType Type of the field in TypeScript.\n     * For example, if this field is a string, you can declare it as a string enum or literal union.\n     */\n    <\n        TName extends PropertyKey,\n        TType extends BufferFieldConverter<unknown, unknown>,\n        TTypeScriptType = TType[\"TTypeScriptType\"],\n    >(\n        name: TName,\n        type: TType,\n        options: FixedLengthBufferLikeFieldOptions,\n        typeScriptType?: TTypeScriptType,\n    ): AddFieldDescriptor<\n        TFields,\n        TOmitInitKey,\n        TExtra,\n        TPostDeserialized,\n        TName,\n        FixedLengthBufferLikeFieldDefinition<\n            TType,\n            FixedLengthBufferLikeFieldOptions\n        >\n    >;\n\n    /**\n     * Append a variable-length array buffer like field to the `Struct`\n     */\n    <\n        TName extends PropertyKey,\n        TType extends BufferFieldConverter<unknown, unknown>,\n        TOptions extends VariableLengthBufferLikeFieldOptions<TFields>,\n        TTypeScriptType = TType[\"TTypeScriptType\"],\n    >(\n        name: TName,\n        type: TType,\n        options: TOptions,\n        typeScriptType?: TTypeScriptType,\n    ): AddFieldDescriptor<\n        TFields,\n        TOmitInitKey,\n        TExtra,\n        TPostDeserialized,\n        TName,\n        VariableLengthBufferLikeFieldDefinition<TType, TOptions>\n    >;\n}\n\n/**\n * Similar to `ArrayBufferLikeFieldCreator`, but bind to `TType`\n */\ninterface BoundArrayBufferLikeFieldDefinitionCreator<\n    TFields extends object,\n    TOmitInitKey extends PropertyKey,\n    TExtra extends object,\n    TPostDeserialized,\n    TType extends BufferFieldConverter<unknown, unknown>,\n> {\n    <TName extends PropertyKey, TTypeScriptType = TType[\"TTypeScriptType\"]>(\n        name: TName,\n        options: FixedLengthBufferLikeFieldOptions,\n        typeScriptType?: TTypeScriptType,\n    ): AddFieldDescriptor<\n        TFields,\n        TOmitInitKey,\n        TExtra,\n        TPostDeserialized,\n        TName,\n        FixedLengthBufferLikeFieldDefinition<\n            TType,\n            FixedLengthBufferLikeFieldOptions,\n            TTypeScriptType\n        >\n    >;\n\n    <\n        TName extends PropertyKey,\n        TOptions extends VariableLengthBufferLikeFieldOptions<\n            TFields,\n            LengthField<TFields>\n        >,\n        TTypeScriptType = TType[\"TTypeScriptType\"],\n    >(\n        name: TName,\n        options: TOptions,\n        typeScriptType?: TTypeScriptType,\n    ): AddFieldDescriptor<\n        TFields,\n        TOmitInitKey,\n        TExtra,\n        TPostDeserialized,\n        TName,\n        VariableLengthBufferLikeFieldDefinition<\n            TType,\n            TOptions,\n            TTypeScriptType\n        >\n    >;\n}\n\nexport type StructPostDeserialized<TFields, TPostDeserialized> = (\n    this: TFields,\n    object: TFields,\n) => TPostDeserialized;\n\nexport type StructDeserializedResult<\n    TFields extends object,\n    TExtra extends object,\n    TPostDeserialized,\n> = TPostDeserialized extends undefined\n    ? Overwrite<TExtra, TFields>\n    : TPostDeserialized;\n\nexport class StructDeserializeError extends Error {\n    constructor(message: string) {\n        super(message);\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\n\nexport class StructNotEnoughDataError extends StructDeserializeError {\n    constructor() {\n        super(\n            \"The underlying readable was ended before the struct was fully deserialized\",\n        );\n    }\n}\n\nexport class StructEmptyError extends StructDeserializeError {\n    constructor() {\n        super(\"The underlying readable doesn't contain any more struct\");\n    }\n}\n\ninterface StructDefinition<\n    TFields extends object,\n    TOmitInitKey extends PropertyKey,\n    TExtra extends object,\n> {\n    readonly TFields: TFields;\n\n    readonly TOmitInitKey: TOmitInitKey;\n\n    readonly TExtra: TExtra;\n\n    readonly TInit: Evaluate<Omit<TFields, TOmitInitKey>>;\n}\n\nexport class Struct<\n    TFields extends object = Record<never, never>,\n    TOmitInitKey extends PropertyKey = never,\n    TExtra extends object = Record<never, never>,\n    TPostDeserialized = undefined,\n> implements\n        StructLike<\n            StructDeserializedResult<TFields, TExtra, TPostDeserialized>\n        >\n{\n    readonly TFields!: TFields;\n\n    readonly TOmitInitKey!: TOmitInitKey;\n\n    readonly TExtra!: TExtra;\n\n    readonly TInit!: Evaluate<Omit<TFields, TOmitInitKey>>;\n\n    readonly TDeserializeResult!: StructDeserializedResult<\n        TFields,\n        TExtra,\n        TPostDeserialized\n    >;\n\n    readonly options: Readonly<StructOptions>;\n\n    #size = 0;\n    /**\n     * Gets the static size (exclude fields that can change size at runtime)\n     */\n    get size() {\n        return this.#size;\n    }\n\n    #fields: [\n        name: PropertyKey,\n        definition: StructFieldDefinition<unknown, unknown, PropertyKey>,\n    ][] = [];\n    get fields(): readonly [\n        name: PropertyKey,\n        definition: StructFieldDefinition<unknown, unknown, PropertyKey>,\n    ][] {\n        return this.#fields;\n    }\n\n    #extra: Record<PropertyKey, unknown> = {};\n\n    #postDeserialized?: StructPostDeserialized<never, unknown> | undefined;\n\n    constructor(options?: Partial<Readonly<StructOptions>>) {\n        this.options = { ...StructDefaultOptions, ...options };\n    }\n\n    /**\n     * Appends a `StructFieldDefinition` to the `Struct\n     */\n    field<\n        TName extends PropertyKey,\n        TDefinition extends StructFieldDefinition<\n            unknown,\n            unknown,\n            PropertyKey\n        >,\n    >(\n        name: TName,\n        definition: TDefinition,\n    ): AddFieldDescriptor<\n        TFields,\n        TOmitInitKey,\n        TExtra,\n        TPostDeserialized,\n        TName,\n        TDefinition\n    > {\n        for (const field of this.#fields) {\n            if (field[0] === name) {\n                // Convert Symbol to string\n                const nameString = String(name);\n                throw new Error(\n                    `This struct already have a field with name '${nameString}'`,\n                );\n            }\n        }\n\n        this.#fields.push([name, definition]);\n\n        const size = definition.getSize();\n        this.#size += size;\n\n        // Force cast `this` to another type\n        return this as never;\n    }\n\n    /**\n     * Merges (flats) another `Struct`'s fields and extra fields into this one.\n     *\n     * `other`'s `postDeserialize` will be ignored.\n     */\n    concat<TOther extends StructDefinition<object, PropertyKey, object>>(\n        other: TOther,\n    ): Struct<\n        TFields & TOther[\"TFields\"],\n        TOmitInitKey | TOther[\"TOmitInitKey\"],\n        TExtra & TOther[\"TExtra\"],\n        TPostDeserialized\n    > {\n        if (!(other instanceof Struct)) {\n            throw new TypeError(\"The other value must be a `Struct` instance\");\n        }\n\n        for (const field of other.#fields) {\n            this.#fields.push(field);\n        }\n        this.#size += other.#size;\n        Object.defineProperties(\n            this.#extra,\n            Object.getOwnPropertyDescriptors(other.#extra),\n        );\n        return this as never;\n    }\n\n    #number<\n        TName extends PropertyKey,\n        TType extends NumberFieldVariant = NumberFieldVariant,\n        TTypeScriptType = number,\n    >(name: TName, type: TType, typeScriptType?: TTypeScriptType) {\n        return this.field(\n            name,\n            new NumberFieldDefinition(type, typeScriptType),\n        );\n    }\n\n    /**\n     * Appends an `int8` field to the `Struct`\n     */\n    int8<TName extends PropertyKey, TTypeScriptType = number>(\n        name: TName,\n        typeScriptType?: TTypeScriptType,\n    ) {\n        return this.#number(name, NumberFieldVariant.Int8, typeScriptType);\n    }\n\n    /**\n     * Appends an `uint8` field to the `Struct`\n     */\n    uint8<TName extends PropertyKey, TTypeScriptType = number>(\n        name: TName,\n        typeScriptType?: TTypeScriptType,\n    ) {\n        return this.#number(name, NumberFieldVariant.Uint8, typeScriptType);\n    }\n\n    /**\n     * Appends an `int16` field to the `Struct`\n     */\n    int16<TName extends PropertyKey, TTypeScriptType = number>(\n        name: TName,\n        typeScriptType?: TTypeScriptType,\n    ) {\n        return this.#number(name, NumberFieldVariant.Int16, typeScriptType);\n    }\n\n    /**\n     * Appends an `uint16` field to the `Struct`\n     */\n    uint16<TName extends PropertyKey, TTypeScriptType = number>(\n        name: TName,\n        typeScriptType?: TTypeScriptType,\n    ) {\n        return this.#number(name, NumberFieldVariant.Uint16, typeScriptType);\n    }\n\n    /**\n     * Appends an `int32` field to the `Struct`\n     */\n    int32<TName extends PropertyKey, TTypeScriptType = number>(\n        name: TName,\n        typeScriptType?: TTypeScriptType,\n    ) {\n        return this.#number(name, NumberFieldVariant.Int32, typeScriptType);\n    }\n\n    /**\n     * Appends an `uint32` field to the `Struct`\n     */\n    uint32<TName extends PropertyKey, TTypeScriptType = number>(\n        name: TName,\n        typeScriptType?: TTypeScriptType,\n    ) {\n        return this.#number(name, NumberFieldVariant.Uint32, typeScriptType);\n    }\n\n    #bigint<\n        TName extends PropertyKey,\n        TType extends BigIntFieldVariant = BigIntFieldVariant,\n        TTypeScriptType = TType[\"TTypeScriptType\"],\n    >(name: TName, type: TType, typeScriptType?: TTypeScriptType) {\n        return this.field(\n            name,\n            new BigIntFieldDefinition(type, typeScriptType),\n        );\n    }\n\n    /**\n     * Appends an `int64` field to the `Struct`\n     *\n     * Requires native `BigInt` support\n     */\n    int64<\n        TName extends PropertyKey,\n        TTypeScriptType = BigIntFieldVariant[\"TTypeScriptType\"],\n    >(name: TName, typeScriptType?: TTypeScriptType) {\n        return this.#bigint(name, BigIntFieldVariant.Int64, typeScriptType);\n    }\n\n    /**\n     * Appends an `uint64` field to the `Struct`\n     *\n     * Requires native `BigInt` support\n     */\n    uint64<\n        TName extends PropertyKey,\n        TTypeScriptType = BigIntFieldVariant[\"TTypeScriptType\"],\n    >(name: TName, typeScriptType?: TTypeScriptType) {\n        return this.#bigint(name, BigIntFieldVariant.Uint64, typeScriptType);\n    }\n\n    #arrayBufferLike: ArrayBufferLikeFieldCreator<\n        TFields,\n        TOmitInitKey,\n        TExtra,\n        TPostDeserialized\n    > = (\n        name: PropertyKey,\n        type: BufferFieldConverter,\n        options:\n            | FixedLengthBufferLikeFieldOptions\n            | VariableLengthBufferLikeFieldOptions,\n    ): never => {\n        if (\"length\" in options) {\n            return this.field(\n                name,\n                new FixedLengthBufferLikeFieldDefinition(type, options),\n            ) as never;\n        } else {\n            return this.field(\n                name,\n                new VariableLengthBufferLikeFieldDefinition(type, options),\n            ) as never;\n        }\n    };\n\n    uint8Array: BoundArrayBufferLikeFieldDefinitionCreator<\n        TFields,\n        TOmitInitKey,\n        TExtra,\n        TPostDeserialized,\n        Uint8ArrayBufferFieldConverter\n    > = (\n        name: PropertyKey,\n        options: unknown,\n        typeScriptType: unknown,\n    ): never => {\n        return this.#arrayBufferLike(\n            name,\n            Uint8ArrayBufferFieldConverter.Instance,\n            options as never,\n            typeScriptType,\n        ) as never;\n    };\n\n    string: BoundArrayBufferLikeFieldDefinitionCreator<\n        TFields,\n        TOmitInitKey,\n        TExtra,\n        TPostDeserialized,\n        StringBufferFieldConverter\n    > = (\n        name: PropertyKey,\n        options: unknown,\n        typeScriptType: unknown,\n    ): never => {\n        return this.#arrayBufferLike(\n            name,\n            StringBufferFieldConverter.Instance,\n            options as never,\n            typeScriptType,\n        ) as never;\n    };\n\n    /**\n     * Adds some extra properties into every `Struct` value.\n     *\n     * Extra properties will not affect serialize or deserialize process.\n     *\n     * Multiple calls to `extra` will merge all properties together.\n     *\n     * @param value\n     * An object containing properties to be added to the result value. Accessors and methods are also allowed.\n     */\n    extra<\n        T extends Record<\n            // This trick disallows any keys that are already in `TValue`\n            Exclude<keyof T, Exclude<keyof T, keyof TFields>>,\n            never\n        >,\n    >(\n        value: T & ThisType<Overwrite<Overwrite<TExtra, T>, TFields>>,\n    ): Struct<TFields, TOmitInitKey, Overwrite<TExtra, T>, TPostDeserialized> {\n        Object.defineProperties(\n            this.#extra,\n            Object.getOwnPropertyDescriptors(value),\n        );\n        return this as never;\n    }\n\n    /**\n     * Registers (or replaces) a custom callback to be run after deserialized.\n     *\n     * A callback returning `never` (always throw an error)\n     * will also change the return type of `deserialize` to `never`.\n     */\n    postDeserialize(\n        callback: StructPostDeserialized<TFields, never>,\n    ): Struct<TFields, TOmitInitKey, TExtra, never>;\n    /**\n     * Registers (or replaces) a custom callback to be run after deserialized.\n     *\n     * A callback returning `void` means it modify the result object in-place\n     * (or doesn't modify it at all), so `deserialize` will still return the result object.\n     */\n    postDeserialize(\n        callback?: StructPostDeserialized<TFields, void>,\n    ): Struct<TFields, TOmitInitKey, TExtra, undefined>;\n    /**\n     * Registers (or replaces) a custom callback to be run after deserialized.\n     *\n     * A callback returning anything other than `undefined`\n     * will `deserialize` to return that object instead.\n     */\n    postDeserialize<TPostSerialize>(\n        callback?: StructPostDeserialized<TFields, TPostSerialize>,\n    ): Struct<TFields, TOmitInitKey, TExtra, TPostSerialize>;\n    postDeserialize(callback?: StructPostDeserialized<TFields, unknown>) {\n        this.#postDeserialized = callback;\n        return this as never;\n    }\n\n    /**\n     * Deserialize a struct value from `stream`.\n     */\n    deserialize(\n        stream: ExactReadable,\n    ): StructDeserializedResult<TFields, TExtra, TPostDeserialized>;\n    deserialize(\n        stream: AsyncExactReadable,\n    ): Promise<StructDeserializedResult<TFields, TExtra, TPostDeserialized>>;\n    deserialize(\n        stream: ExactReadable | AsyncExactReadable,\n    ): ValueOrPromise<\n        StructDeserializedResult<TFields, TExtra, TPostDeserialized>\n    > {\n        const structValue = new StructValue(this.#extra);\n\n        let promise = SyncPromise.resolve();\n\n        const startPosition = stream.position;\n        for (const [name, definition] of this.#fields) {\n            promise = promise\n                .then(() =>\n                    definition.deserialize(this.options, stream, structValue),\n                )\n                .then(\n                    (fieldValue) => {\n                        structValue.set(name, fieldValue);\n                    },\n                    (e) => {\n                        if (!(e instanceof ExactReadableEndedError)) {\n                            throw e;\n                        }\n\n                        if (stream.position === startPosition) {\n                            throw new StructEmptyError();\n                        } else {\n                            throw new StructNotEnoughDataError();\n                        }\n                    },\n                );\n        }\n\n        return promise\n            .then(() => {\n                const value = structValue.value;\n\n                // Run `postDeserialized`\n                if (this.#postDeserialized) {\n                    const override = this.#postDeserialized.call(\n                        value as never,\n                        value as never,\n                    );\n                    // If it returns a new value, use that as result\n                    // Otherwise it only inspects/mutates the object in place.\n                    if (override !== undefined) {\n                        return override as never;\n                    }\n                }\n\n                return value as never;\n            })\n            .valueOrPromise();\n    }\n\n    /**\n     * Serialize a struct value to a buffer.\n     * @param init Fields of the struct\n     * @param output The buffer to serialize the struct to. It must be large enough to hold the entire struct. If not provided, a new buffer will be created.\n     * @returns A view of `output` that contains the serialized struct, or a new buffer if `output` is not provided.\n     */\n    serialize(\n        init: Evaluate<Omit<TFields, TOmitInitKey>>,\n        output?: Uint8Array,\n    ): Uint8Array {\n        let structValue: StructValue;\n        if (isStructValueInit(init)) {\n            structValue = init[STRUCT_VALUE_SYMBOL];\n            for (const [key, value] of Object.entries(init)) {\n                const fieldValue = structValue.get(key);\n                if (fieldValue) {\n                    fieldValue.set(value);\n                }\n            }\n        } else {\n            structValue = new StructValue({});\n            for (const [name, definition] of this.#fields) {\n                const fieldValue = definition.create(\n                    this.options,\n                    structValue,\n                    (init as Record<PropertyKey, unknown>)[name],\n                );\n                structValue.set(name, fieldValue);\n            }\n        }\n\n        let structSize = 0;\n        const fieldsInfo: {\n            fieldValue: StructFieldValue<any>;\n            size: number;\n        }[] = [];\n\n        for (const [name] of this.#fields) {\n            const fieldValue = structValue.get(name);\n            const size = fieldValue.getSize();\n            fieldsInfo.push({ fieldValue, size });\n            structSize += size;\n        }\n\n        if (!output) {\n            output = new Uint8Array(structSize);\n        } else if (output.length < structSize) {\n            throw new TypeError(\"Output buffer is too small\");\n        }\n\n        const dataView = new DataView(\n            output.buffer,\n            output.byteOffset,\n            output.byteLength,\n        );\n        let offset = 0;\n        for (const { fieldValue, size } of fieldsInfo) {\n            fieldValue.serialize(dataView, output, offset);\n            offset += size;\n        }\n\n        if (output.length !== structSize) {\n            return output.subarray(0, structSize);\n        } else {\n            return output;\n        }\n    }\n}\n","export const SyncPromise = {\n    reject(reason) {\n        return new RejectedSyncPromise(reason);\n    },\n    resolve(value) {\n        if (typeof value === \"object\" &&\n            value !== null &&\n            typeof value.then === \"function\") {\n            if (value instanceof PendingSyncPromise ||\n                value instanceof ResolvedSyncPromise ||\n                value instanceof RejectedSyncPromise) {\n                return value;\n            }\n            return new PendingSyncPromise(value);\n        }\n        else {\n            return new ResolvedSyncPromise(value);\n        }\n    },\n    try(executor) {\n        try {\n            return SyncPromise.resolve(executor());\n        }\n        catch (e) {\n            return SyncPromise.reject(e);\n        }\n    },\n};\nclass PendingSyncPromise {\n    #promise;\n    constructor(promise) {\n        this.#promise = promise;\n    }\n    then(onfulfilled, onrejected) {\n        return new PendingSyncPromise(this.#promise.then(onfulfilled, onrejected));\n    }\n    valueOrPromise() {\n        return this.#promise;\n    }\n}\nclass ResolvedSyncPromise {\n    #value;\n    constructor(value) {\n        this.#value = value;\n    }\n    then(onfulfilled) {\n        if (!onfulfilled) {\n            return this;\n        }\n        return SyncPromise.try(() => onfulfilled(this.#value));\n    }\n    valueOrPromise() {\n        return this.#value;\n    }\n}\nclass RejectedSyncPromise {\n    #reason;\n    constructor(reason) {\n        this.#reason = reason;\n    }\n    then(onfulfilled, onrejected) {\n        if (!onrejected) {\n            return this;\n        }\n        return SyncPromise.try(() => onrejected(this.#reason));\n    }\n    valueOrPromise() {\n        throw this.#reason;\n    }\n}\n//# sourceMappingURL=sync-promise.js.map","export interface SyncPromise<T> {\n    then<TResult1 = T, TResult2 = never>(\n        onfulfilled?:\n            | ((value: T) => TResult1 | PromiseLike<TResult1>)\n            | null\n            | undefined,\n        onrejected?:\n            | ((reason: unknown) => TResult2 | PromiseLike<TResult2>)\n            | null\n            | undefined,\n    ): SyncPromise<TResult1 | TResult2>;\n\n    valueOrPromise(): T | PromiseLike<T>;\n}\n\ninterface SyncPromiseStatic {\n    reject<T = never>(reason?: unknown): SyncPromise<T>;\n\n    resolve(): SyncPromise<void>;\n    resolve<T>(value: T | PromiseLike<T>): SyncPromise<T>;\n\n    try<T>(executor: () => T | PromiseLike<T>): SyncPromise<T>;\n}\n\nexport const SyncPromise: SyncPromiseStatic = {\n    reject<T = never>(reason?: unknown): SyncPromise<T> {\n        return new RejectedSyncPromise(reason);\n    },\n    resolve<T>(value?: T | PromiseLike<T>): SyncPromise<T> {\n        if (\n            typeof value === \"object\" &&\n            value !== null &&\n            typeof (value as PromiseLike<T>).then === \"function\"\n        ) {\n            if (\n                value instanceof PendingSyncPromise ||\n                value instanceof ResolvedSyncPromise ||\n                value instanceof RejectedSyncPromise\n            ) {\n                return value;\n            }\n\n            return new PendingSyncPromise(value as PromiseLike<T>);\n        } else {\n            return new ResolvedSyncPromise(value as T);\n        }\n    },\n    try<T>(executor: () => T | PromiseLike<T>): SyncPromise<T> {\n        try {\n            return SyncPromise.resolve(executor());\n        } catch (e) {\n            return SyncPromise.reject(e);\n        }\n    },\n};\n\nclass PendingSyncPromise<T> implements SyncPromise<T> {\n    #promise: PromiseLike<T>;\n\n    constructor(promise: PromiseLike<T>) {\n        this.#promise = promise;\n    }\n\n    then<TResult1 = T, TResult2 = never>(\n        onfulfilled?:\n            | ((value: T) => TResult1 | PromiseLike<TResult1>)\n            | null\n            | undefined,\n        onrejected?:\n            | ((reason: unknown) => TResult2 | PromiseLike<TResult2>)\n            | null\n            | undefined,\n    ) {\n        return new PendingSyncPromise<TResult1 | TResult2>(\n            this.#promise.then(onfulfilled, onrejected),\n        );\n    }\n\n    valueOrPromise(): T | PromiseLike<T> {\n        return this.#promise;\n    }\n}\n\nclass ResolvedSyncPromise<T> implements SyncPromise<T> {\n    #value: T;\n\n    constructor(value: T) {\n        this.#value = value;\n    }\n\n    then<TResult1 = T>(\n        onfulfilled?:\n            | ((value: T) => TResult1 | PromiseLike<TResult1>)\n            | null\n            | undefined,\n    ) {\n        if (!onfulfilled) {\n            return this as never;\n        }\n        return SyncPromise.try(() => onfulfilled(this.#value));\n    }\n\n    valueOrPromise(): T | PromiseLike<T> {\n        return this.#value;\n    }\n}\n\nclass RejectedSyncPromise<T> implements SyncPromise<T> {\n    #reason: unknown;\n\n    constructor(reason: unknown) {\n        this.#reason = reason;\n    }\n\n    then<TResult1 = T, TResult2 = never>(\n        onfulfilled?:\n            | ((value: T) => TResult1 | PromiseLike<TResult1>)\n            | null\n            | undefined,\n        onrejected?:\n            | ((reason: unknown) => TResult2 | PromiseLike<TResult2>)\n            | null\n            | undefined,\n    ) {\n        if (!onrejected) {\n            return this as never;\n        }\n        return SyncPromise.try(() => onrejected(this.#reason));\n    }\n\n    valueOrPromise(): T | PromiseLike<T> {\n        throw this.#reason;\n    }\n}\n","export * from \"./bigint.js\";\nexport * from \"./buffer/index.js\";\nexport * from \"./number.js\";\n","import { getInt64, getUint64, setInt64, setUint64, } from \"@yume-chan/no-data-view\";\nimport { StructFieldDefinition, StructFieldValue } from \"../basic/index.js\";\nimport { SyncPromise } from \"../sync-promise.js\";\nexport class BigIntFieldVariant {\n    TTypeScriptType;\n    size;\n    deserialize;\n    serialize;\n    constructor(size, deserialize, serialize) {\n        this.size = size;\n        this.deserialize = deserialize;\n        this.serialize = serialize;\n    }\n    static Int64 = new BigIntFieldVariant(8, getInt64, setInt64);\n    static Uint64 = new BigIntFieldVariant(8, getUint64, setUint64);\n}\nexport class BigIntFieldDefinition extends StructFieldDefinition {\n    variant;\n    constructor(variant, typescriptType) {\n        void typescriptType;\n        super();\n        this.variant = variant;\n    }\n    getSize() {\n        return this.variant.size;\n    }\n    create(options, struct, value) {\n        return new BigIntFieldValue(this, options, struct, value);\n    }\n    deserialize(options, stream, struct) {\n        return SyncPromise.try(() => {\n            return stream.readExactly(this.getSize());\n        })\n            .then((array) => {\n            const value = this.variant.deserialize(array, 0, options.littleEndian);\n            return this.create(options, struct, value);\n        })\n            .valueOrPromise();\n    }\n}\nexport class BigIntFieldValue extends StructFieldValue {\n    serialize(dataView, array, offset) {\n        this.definition.variant.serialize(array, offset, this.value, this.options.littleEndian);\n    }\n}\n//# sourceMappingURL=bigint.js.map","import {\n    getInt64,\n    getUint64,\n    setInt64,\n    setUint64,\n} from \"@yume-chan/no-data-view\";\n\nimport type {\n    AsyncExactReadable,\n    ExactReadable,\n    StructOptions,\n    StructValue,\n} from \"../basic/index.js\";\nimport { StructFieldDefinition, StructFieldValue } from \"../basic/index.js\";\nimport { SyncPromise } from \"../sync-promise.js\";\nimport type { ValueOrPromise } from \"../utils.js\";\n\nexport type BigIntDeserializer = (\n    array: Uint8Array,\n    byteOffset: number,\n    littleEndian: boolean,\n) => bigint;\n\nexport type BigIntSerializer = (\n    array: Uint8Array,\n    byteOffset: number,\n    value: bigint,\n    littleEndian: boolean,\n) => void;\n\nexport class BigIntFieldVariant {\n    readonly TTypeScriptType!: bigint;\n\n    readonly size: number;\n\n    readonly deserialize: BigIntDeserializer;\n\n    readonly serialize: BigIntSerializer;\n\n    constructor(\n        size: number,\n        deserialize: BigIntDeserializer,\n        serialize: BigIntSerializer,\n    ) {\n        this.size = size;\n        this.deserialize = deserialize;\n        this.serialize = serialize;\n    }\n\n    static readonly Int64 = new BigIntFieldVariant(8, getInt64, setInt64);\n\n    static readonly Uint64 = new BigIntFieldVariant(8, getUint64, setUint64);\n}\n\nexport class BigIntFieldDefinition<\n    TVariant extends BigIntFieldVariant = BigIntFieldVariant,\n    TTypeScriptType = TVariant[\"TTypeScriptType\"],\n> extends StructFieldDefinition<void, TTypeScriptType> {\n    readonly variant: TVariant;\n\n    constructor(variant: TVariant, typescriptType?: TTypeScriptType) {\n        void typescriptType;\n        super();\n        this.variant = variant;\n    }\n\n    getSize(): number {\n        return this.variant.size;\n    }\n\n    create(\n        options: Readonly<StructOptions>,\n        struct: StructValue,\n        value: TTypeScriptType,\n    ): BigIntFieldValue<this> {\n        return new BigIntFieldValue(this, options, struct, value);\n    }\n\n    override deserialize(\n        options: Readonly<StructOptions>,\n        stream: ExactReadable,\n        struct: StructValue,\n    ): BigIntFieldValue<this>;\n    override deserialize(\n        options: Readonly<StructOptions>,\n        stream: AsyncExactReadable,\n        struct: StructValue,\n    ): Promise<BigIntFieldValue<this>>;\n    override deserialize(\n        options: Readonly<StructOptions>,\n        stream: ExactReadable | AsyncExactReadable,\n        struct: StructValue,\n    ): ValueOrPromise<BigIntFieldValue<this>> {\n        return SyncPromise.try(() => {\n            return stream.readExactly(this.getSize());\n        })\n            .then((array) => {\n                const value = this.variant.deserialize(\n                    array,\n                    0,\n                    options.littleEndian,\n                );\n                return this.create(options, struct, value as never);\n            })\n            .valueOrPromise();\n    }\n}\n\nexport class BigIntFieldValue<\n    TDefinition extends BigIntFieldDefinition<BigIntFieldVariant, unknown>,\n> extends StructFieldValue<TDefinition> {\n    override serialize(\n        dataView: DataView,\n        array: Uint8Array,\n        offset: number,\n    ): void {\n        this.definition.variant.serialize(\n            array,\n            offset,\n            this.value as never,\n            this.options.littleEndian,\n        );\n    }\n}\n","export * from \"./int16.js\";\r\nexport * from \"./int32.js\";\r\nexport * from \"./int64.js\";\r\nexport * from \"./int8.js\";\r\nexport * from \"./uint16.js\";\r\nexport * from \"./uint32.js\";\r\nexport * from \"./uint64.js\";\r\n","export function getInt16LittleEndian(buffer, offset) {\n    return ((buffer[offset] | (buffer[offset + 1] << 8)) << 16) >> 16;\n}\nexport function getInt16BigEndian(buffer, offset) {\n    return (((buffer[offset] << 8) | buffer[offset + 1]) << 16) >> 16;\n}\nexport function getInt16(buffer, offset, littleEndian) {\n    return littleEndian\n        ? ((buffer[offset] | (buffer[offset + 1] << 8)) << 16) >> 16\n        : (((buffer[offset] << 8) | buffer[offset + 1]) << 16) >> 16;\n}\nexport function setInt16LittleEndian(buffer, offset, value) {\n    buffer[offset] = value;\n    buffer[offset + 1] = value >> 8;\n}\nexport function setInt16BigEndian(buffer, offset, value) {\n    buffer[offset] = value >> 8;\n    buffer[offset + 1] = value;\n}\nexport function setInt16(buffer, offset, value, littleEndian) {\n    if (littleEndian) {\n        buffer[offset] = value;\n        buffer[offset + 1] = value >> 8;\n    }\n    else {\n        buffer[offset] = value >> 8;\n        buffer[offset + 1] = value;\n    }\n}\n//# sourceMappingURL=int16.js.map","export function getInt16LittleEndian(\r\n    buffer: Uint8Array,\r\n    offset: number,\r\n): number {\r\n    return ((buffer[offset]! | (buffer[offset + 1]! << 8)) << 16) >> 16;\r\n}\r\n\r\nexport function getInt16BigEndian(buffer: Uint8Array, offset: number): number {\r\n    return (((buffer[offset]! << 8) | buffer[offset + 1]!) << 16) >> 16;\r\n}\r\n\r\nexport function getInt16(\r\n    buffer: Uint8Array,\r\n    offset: number,\r\n    littleEndian: boolean,\r\n) {\r\n    return littleEndian\r\n        ? ((buffer[offset]! | (buffer[offset + 1]! << 8)) << 16) >> 16\r\n        : (((buffer[offset]! << 8) | buffer[offset + 1]!) << 16) >> 16;\r\n}\r\n\r\nexport function setInt16LittleEndian(\r\n    buffer: Uint8Array,\r\n    offset: number,\r\n    value: number,\r\n): void {\r\n    buffer[offset] = value;\r\n    buffer[offset + 1] = value >> 8;\r\n}\r\n\r\nexport function setInt16BigEndian(\r\n    buffer: Uint8Array,\r\n    offset: number,\r\n    value: number,\r\n): void {\r\n    buffer[offset] = value >> 8;\r\n    buffer[offset + 1] = value;\r\n}\r\n\r\nexport function setInt16(\r\n    buffer: Uint8Array,\r\n    offset: number,\r\n    value: number,\r\n    littleEndian: boolean,\r\n): void {\r\n    if (littleEndian) {\r\n        buffer[offset] = value;\r\n        buffer[offset + 1] = value >> 8;\r\n    } else {\r\n        buffer[offset] = value >> 8;\r\n        buffer[offset + 1] = value;\r\n    }\r\n}\r\n","export function getInt32LittleEndian(buffer, offset) {\n    return (buffer[offset] |\n        (buffer[offset + 1] << 8) |\n        (buffer[offset + 2] << 16) |\n        (buffer[offset + 3] << 24));\n}\nexport function getInt32BigEndian(buffer, offset) {\n    return ((buffer[offset] << 24) |\n        (buffer[offset + 1] << 16) |\n        (buffer[offset + 2] << 8) |\n        buffer[offset + 3]);\n}\nexport function getInt32(buffer, offset, littleEndian) {\n    return littleEndian\n        ? buffer[offset] |\n            (buffer[offset + 1] << 8) |\n            (buffer[offset + 2] << 16) |\n            (buffer[offset + 3] << 24)\n        : (buffer[offset] << 24) |\n            (buffer[offset + 1] << 16) |\n            (buffer[offset + 2] << 8) |\n            buffer[offset + 3];\n}\nexport function setInt32LittleEndian(buffer, offset, value) {\n    buffer[offset] = value;\n    buffer[offset + 1] = value >> 8;\n    buffer[offset + 2] = value >> 16;\n    buffer[offset + 3] = value >> 24;\n}\nexport function setInt32BigEndian(buffer, offset, value) {\n    buffer[offset] = value >> 24;\n    buffer[offset + 1] = value >> 16;\n    buffer[offset + 2] = value >> 8;\n    buffer[offset + 3] = value;\n}\nexport function setInt32(buffer, offset, value, littleEndian) {\n    if (littleEndian) {\n        buffer[offset] = value;\n        buffer[offset + 1] = value >> 8;\n        buffer[offset + 2] = value >> 16;\n        buffer[offset + 3] = value >> 24;\n    }\n    else {\n        buffer[offset] = value >> 24;\n        buffer[offset + 1] = value >> 16;\n        buffer[offset + 2] = value >> 8;\n        buffer[offset + 3] = value;\n    }\n}\n//# sourceMappingURL=int32.js.map","export function getInt32LittleEndian(\r\n    buffer: Uint8Array,\r\n    offset: number,\r\n): number {\r\n    return (\r\n        buffer[offset]! |\r\n        (buffer[offset + 1]! << 8) |\r\n        (buffer[offset + 2]! << 16) |\r\n        (buffer[offset + 3]! << 24)\r\n    );\r\n}\r\n\r\nexport function getInt32BigEndian(buffer: Uint8Array, offset: number): number {\r\n    return (\r\n        (buffer[offset]! << 24) |\r\n        (buffer[offset + 1]! << 16) |\r\n        (buffer[offset + 2]! << 8) |\r\n        buffer[offset + 3]!\r\n    );\r\n}\r\n\r\nexport function getInt32(\r\n    buffer: Uint8Array,\r\n    offset: number,\r\n    littleEndian: boolean,\r\n) {\r\n    return littleEndian\r\n        ? buffer[offset]! |\r\n              (buffer[offset + 1]! << 8) |\r\n              (buffer[offset + 2]! << 16) |\r\n              (buffer[offset + 3]! << 24)\r\n        : (buffer[offset]! << 24) |\r\n              (buffer[offset + 1]! << 16) |\r\n              (buffer[offset + 2]! << 8) |\r\n              buffer[offset + 3]!;\r\n}\r\n\r\nexport function setInt32LittleEndian(\r\n    buffer: Uint8Array,\r\n    offset: number,\r\n    value: number,\r\n) {\r\n    buffer[offset] = value;\r\n    buffer[offset + 1] = value >> 8;\r\n    buffer[offset + 2] = value >> 16;\r\n    buffer[offset + 3] = value >> 24;\r\n}\r\n\r\nexport function setInt32BigEndian(\r\n    buffer: Uint8Array,\r\n    offset: number,\r\n    value: number,\r\n) {\r\n    buffer[offset] = value >> 24;\r\n    buffer[offset + 1] = value >> 16;\r\n    buffer[offset + 2] = value >> 8;\r\n    buffer[offset + 3] = value;\r\n}\r\n\r\nexport function setInt32(\r\n    buffer: Uint8Array,\r\n    offset: number,\r\n    value: number,\r\n    littleEndian: boolean,\r\n) {\r\n    if (littleEndian) {\r\n        buffer[offset] = value;\r\n        buffer[offset + 1] = value >> 8;\r\n        buffer[offset + 2] = value >> 16;\r\n        buffer[offset + 3] = value >> 24;\r\n    } else {\r\n        buffer[offset] = value >> 24;\r\n        buffer[offset + 1] = value >> 16;\r\n        buffer[offset + 2] = value >> 8;\r\n        buffer[offset + 3] = value;\r\n    }\r\n}\r\n","export function getInt64LittleEndian(buffer, offset) {\n    return (BigInt(buffer[offset]) |\n        (BigInt(buffer[offset + 1]) << 8n) |\n        (BigInt(buffer[offset + 2]) << 16n) |\n        (BigInt(buffer[offset + 3]) << 24n) |\n        (BigInt(buffer[offset + 4]) << 32n) |\n        (BigInt(buffer[offset + 5]) << 40n) |\n        (BigInt(buffer[offset + 6]) << 48n) |\n        (BigInt(buffer[offset + 7] << 24) << 32n));\n}\nexport function getInt64BigEndian(buffer, offset) {\n    return ((BigInt(buffer[offset] << 24) << 32n) |\n        (BigInt(buffer[offset + 1]) << 48n) |\n        (BigInt(buffer[offset + 2]) << 40n) |\n        (BigInt(buffer[offset + 3]) << 32n) |\n        (BigInt(buffer[offset + 4]) << 24n) |\n        (BigInt(buffer[offset + 5]) << 16n) |\n        (BigInt(buffer[offset + 6]) << 8n) |\n        BigInt(buffer[offset + 7]));\n}\nexport function getInt64(buffer, offset, littleEndian) {\n    return littleEndian\n        ? BigInt(buffer[offset]) |\n            (BigInt(buffer[offset + 1]) << 8n) |\n            (BigInt(buffer[offset + 2]) << 16n) |\n            (BigInt(buffer[offset + 3]) << 24n) |\n            (BigInt(buffer[offset + 4]) << 32n) |\n            (BigInt(buffer[offset + 5]) << 40n) |\n            (BigInt(buffer[offset + 6]) << 48n) |\n            (BigInt(buffer[offset + 7] << 24) << 32n)\n        : (BigInt(buffer[offset] << 24) << 32n) |\n            (BigInt(buffer[offset + 1]) << 48n) |\n            (BigInt(buffer[offset + 2]) << 40n) |\n            (BigInt(buffer[offset + 3]) << 32n) |\n            (BigInt(buffer[offset + 4]) << 24n) |\n            (BigInt(buffer[offset + 5]) << 16n) |\n            (BigInt(buffer[offset + 6]) << 8n) |\n            BigInt(buffer[offset + 7]);\n}\nexport function setInt64LittleEndian(buffer, offset, value) {\n    buffer[offset] = Number(value & 0xffn);\n    buffer[offset + 1] = Number((value >> 8n) & 0xffn);\n    buffer[offset + 2] = Number((value >> 16n) & 0xffn);\n    buffer[offset + 3] = Number((value >> 24n) & 0xffn);\n    buffer[offset + 4] = Number((value >> 32n) & 0xffn);\n    buffer[offset + 5] = Number((value >> 40n) & 0xffn);\n    buffer[offset + 6] = Number((value >> 48n) & 0xffn);\n    buffer[offset + 7] = Number((value >> 56n) & 0xffn);\n}\nexport function setInt64BigEndian(buffer, offset, value) {\n    buffer[offset] = Number((value >> 56n) & 0xffn);\n    buffer[offset + 1] = Number((value >> 48n) & 0xffn);\n    buffer[offset + 2] = Number((value >> 40n) & 0xffn);\n    buffer[offset + 3] = Number((value >> 32n) & 0xffn);\n    buffer[offset + 4] = Number((value >> 24n) & 0xffn);\n    buffer[offset + 5] = Number((value >> 16n) & 0xffn);\n    buffer[offset + 6] = Number((value >> 8n) & 0xffn);\n    buffer[offset + 7] = Number(value & 0xffn);\n}\nexport function setInt64(buffer, offset, value, littleEndian) {\n    if (littleEndian) {\n        buffer[offset] = Number(value & 0xffn);\n        buffer[offset + 1] = Number((value >> 8n) & 0xffn);\n        buffer[offset + 2] = Number((value >> 16n) & 0xffn);\n        buffer[offset + 3] = Number((value >> 24n) & 0xffn);\n        buffer[offset + 4] = Number((value >> 32n) & 0xffn);\n        buffer[offset + 5] = Number((value >> 40n) & 0xffn);\n        buffer[offset + 6] = Number((value >> 48n) & 0xffn);\n        buffer[offset + 7] = Number((value >> 56n) & 0xffn);\n    }\n    else {\n        buffer[offset] = Number((value >> 56n) & 0xffn);\n        buffer[offset + 1] = Number((value >> 48n) & 0xffn);\n        buffer[offset + 2] = Number((value >> 40n) & 0xffn);\n        buffer[offset + 3] = Number((value >> 32n) & 0xffn);\n        buffer[offset + 4] = Number((value >> 24n) & 0xffn);\n        buffer[offset + 5] = Number((value >> 16n) & 0xffn);\n        buffer[offset + 6] = Number((value >> 8n) & 0xffn);\n        buffer[offset + 7] = Number(value & 0xffn);\n    }\n}\n//# sourceMappingURL=int64.js.map","export function getInt64LittleEndian(\r\n    buffer: Uint8Array,\r\n    offset: number,\r\n): bigint {\r\n    return (\r\n        BigInt(buffer[offset]!) |\r\n        (BigInt(buffer[offset + 1]!) << 8n) |\r\n        (BigInt(buffer[offset + 2]!) << 16n) |\r\n        (BigInt(buffer[offset + 3]!) << 24n) |\r\n        (BigInt(buffer[offset + 4]!) << 32n) |\r\n        (BigInt(buffer[offset + 5]!) << 40n) |\r\n        (BigInt(buffer[offset + 6]!) << 48n) |\r\n        (BigInt(buffer[offset + 7]! << 24) << 32n)\r\n    );\r\n}\r\n\r\nexport function getInt64BigEndian(buffer: Uint8Array, offset: number): bigint {\r\n    return (\r\n        (BigInt(buffer[offset]! << 24) << 32n) |\r\n        (BigInt(buffer[offset + 1]!) << 48n) |\r\n        (BigInt(buffer[offset + 2]!) << 40n) |\r\n        (BigInt(buffer[offset + 3]!) << 32n) |\r\n        (BigInt(buffer[offset + 4]!) << 24n) |\r\n        (BigInt(buffer[offset + 5]!) << 16n) |\r\n        (BigInt(buffer[offset + 6]!) << 8n) |\r\n        BigInt(buffer[offset + 7]!)\r\n    );\r\n}\r\n\r\nexport function getInt64(\r\n    buffer: Uint8Array,\r\n    offset: number,\r\n    littleEndian: boolean,\r\n): bigint {\r\n    return littleEndian\r\n        ? BigInt(buffer[offset]!) |\r\n              (BigInt(buffer[offset + 1]!) << 8n) |\r\n              (BigInt(buffer[offset + 2]!) << 16n) |\r\n              (BigInt(buffer[offset + 3]!) << 24n) |\r\n              (BigInt(buffer[offset + 4]!) << 32n) |\r\n              (BigInt(buffer[offset + 5]!) << 40n) |\r\n              (BigInt(buffer[offset + 6]!) << 48n) |\r\n              (BigInt(buffer[offset + 7]! << 24) << 32n)\r\n        : (BigInt(buffer[offset]! << 24) << 32n) |\r\n              (BigInt(buffer[offset + 1]!) << 48n) |\r\n              (BigInt(buffer[offset + 2]!) << 40n) |\r\n              (BigInt(buffer[offset + 3]!) << 32n) |\r\n              (BigInt(buffer[offset + 4]!) << 24n) |\r\n              (BigInt(buffer[offset + 5]!) << 16n) |\r\n              (BigInt(buffer[offset + 6]!) << 8n) |\r\n              BigInt(buffer[offset + 7]!);\r\n}\r\n\r\nexport function setInt64LittleEndian(\r\n    buffer: Uint8Array,\r\n    offset: number,\r\n    value: bigint,\r\n): void {\r\n    buffer[offset] = Number(value & 0xffn);\r\n    buffer[offset + 1] = Number((value >> 8n) & 0xffn);\r\n    buffer[offset + 2] = Number((value >> 16n) & 0xffn);\r\n    buffer[offset + 3] = Number((value >> 24n) & 0xffn);\r\n    buffer[offset + 4] = Number((value >> 32n) & 0xffn);\r\n    buffer[offset + 5] = Number((value >> 40n) & 0xffn);\r\n    buffer[offset + 6] = Number((value >> 48n) & 0xffn);\r\n    buffer[offset + 7] = Number((value >> 56n) & 0xffn);\r\n}\r\n\r\nexport function setInt64BigEndian(\r\n    buffer: Uint8Array,\r\n    offset: number,\r\n    value: bigint,\r\n): void {\r\n    buffer[offset] = Number((value >> 56n) & 0xffn);\r\n    buffer[offset + 1] = Number((value >> 48n) & 0xffn);\r\n    buffer[offset + 2] = Number((value >> 40n) & 0xffn);\r\n    buffer[offset + 3] = Number((value >> 32n) & 0xffn);\r\n    buffer[offset + 4] = Number((value >> 24n) & 0xffn);\r\n    buffer[offset + 5] = Number((value >> 16n) & 0xffn);\r\n    buffer[offset + 6] = Number((value >> 8n) & 0xffn);\r\n    buffer[offset + 7] = Number(value & 0xffn);\r\n}\r\n\r\nexport function setInt64(\r\n    buffer: Uint8Array,\r\n    offset: number,\r\n    value: bigint,\r\n    littleEndian: boolean,\r\n): void {\r\n    if (littleEndian) {\r\n        buffer[offset] = Number(value & 0xffn);\r\n        buffer[offset + 1] = Number((value >> 8n) & 0xffn);\r\n        buffer[offset + 2] = Number((value >> 16n) & 0xffn);\r\n        buffer[offset + 3] = Number((value >> 24n) & 0xffn);\r\n        buffer[offset + 4] = Number((value >> 32n) & 0xffn);\r\n        buffer[offset + 5] = Number((value >> 40n) & 0xffn);\r\n        buffer[offset + 6] = Number((value >> 48n) & 0xffn);\r\n        buffer[offset + 7] = Number((value >> 56n) & 0xffn);\r\n    } else {\r\n        buffer[offset] = Number((value >> 56n) & 0xffn);\r\n        buffer[offset + 1] = Number((value >> 48n) & 0xffn);\r\n        buffer[offset + 2] = Number((value >> 40n) & 0xffn);\r\n        buffer[offset + 3] = Number((value >> 32n) & 0xffn);\r\n        buffer[offset + 4] = Number((value >> 24n) & 0xffn);\r\n        buffer[offset + 5] = Number((value >> 16n) & 0xffn);\r\n        buffer[offset + 6] = Number((value >> 8n) & 0xffn);\r\n        buffer[offset + 7] = Number(value & 0xffn);\r\n    }\r\n}\r\n","export function getInt8(buffer, offset) {\n    return (buffer[offset] << 24) >> 24;\n}\n//# sourceMappingURL=int8.js.map","export function getInt8(buffer: Uint8Array, offset: number): number {\r\n    return (buffer[offset]! << 24) >> 24;\r\n}\r\n","export function getUint16LittleEndian(buffer, offset) {\n    return buffer[offset] | (buffer[offset + 1] << 8);\n}\nexport function getUint16BigEndian(buffer, offset) {\n    return (buffer[offset] << 8) | buffer[offset + 1];\n}\nexport function getUint16(buffer, offset, littleEndian) {\n    return littleEndian\n        ? buffer[offset] | (buffer[offset + 1] << 8)\n        : buffer[offset + 1] | (buffer[offset] << 8);\n}\nexport function setUint16LittleEndian(buffer, offset, value) {\n    buffer[offset] = value;\n    buffer[offset + 1] = value >> 8;\n}\nexport function setUint16BigEndian(buffer, offset, value) {\n    buffer[offset] = value >> 8;\n    buffer[offset + 1] = value;\n}\nexport function setUint16(buffer, offset, value, littleEndian) {\n    if (littleEndian) {\n        buffer[offset] = value;\n        buffer[offset + 1] = value >> 8;\n    }\n    else {\n        buffer[offset] = value >> 8;\n        buffer[offset + 1] = value;\n    }\n}\n//# sourceMappingURL=uint16.js.map","export function getUint16LittleEndian(\r\n    buffer: Uint8Array,\r\n    offset: number,\r\n): number {\r\n    return buffer[offset]! | (buffer[offset + 1]! << 8);\r\n}\r\n\r\nexport function getUint16BigEndian(buffer: Uint8Array, offset: number): number {\r\n    return (buffer[offset]! << 8) | buffer[offset + 1]!;\r\n}\r\n\r\nexport function getUint16(\r\n    buffer: Uint8Array,\r\n    offset: number,\r\n    littleEndian: boolean,\r\n) {\r\n    return littleEndian\r\n        ? buffer[offset]! | (buffer[offset + 1]! << 8)\r\n        : buffer[offset + 1]! | (buffer[offset]! << 8);\r\n}\r\n\r\nexport function setUint16LittleEndian(\r\n    buffer: Uint8Array,\r\n    offset: number,\r\n    value: number,\r\n): void {\r\n    buffer[offset] = value;\r\n    buffer[offset + 1] = value >> 8;\r\n}\r\n\r\nexport function setUint16BigEndian(\r\n    buffer: Uint8Array,\r\n    offset: number,\r\n    value: number,\r\n): void {\r\n    buffer[offset] = value >> 8;\r\n    buffer[offset + 1] = value;\r\n}\r\n\r\nexport function setUint16(\r\n    buffer: Uint8Array,\r\n    offset: number,\r\n    value: number,\r\n    littleEndian: boolean,\r\n): void {\r\n    if (littleEndian) {\r\n        buffer[offset] = value;\r\n        buffer[offset + 1] = value >> 8;\r\n    } else {\r\n        buffer[offset] = value >> 8;\r\n        buffer[offset + 1] = value;\r\n    }\r\n}\r\n","export function getUint32LittleEndian(buffer, offset) {\n    return ((buffer[offset] |\n        (buffer[offset + 1] << 8) |\n        (buffer[offset + 2] << 16) |\n        (buffer[offset + 3] << 24)) >>>\n        0);\n}\nexport function getUint32BigEndian(buffer, offset) {\n    return (((buffer[offset] << 24) |\n        (buffer[offset + 1] << 16) |\n        (buffer[offset + 2] << 8) |\n        buffer[offset + 3]) >>>\n        0);\n}\nexport function getUint32(buffer, offset, littleEndian) {\n    return littleEndian\n        ? (buffer[offset] |\n            (buffer[offset + 1] << 8) |\n            (buffer[offset + 2] << 16) |\n            (buffer[offset + 3] << 24)) >>>\n            0\n        : ((buffer[offset] << 24) |\n            (buffer[offset + 1] << 16) |\n            (buffer[offset + 2] << 8) |\n            buffer[offset + 3]) >>>\n            0;\n}\nexport function setUint32LittleEndian(buffer, offset, value) {\n    buffer[offset] = value;\n    buffer[offset + 1] = value >> 8;\n    buffer[offset + 2] = value >> 16;\n    buffer[offset + 3] = value >> 24;\n}\nexport function setUint32BigEndian(buffer, offset, value) {\n    buffer[offset] = value >> 24;\n    buffer[offset + 1] = value >> 16;\n    buffer[offset + 2] = value >> 8;\n    buffer[offset + 3] = value;\n}\nexport function setUint32(buffer, offset, value, littleEndian) {\n    if (littleEndian) {\n        buffer[offset] = value;\n        buffer[offset + 1] = value >> 8;\n        buffer[offset + 2] = value >> 16;\n        buffer[offset + 3] = value >> 24;\n    }\n    else {\n        buffer[offset] = value >> 24;\n        buffer[offset + 1] = value >> 16;\n        buffer[offset + 2] = value >> 8;\n        buffer[offset + 3] = value;\n    }\n}\n//# sourceMappingURL=uint32.js.map","export function getUint32LittleEndian(\r\n    buffer: Uint8Array,\r\n    offset: number,\r\n): number {\r\n    return (\r\n        (buffer[offset]! |\r\n            (buffer[offset + 1]! << 8) |\r\n            (buffer[offset + 2]! << 16) |\r\n            (buffer[offset + 3]! << 24)) >>>\r\n        0\r\n    );\r\n}\r\n\r\nexport function getUint32BigEndian(buffer: Uint8Array, offset: number): number {\r\n    return (\r\n        ((buffer[offset]! << 24) |\r\n            (buffer[offset + 1]! << 16) |\r\n            (buffer[offset + 2]! << 8) |\r\n            buffer[offset + 3]!) >>>\r\n        0\r\n    );\r\n}\r\n\r\nexport function getUint32(\r\n    buffer: Uint8Array,\r\n    offset: number,\r\n    littleEndian: boolean,\r\n) {\r\n    return littleEndian\r\n        ? (buffer[offset]! |\r\n              (buffer[offset + 1]! << 8) |\r\n              (buffer[offset + 2]! << 16) |\r\n              (buffer[offset + 3]! << 24)) >>>\r\n              0\r\n        : ((buffer[offset]! << 24) |\r\n              (buffer[offset + 1]! << 16) |\r\n              (buffer[offset + 2]! << 8) |\r\n              buffer[offset + 3]!) >>>\r\n              0;\r\n}\r\n\r\nexport function setUint32LittleEndian(\r\n    buffer: Uint8Array,\r\n    offset: number,\r\n    value: number,\r\n): void {\r\n    buffer[offset] = value;\r\n    buffer[offset + 1] = value >> 8;\r\n    buffer[offset + 2] = value >> 16;\r\n    buffer[offset + 3] = value >> 24;\r\n}\r\n\r\nexport function setUint32BigEndian(\r\n    buffer: Uint8Array,\r\n    offset: number,\r\n    value: number,\r\n): void {\r\n    buffer[offset] = value >> 24;\r\n    buffer[offset + 1] = value >> 16;\r\n    buffer[offset + 2] = value >> 8;\r\n    buffer[offset + 3] = value;\r\n}\r\n\r\nexport function setUint32(\r\n    buffer: Uint8Array,\r\n    offset: number,\r\n    value: number,\r\n    littleEndian: boolean,\r\n): void {\r\n    if (littleEndian) {\r\n        buffer[offset] = value;\r\n        buffer[offset + 1] = value >> 8;\r\n        buffer[offset + 2] = value >> 16;\r\n        buffer[offset + 3] = value >> 24;\r\n    } else {\r\n        buffer[offset] = value >> 24;\r\n        buffer[offset + 1] = value >> 16;\r\n        buffer[offset + 2] = value >> 8;\r\n        buffer[offset + 3] = value;\r\n    }\r\n}\r\n","export function getUint64LittleEndian(buffer, offset) {\n    return (BigInt(buffer[offset]) |\n        (BigInt(buffer[offset + 1]) << 8n) |\n        (BigInt(buffer[offset + 2]) << 16n) |\n        (BigInt(buffer[offset + 3]) << 24n) |\n        (BigInt(buffer[offset + 4]) << 32n) |\n        (BigInt(buffer[offset + 5]) << 40n) |\n        (BigInt(buffer[offset + 6]) << 48n) |\n        (BigInt(buffer[offset + 7]) << 56n));\n}\nexport function getUint64BigEndian(buffer, offset) {\n    return ((BigInt(buffer[offset]) << 56n) |\n        (BigInt(buffer[offset + 1]) << 48n) |\n        (BigInt(buffer[offset + 2]) << 40n) |\n        (BigInt(buffer[offset + 3]) << 32n) |\n        (BigInt(buffer[offset + 4]) << 24n) |\n        (BigInt(buffer[offset + 5]) << 16n) |\n        (BigInt(buffer[offset + 6]) << 8n) |\n        BigInt(buffer[offset + 7]));\n}\nexport function getUint64(buffer, offset, littleEndian) {\n    return littleEndian\n        ? BigInt(buffer[offset]) |\n            (BigInt(buffer[offset + 1]) << 8n) |\n            (BigInt(buffer[offset + 2]) << 16n) |\n            (BigInt(buffer[offset + 3]) << 24n) |\n            (BigInt(buffer[offset + 4]) << 32n) |\n            (BigInt(buffer[offset + 5]) << 40n) |\n            (BigInt(buffer[offset + 6]) << 48n) |\n            (BigInt(buffer[offset + 7]) << 56n)\n        : (BigInt(buffer[offset]) << 56n) |\n            (BigInt(buffer[offset + 1]) << 48n) |\n            (BigInt(buffer[offset + 2]) << 40n) |\n            (BigInt(buffer[offset + 3]) << 32n) |\n            (BigInt(buffer[offset + 4]) << 24n) |\n            (BigInt(buffer[offset + 5]) << 16n) |\n            (BigInt(buffer[offset + 6]) << 8n) |\n            BigInt(buffer[offset + 7]);\n}\nexport function setUint64LittleEndian(buffer, offset, value) {\n    buffer[offset] = Number(value & 0xffn);\n    buffer[offset + 1] = Number((value >> 8n) & 0xffn);\n    buffer[offset + 2] = Number((value >> 16n) & 0xffn);\n    buffer[offset + 3] = Number((value >> 24n) & 0xffn);\n    buffer[offset + 4] = Number((value >> 32n) & 0xffn);\n    buffer[offset + 5] = Number((value >> 40n) & 0xffn);\n    buffer[offset + 6] = Number((value >> 48n) & 0xffn);\n    buffer[offset + 7] = Number((value >> 56n) & 0xffn);\n}\nexport function setUint64BigEndian(buffer, offset, value) {\n    buffer[offset] = Number((value >> 56n) & 0xffn);\n    buffer[offset + 1] = Number((value >> 48n) & 0xffn);\n    buffer[offset + 2] = Number((value >> 40n) & 0xffn);\n    buffer[offset + 3] = Number((value >> 32n) & 0xffn);\n    buffer[offset + 4] = Number((value >> 24n) & 0xffn);\n    buffer[offset + 5] = Number((value >> 16n) & 0xffn);\n    buffer[offset + 6] = Number((value >> 8n) & 0xffn);\n    buffer[offset + 7] = Number(value & 0xffn);\n}\nexport function setUint64(buffer, offset, value, littleEndian) {\n    if (littleEndian) {\n        buffer[offset] = Number(value & 0xffn);\n        buffer[offset + 1] = Number((value >> 8n) & 0xffn);\n        buffer[offset + 2] = Number((value >> 16n) & 0xffn);\n        buffer[offset + 3] = Number((value >> 24n) & 0xffn);\n        buffer[offset + 4] = Number((value >> 32n) & 0xffn);\n        buffer[offset + 5] = Number((value >> 40n) & 0xffn);\n        buffer[offset + 6] = Number((value >> 48n) & 0xffn);\n        buffer[offset + 7] = Number((value >> 56n) & 0xffn);\n    }\n    else {\n        buffer[offset] = Number((value >> 56n) & 0xffn);\n        buffer[offset + 1] = Number((value >> 48n) & 0xffn);\n        buffer[offset + 2] = Number((value >> 40n) & 0xffn);\n        buffer[offset + 3] = Number((value >> 32n) & 0xffn);\n        buffer[offset + 4] = Number((value >> 24n) & 0xffn);\n        buffer[offset + 5] = Number((value >> 16n) & 0xffn);\n        buffer[offset + 6] = Number((value >> 8n) & 0xffn);\n        buffer[offset + 7] = Number(value & 0xffn);\n    }\n}\n//# sourceMappingURL=uint64.js.map","export function getUint64LittleEndian(\r\n    buffer: Uint8Array,\r\n    offset: number,\r\n): bigint {\r\n    return (\r\n        BigInt(buffer[offset]!) |\r\n        (BigInt(buffer[offset + 1]!) << 8n) |\r\n        (BigInt(buffer[offset + 2]!) << 16n) |\r\n        (BigInt(buffer[offset + 3]!) << 24n) |\r\n        (BigInt(buffer[offset + 4]!) << 32n) |\r\n        (BigInt(buffer[offset + 5]!) << 40n) |\r\n        (BigInt(buffer[offset + 6]!) << 48n) |\r\n        (BigInt(buffer[offset + 7]!) << 56n)\r\n    );\r\n}\r\n\r\nexport function getUint64BigEndian(buffer: Uint8Array, offset: number): bigint {\r\n    return (\r\n        (BigInt(buffer[offset]!) << 56n) |\r\n        (BigInt(buffer[offset + 1]!) << 48n) |\r\n        (BigInt(buffer[offset + 2]!) << 40n) |\r\n        (BigInt(buffer[offset + 3]!) << 32n) |\r\n        (BigInt(buffer[offset + 4]!) << 24n) |\r\n        (BigInt(buffer[offset + 5]!) << 16n) |\r\n        (BigInt(buffer[offset + 6]!) << 8n) |\r\n        BigInt(buffer[offset + 7]!)\r\n    );\r\n}\r\n\r\nexport function getUint64(\r\n    buffer: Uint8Array,\r\n    offset: number,\r\n    littleEndian: boolean,\r\n): bigint {\r\n    return littleEndian\r\n        ? BigInt(buffer[offset]!) |\r\n              (BigInt(buffer[offset + 1]!) << 8n) |\r\n              (BigInt(buffer[offset + 2]!) << 16n) |\r\n              (BigInt(buffer[offset + 3]!) << 24n) |\r\n              (BigInt(buffer[offset + 4]!) << 32n) |\r\n              (BigInt(buffer[offset + 5]!) << 40n) |\r\n              (BigInt(buffer[offset + 6]!) << 48n) |\r\n              (BigInt(buffer[offset + 7]!) << 56n)\r\n        : (BigInt(buffer[offset]!) << 56n) |\r\n              (BigInt(buffer[offset + 1]!) << 48n) |\r\n              (BigInt(buffer[offset + 2]!) << 40n) |\r\n              (BigInt(buffer[offset + 3]!) << 32n) |\r\n              (BigInt(buffer[offset + 4]!) << 24n) |\r\n              (BigInt(buffer[offset + 5]!) << 16n) |\r\n              (BigInt(buffer[offset + 6]!) << 8n) |\r\n              BigInt(buffer[offset + 7]!);\r\n}\r\n\r\nexport function setUint64LittleEndian(\r\n    buffer: Uint8Array,\r\n    offset: number,\r\n    value: bigint,\r\n): void {\r\n    buffer[offset] = Number(value & 0xffn);\r\n    buffer[offset + 1] = Number((value >> 8n) & 0xffn);\r\n    buffer[offset + 2] = Number((value >> 16n) & 0xffn);\r\n    buffer[offset + 3] = Number((value >> 24n) & 0xffn);\r\n    buffer[offset + 4] = Number((value >> 32n) & 0xffn);\r\n    buffer[offset + 5] = Number((value >> 40n) & 0xffn);\r\n    buffer[offset + 6] = Number((value >> 48n) & 0xffn);\r\n    buffer[offset + 7] = Number((value >> 56n) & 0xffn);\r\n}\r\n\r\nexport function setUint64BigEndian(\r\n    buffer: Uint8Array,\r\n    offset: number,\r\n    value: bigint,\r\n): void {\r\n    buffer[offset] = Number((value >> 56n) & 0xffn);\r\n    buffer[offset + 1] = Number((value >> 48n) & 0xffn);\r\n    buffer[offset + 2] = Number((value >> 40n) & 0xffn);\r\n    buffer[offset + 3] = Number((value >> 32n) & 0xffn);\r\n    buffer[offset + 4] = Number((value >> 24n) & 0xffn);\r\n    buffer[offset + 5] = Number((value >> 16n) & 0xffn);\r\n    buffer[offset + 6] = Number((value >> 8n) & 0xffn);\r\n    buffer[offset + 7] = Number(value & 0xffn);\r\n}\r\n\r\nexport function setUint64(\r\n    buffer: Uint8Array,\r\n    offset: number,\r\n    value: bigint,\r\n    littleEndian: boolean,\r\n): void {\r\n    if (littleEndian) {\r\n        buffer[offset] = Number(value & 0xffn);\r\n        buffer[offset + 1] = Number((value >> 8n) & 0xffn);\r\n        buffer[offset + 2] = Number((value >> 16n) & 0xffn);\r\n        buffer[offset + 3] = Number((value >> 24n) & 0xffn);\r\n        buffer[offset + 4] = Number((value >> 32n) & 0xffn);\r\n        buffer[offset + 5] = Number((value >> 40n) & 0xffn);\r\n        buffer[offset + 6] = Number((value >> 48n) & 0xffn);\r\n        buffer[offset + 7] = Number((value >> 56n) & 0xffn);\r\n    } else {\r\n        buffer[offset] = Number((value >> 56n) & 0xffn);\r\n        buffer[offset + 1] = Number((value >> 48n) & 0xffn);\r\n        buffer[offset + 2] = Number((value >> 40n) & 0xffn);\r\n        buffer[offset + 3] = Number((value >> 32n) & 0xffn);\r\n        buffer[offset + 4] = Number((value >> 24n) & 0xffn);\r\n        buffer[offset + 5] = Number((value >> 16n) & 0xffn);\r\n        buffer[offset + 6] = Number((value >> 8n) & 0xffn);\r\n        buffer[offset + 7] = Number(value & 0xffn);\r\n    }\r\n}\r\n","export * from \"./base.js\";\nexport * from \"./fixed-length.js\";\nexport * from \"./variable-length.js\";\n","import { StructFieldDefinition, StructFieldValue } from \"../../basic/index.js\";\nimport { SyncPromise } from \"../../sync-promise.js\";\nimport { decodeUtf8, encodeUtf8 } from \"../../utils.js\";\n/**\n * A converter for buffer-like fields.\n * It converts `Uint8Array`s to custom-typed values when deserializing,\n * and convert values back to `Uint8Array`s when serializing.\n *\n * @template TValue The type of the value that the converter converts to/from `Uint8Array`.\n * @template TTypeScriptType Optionally another type to refine `TValue`.\n * For example, `TValue` is `string`, and `TTypeScriptType` is `\"foo\" | \"bar\"`.\n * `TValue` is specified by the developer when creating an converter implementation,\n * `TTypeScriptType` is specified by the user when creating a field.\n */\nexport class BufferFieldConverter {\n    TTypeScriptType;\n}\n/** An identity converter, doesn't convert to anything else. */\nexport class Uint8ArrayBufferFieldConverter extends BufferFieldConverter {\n    static Instance = new Uint8ArrayBufferFieldConverter();\n    constructor() {\n        super();\n    }\n    toBuffer(value) {\n        return value;\n    }\n    toValue(buffer) {\n        return buffer;\n    }\n    getSize(value) {\n        return value.length;\n    }\n}\n/** An `BufferFieldSubType` that converts between `Uint8Array` and `string` */\nexport class StringBufferFieldConverter extends BufferFieldConverter {\n    static Instance = new StringBufferFieldConverter();\n    toBuffer(value) {\n        return encodeUtf8(value);\n    }\n    toValue(array) {\n        return decodeUtf8(array);\n    }\n    getSize() {\n        // See the note in `BufferFieldConverter.getSize`\n        return undefined;\n    }\n}\nexport const EMPTY_UINT8_ARRAY = new Uint8Array(0);\nexport class BufferLikeFieldDefinition extends StructFieldDefinition {\n    converter;\n    TTypeScriptType;\n    constructor(converter, options) {\n        super(options);\n        this.converter = converter;\n    }\n    getDeserializeSize(struct) {\n        void struct;\n        return this.getSize();\n    }\n    /**\n     * When implemented in derived classes, creates a `StructFieldValue` for the current field definition.\n     */\n    create(options, struct, value, array) {\n        return new BufferLikeFieldValue(this, options, struct, value, array);\n    }\n    deserialize(options, stream, struct) {\n        return SyncPromise.try(() => {\n            const size = this.getDeserializeSize(struct);\n            if (size === 0) {\n                return EMPTY_UINT8_ARRAY;\n            }\n            else {\n                return stream.readExactly(size);\n            }\n        })\n            .then((array) => {\n            const value = this.converter.toValue(array);\n            return this.create(options, struct, value, array);\n        })\n            .valueOrPromise();\n    }\n}\nexport class BufferLikeFieldValue extends StructFieldValue {\n    array;\n    constructor(definition, options, struct, value, array) {\n        super(definition, options, struct, value);\n        this.array = array;\n    }\n    set(value) {\n        super.set(value);\n        // When value changes, clear the cached `array`\n        // It will be lazily calculated in `serialize()`\n        this.array = undefined;\n    }\n    serialize(dataView, array, offset) {\n        this.array ??= this.definition.converter.toBuffer(this.value);\n        array.set(this.array, offset);\n    }\n}\n//# sourceMappingURL=base.js.map","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type {\n    AsyncExactReadable,\n    ExactReadable,\n    StructOptions,\n    StructValue,\n} from \"../../basic/index.js\";\nimport { StructFieldDefinition, StructFieldValue } from \"../../basic/index.js\";\nimport { SyncPromise } from \"../../sync-promise.js\";\nimport type { ValueOrPromise } from \"../../utils.js\";\nimport { decodeUtf8, encodeUtf8 } from \"../../utils.js\";\n\n/**\n * A converter for buffer-like fields.\n * It converts `Uint8Array`s to custom-typed values when deserializing,\n * and convert values back to `Uint8Array`s when serializing.\n *\n * @template TValue The type of the value that the converter converts to/from `Uint8Array`.\n * @template TTypeScriptType Optionally another type to refine `TValue`.\n * For example, `TValue` is `string`, and `TTypeScriptType` is `\"foo\" | \"bar\"`.\n * `TValue` is specified by the developer when creating an converter implementation,\n * `TTypeScriptType` is specified by the user when creating a field.\n */\nexport abstract class BufferFieldConverter<\n    TValue = unknown,\n    TTypeScriptType = TValue,\n> {\n    readonly TTypeScriptType!: TTypeScriptType;\n\n    /**\n     * When implemented in derived classes, converts the custom `value` to an `Uint8Array`\n     *\n     * This function should be \"pure\", i.e.,\n     * same `value` should always be converted to `Uint8Array`s that have same content.\n     */\n    abstract toBuffer(value: TValue): Uint8Array;\n\n    /** When implemented in derived classes, converts the `Uint8Array` to a custom value */\n    abstract toValue(array: Uint8Array): TValue;\n\n    /**\n     * When implemented in derived classes, gets the size in byte of the custom `value`.\n     *\n     * If the size can't be determined without first converting the `value` back to an `Uint8Array`,\n     * the implementer should return `undefined`. In which case, the caller will call `toBuffer` to\n     * convert the value to a `Uint8Array`, then read the length of the `Uint8Array`. The caller can\n     * cache the result so the serialization process doesn't need to call `toBuffer` again.\n     */\n    abstract getSize(value: TValue): number | undefined;\n}\n\n/** An identity converter, doesn't convert to anything else. */\nexport class Uint8ArrayBufferFieldConverter<\n    TTypeScriptType = Uint8Array,\n> extends BufferFieldConverter<Uint8Array, TTypeScriptType> {\n    static readonly Instance = new Uint8ArrayBufferFieldConverter();\n\n    protected constructor() {\n        super();\n    }\n\n    toBuffer(value: Uint8Array): Uint8Array {\n        return value;\n    }\n\n    toValue(buffer: Uint8Array): Uint8Array {\n        return buffer;\n    }\n\n    getSize(value: Uint8Array): number {\n        return value.length;\n    }\n}\n\n/** An `BufferFieldSubType` that converts between `Uint8Array` and `string` */\nexport class StringBufferFieldConverter<\n    TTypeScriptType = string,\n> extends BufferFieldConverter<string, TTypeScriptType> {\n    static readonly Instance = new StringBufferFieldConverter();\n\n    toBuffer(value: string): Uint8Array {\n        return encodeUtf8(value);\n    }\n\n    toValue(array: Uint8Array): string {\n        return decodeUtf8(array);\n    }\n\n    getSize(): number | undefined {\n        // See the note in `BufferFieldConverter.getSize`\n        return undefined;\n    }\n}\n\nexport const EMPTY_UINT8_ARRAY = new Uint8Array(0);\n\nexport abstract class BufferLikeFieldDefinition<\n    TConverter extends BufferFieldConverter<\n        unknown,\n        unknown\n    > = BufferFieldConverter<unknown, unknown>,\n    TOptions = void,\n    TOmitInitKey extends PropertyKey = never,\n    TTypeScriptType = TConverter[\"TTypeScriptType\"],\n> extends StructFieldDefinition<TOptions, TTypeScriptType, TOmitInitKey> {\n    readonly converter: TConverter;\n    readonly TTypeScriptType!: TTypeScriptType;\n\n    constructor(converter: TConverter, options: TOptions) {\n        super(options);\n        this.converter = converter;\n    }\n\n    protected getDeserializeSize(struct: StructValue): number {\n        void struct;\n        return this.getSize();\n    }\n\n    /**\n     * When implemented in derived classes, creates a `StructFieldValue` for the current field definition.\n     */\n    create(\n        options: Readonly<StructOptions>,\n        struct: StructValue,\n        value: TTypeScriptType,\n        array?: Uint8Array,\n    ): BufferLikeFieldValue<this> {\n        return new BufferLikeFieldValue(this, options, struct, value, array);\n    }\n\n    override deserialize(\n        options: Readonly<StructOptions>,\n        stream: ExactReadable,\n        struct: StructValue,\n    ): BufferLikeFieldValue<this>;\n    override deserialize(\n        options: Readonly<StructOptions>,\n        stream: AsyncExactReadable,\n        struct: StructValue,\n    ): Promise<BufferLikeFieldValue<this>>;\n    override deserialize(\n        options: Readonly<StructOptions>,\n        stream: ExactReadable | AsyncExactReadable,\n        struct: StructValue,\n    ): ValueOrPromise<BufferLikeFieldValue<this>> {\n        return SyncPromise.try(() => {\n            const size = this.getDeserializeSize(struct);\n            if (size === 0) {\n                return EMPTY_UINT8_ARRAY;\n            } else {\n                return stream.readExactly(size);\n            }\n        })\n            .then((array) => {\n                const value = this.converter.toValue(array) as TTypeScriptType;\n                return this.create(options, struct, value, array);\n            })\n            .valueOrPromise();\n    }\n}\n\nexport class BufferLikeFieldValue<\n    TDefinition extends BufferLikeFieldDefinition<\n        BufferFieldConverter<unknown, unknown>,\n        any,\n        any,\n        any\n    >,\n> extends StructFieldValue<TDefinition> {\n    protected array: Uint8Array | undefined;\n\n    constructor(\n        definition: TDefinition,\n        options: Readonly<StructOptions>,\n        struct: StructValue,\n        value: TDefinition[\"TTypeScriptType\"],\n        array?: Uint8Array,\n    ) {\n        super(definition, options, struct, value);\n        this.array = array;\n    }\n\n    override set(value: TDefinition[\"TValue\"]): void {\n        super.set(value);\n        // When value changes, clear the cached `array`\n        // It will be lazily calculated in `serialize()`\n        this.array = undefined;\n    }\n\n    override serialize(\n        dataView: DataView,\n        array: Uint8Array,\n        offset: number,\n    ): void {\n        this.array ??= this.definition.converter.toBuffer(this.value);\n        array.set(this.array, offset);\n    }\n}\n","/**\n * Returns a (fake) value of the given type.\n */\nexport function placeholder() {\n    return undefined;\n}\nconst { TextEncoder, TextDecoder } = globalThis;\nconst SharedEncoder = new TextEncoder();\nconst SharedDecoder = new TextDecoder();\nexport function encodeUtf8(input) {\n    return SharedEncoder.encode(input);\n}\nexport function decodeUtf8(buffer) {\n    // `TextDecoder` has internal states in stream mode,\n    // but this method is not for stream mode, so the instance can be reused\n    return SharedDecoder.decode(buffer);\n}\n//# sourceMappingURL=utils.js.map","/**\n * When evaluating a very complex generic type alias,\n * tell TypeScript to use `T`, instead of current type alias' name, as the result type name\n *\n * Example:\n *\n * ```ts\n * type WithIdentity<T> = Identity<SomeType<T>>;\n * type WithoutIdentity<T> = SomeType<T>;\n *\n * type WithIdentityResult = WithIdentity<number>;\n * // Hover on this one shows `SomeType<number>`\n *\n * type WithoutIdentityResult = WithoutIdentity<number>;\n * // Hover on this one shows `WithoutIdentity<number>`\n * ```\n */\nexport type Identity<T> = T;\n\n/**\n * Collapse an intersection type (`{ foo: string } & { bar: number }`) to a simple type (`{ foo: string, bar: number }`)\n */\nexport type Evaluate<T> = T extends infer U ? { [K in keyof U]: U[K] } : never;\n\n/**\n * Overwrite fields in `TBase` with fields in `TNew`\n */\nexport type Overwrite<TBase extends object, TNew extends object> = Evaluate<\n    Omit<TBase, keyof TNew> & TNew\n>;\n\n/**\n * Remove fields with `never` type\n */\nexport type OmitNever<T> = Pick<\n    T,\n    { [K in keyof T]: [T[K]] extends [never] ? never : K }[keyof T]\n>;\n\n/**\n * Extract keys of fields in `T` that has type `TValue`\n */\nexport type KeysOfType<T, TValue> = {\n    [TKey in keyof T]: T[TKey] extends TValue ? TKey : never;\n}[keyof T];\n\nexport type ValueOrPromise<T> = T | PromiseLike<T>;\n\n/**\n * Returns a (fake) value of the given type.\n */\nexport function placeholder<T>(): T {\n    return undefined as unknown as T;\n}\n\n// This library can't use `@types/node` or `lib: dom`\n// because they will pollute the global scope\n// So `TextEncoder` and `TextDecoder` types are not available\n\n// Node.js 8.3 ships `TextEncoder` and `TextDecoder` in `util` module.\n// But using top level await to load them requires Node.js 14.1.\n// So there is no point to do that. Let's just assume they exist in global.\n\ndeclare class TextEncoderType {\n    constructor();\n\n    encode(input: string): Uint8Array;\n}\n\ndeclare class TextDecoderType {\n    constructor();\n\n    decode(buffer: ArrayBufferView | ArrayBuffer): string;\n}\n\ninterface GlobalExtension {\n    TextEncoder: typeof TextEncoderType;\n    TextDecoder: typeof TextDecoderType;\n}\n\nconst { TextEncoder, TextDecoder } = globalThis as unknown as GlobalExtension;\n\nconst SharedEncoder = new TextEncoder();\nconst SharedDecoder = new TextDecoder();\n\nexport function encodeUtf8(input: string): Uint8Array {\n    return SharedEncoder.encode(input);\n}\n\nexport function decodeUtf8(buffer: ArrayBufferView | ArrayBuffer): string {\n    // `TextDecoder` has internal states in stream mode,\n    // but this method is not for stream mode, so the instance can be reused\n    return SharedDecoder.decode(buffer);\n}\n","import { BufferLikeFieldDefinition } from \"./base.js\";\nexport class FixedLengthBufferLikeFieldDefinition extends BufferLikeFieldDefinition {\n    getSize() {\n        return this.options.length;\n    }\n}\n//# sourceMappingURL=fixed-length.js.map","import type { BufferFieldConverter } from \"./base.js\";\nimport { BufferLikeFieldDefinition } from \"./base.js\";\n\nexport interface FixedLengthBufferLikeFieldOptions {\n    length: number;\n}\n\nexport class FixedLengthBufferLikeFieldDefinition<\n    TConverter extends BufferFieldConverter = BufferFieldConverter,\n    TOptions extends\n        FixedLengthBufferLikeFieldOptions = FixedLengthBufferLikeFieldOptions,\n    TTypeScriptType = TConverter[\"TTypeScriptType\"],\n> extends BufferLikeFieldDefinition<\n    TConverter,\n    TOptions,\n    never,\n    TTypeScriptType\n> {\n    getSize(): number {\n        return this.options.length;\n    }\n}\n","/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { StructFieldValue } from \"../../basic/index.js\";\nimport { BufferLikeFieldDefinition, BufferLikeFieldValue } from \"./base.js\";\nexport class VariableLengthBufferLikeFieldDefinition extends BufferLikeFieldDefinition {\n    getSize() {\n        return 0;\n    }\n    getDeserializeSize(struct) {\n        let value = struct.value[this.options.lengthField];\n        if (typeof value === \"string\") {\n            value = Number.parseInt(value, this.options.lengthFieldRadix ?? 10);\n        }\n        return value;\n    }\n    create(options, struct, value, array) {\n        return new VariableLengthBufferLikeStructFieldValue(this, options, struct, value, array);\n    }\n}\nexport class VariableLengthBufferLikeStructFieldValue extends BufferLikeFieldValue {\n    length;\n    lengthFieldValue;\n    constructor(definition, options, struct, value, array) {\n        super(definition, options, struct, value, array);\n        if (array) {\n            this.length = array.length;\n        }\n        // Patch the associated length field.\n        const lengthField = this.definition.options.lengthField;\n        const originalValue = struct.get(lengthField);\n        this.lengthFieldValue = new VariableLengthBufferLikeFieldLengthValue(originalValue, this);\n        struct.set(lengthField, this.lengthFieldValue);\n    }\n    #tryGetSize() {\n        const length = this.definition.converter.getSize(this.value);\n        if (length !== undefined && length < 0) {\n            throw new Error(\"Invalid length\");\n        }\n        return length;\n    }\n    getSize() {\n        if (this.length === undefined) {\n            // first try to get the size from the converter\n            this.length = this.#tryGetSize();\n        }\n        if (this.length === undefined) {\n            // The converter doesn't know the size, so convert the value to a buffer to get its size\n            this.array = this.definition.converter.toBuffer(this.value);\n            this.length = this.array.length;\n        }\n        return this.length;\n    }\n    set(value) {\n        super.set(value);\n        this.array = undefined;\n        this.length = undefined;\n    }\n}\nexport class VariableLengthBufferLikeFieldLengthValue extends StructFieldValue {\n    originalValue;\n    bufferValue;\n    constructor(originalValue, bufferValue) {\n        super(originalValue.definition, originalValue.options, originalValue.struct, 0);\n        this.originalValue = originalValue;\n        this.bufferValue = bufferValue;\n    }\n    getSize() {\n        return this.originalValue.getSize();\n    }\n    get() {\n        let value = this.bufferValue.getSize();\n        const originalValue = this.originalValue.get();\n        if (typeof originalValue === \"string\") {\n            value = value.toString(this.bufferValue.definition.options.lengthFieldRadix ?? 10);\n        }\n        return value;\n    }\n    set() {\n        // Ignore setting\n        // It will always be in sync with the buffer size\n    }\n    serialize(dataView, array, offset) {\n        this.originalValue.set(this.get());\n        this.originalValue.serialize(dataView, array, offset);\n    }\n}\n//# sourceMappingURL=variable-length.js.map","/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport type {\n    StructFieldDefinition,\n    StructOptions,\n    StructValue,\n} from \"../../basic/index.js\";\nimport { StructFieldValue } from \"../../basic/index.js\";\nimport type { KeysOfType } from \"../../utils.js\";\n\nimport type { BufferFieldConverter } from \"./base.js\";\nimport { BufferLikeFieldDefinition, BufferLikeFieldValue } from \"./base.js\";\n\nexport type LengthField<TFields> = KeysOfType<TFields, number | string>;\n\nexport interface VariableLengthBufferLikeFieldOptions<\n    TFields extends object = object,\n    TLengthField extends LengthField<TFields> = any,\n> {\n    /**\n     * The name of the field that contains the length of the buffer.\n     *\n     * This field must be a `number` or `string` (can't be `bigint`) field.\n     */\n    lengthField: TLengthField;\n\n    /**\n     * If the `lengthField` refers to a string field,\n     * what radix to use when converting the string to a number.\n     *\n     * @default 10\n     */\n    lengthFieldRadix?: number;\n}\n\nexport class VariableLengthBufferLikeFieldDefinition<\n    TConverter extends BufferFieldConverter = BufferFieldConverter,\n    TOptions extends\n        VariableLengthBufferLikeFieldOptions = VariableLengthBufferLikeFieldOptions,\n    TTypeScriptType = TConverter[\"TTypeScriptType\"],\n> extends BufferLikeFieldDefinition<\n    TConverter,\n    TOptions,\n    TOptions[\"lengthField\"],\n    TTypeScriptType\n> {\n    getSize(): number {\n        return 0;\n    }\n\n    protected override getDeserializeSize(struct: StructValue) {\n        let value = struct.value[this.options.lengthField] as number | string;\n        if (typeof value === \"string\") {\n            value = Number.parseInt(value, this.options.lengthFieldRadix ?? 10);\n        }\n        return value;\n    }\n\n    override create(\n        options: Readonly<StructOptions>,\n        struct: StructValue,\n        value: TTypeScriptType,\n        array?: Uint8Array,\n    ): VariableLengthBufferLikeStructFieldValue<this> {\n        return new VariableLengthBufferLikeStructFieldValue(\n            this,\n            options,\n            struct,\n            value,\n            array,\n        );\n    }\n}\n\nexport class VariableLengthBufferLikeStructFieldValue<\n    TDefinition extends\n        VariableLengthBufferLikeFieldDefinition = VariableLengthBufferLikeFieldDefinition,\n> extends BufferLikeFieldValue<TDefinition> {\n    protected length: number | undefined;\n\n    protected lengthFieldValue: VariableLengthBufferLikeFieldLengthValue;\n\n    constructor(\n        definition: TDefinition,\n        options: Readonly<StructOptions>,\n        struct: StructValue,\n        value: TDefinition[\"TValue\"],\n        array?: Uint8Array,\n    ) {\n        super(definition, options, struct, value, array);\n\n        if (array) {\n            this.length = array.length;\n        }\n\n        // Patch the associated length field.\n        const lengthField = this.definition.options.lengthField as PropertyKey;\n\n        const originalValue = struct.get(lengthField);\n        this.lengthFieldValue = new VariableLengthBufferLikeFieldLengthValue(\n            originalValue,\n            this,\n        );\n        struct.set(lengthField, this.lengthFieldValue);\n    }\n\n    #tryGetSize() {\n        const length = this.definition.converter.getSize(this.value);\n        if (length !== undefined && length < 0) {\n            throw new Error(\"Invalid length\");\n        }\n        return length;\n    }\n\n    override getSize(): number {\n        if (this.length === undefined) {\n            // first try to get the size from the converter\n            this.length = this.#tryGetSize();\n        }\n\n        if (this.length === undefined) {\n            // The converter doesn't know the size, so convert the value to a buffer to get its size\n            this.array = this.definition.converter.toBuffer(this.value);\n            this.length = this.array.length;\n        }\n\n        return this.length;\n    }\n\n    override set(value: unknown) {\n        super.set(value);\n        this.array = undefined;\n        this.length = undefined;\n    }\n}\n\n// Not using `VariableLengthBufferLikeStructFieldValue` directly makes writing tests much easier...\ntype VariableLengthBufferLikeFieldValueLike = StructFieldValue<\n    StructFieldDefinition<\n        VariableLengthBufferLikeFieldOptions<any, any>,\n        any,\n        any\n    >\n>;\n\nexport class VariableLengthBufferLikeFieldLengthValue extends StructFieldValue<\n    StructFieldDefinition<unknown, unknown, PropertyKey>\n> {\n    protected originalValue: StructFieldValue<\n        StructFieldDefinition<unknown, unknown, PropertyKey>\n    >;\n\n    protected bufferValue: VariableLengthBufferLikeFieldValueLike;\n\n    constructor(\n        originalValue: StructFieldValue<\n            StructFieldDefinition<unknown, unknown, PropertyKey>\n        >,\n        bufferValue: VariableLengthBufferLikeFieldValueLike,\n    ) {\n        super(\n            originalValue.definition,\n            originalValue.options,\n            originalValue.struct,\n            0,\n        );\n        this.originalValue = originalValue;\n        this.bufferValue = bufferValue;\n    }\n\n    override getSize() {\n        return this.originalValue.getSize();\n    }\n\n    override get() {\n        let value: string | number = this.bufferValue.getSize();\n\n        const originalValue = this.originalValue.get();\n        if (typeof originalValue === \"string\") {\n            value = value.toString(\n                this.bufferValue.definition.options.lengthFieldRadix ?? 10,\n            );\n        }\n\n        return value;\n    }\n\n    override set() {\n        // Ignore setting\n        // It will always be in sync with the buffer size\n    }\n\n    serialize(dataView: DataView, array: Uint8Array, offset: number) {\n        this.originalValue.set(this.get());\n        this.originalValue.serialize(dataView, array, offset);\n    }\n}\n","import { getInt16, getInt32, getInt8, getUint16, getUint32, } from \"@yume-chan/no-data-view\";\nimport { StructFieldDefinition, StructFieldValue } from \"../basic/index.js\";\nimport { SyncPromise } from \"../sync-promise.js\";\nexport var NumberFieldVariant;\n(function (NumberFieldVariant) {\n    NumberFieldVariant.Uint8 = {\n        signed: false,\n        size: 1,\n        deserialize(array) {\n            return array[0];\n        },\n        serialize(dataView, offset, value) {\n            dataView.setUint8(offset, value);\n        },\n    };\n    NumberFieldVariant.Int8 = {\n        signed: true,\n        size: 1,\n        deserialize(array) {\n            return getInt8(array, 0);\n        },\n        serialize(dataView, offset, value) {\n            dataView.setInt8(offset, value);\n        },\n    };\n    NumberFieldVariant.Uint16 = {\n        signed: false,\n        size: 2,\n        deserialize(array, littleEndian) {\n            // PERF: Creating many `DataView`s over small buffers is 90% slower\n            // than this. Even if the `DataView` is cached, `DataView#getUint16`\n            // is still 1% slower than this.\n            return getUint16(array, 0, littleEndian);\n        },\n        serialize(dataView, offset, value, littleEndian) {\n            dataView.setUint16(offset, value, littleEndian);\n        },\n    };\n    NumberFieldVariant.Int16 = {\n        signed: true,\n        size: 2,\n        deserialize(array, littleEndian) {\n            return getInt16(array, 0, littleEndian);\n        },\n        serialize(dataView, offset, value, littleEndian) {\n            dataView.setInt16(offset, value, littleEndian);\n        },\n    };\n    NumberFieldVariant.Uint32 = {\n        signed: false,\n        size: 4,\n        deserialize(array, littleEndian) {\n            return getUint32(array, 0, littleEndian);\n        },\n        serialize(dataView, offset, value, littleEndian) {\n            dataView.setUint32(offset, value, littleEndian);\n        },\n    };\n    NumberFieldVariant.Int32 = {\n        signed: true,\n        size: 4,\n        deserialize(array, littleEndian) {\n            return getInt32(array, 0, littleEndian);\n        },\n        serialize(dataView, offset, value, littleEndian) {\n            dataView.setInt32(offset, value, littleEndian);\n        },\n    };\n})(NumberFieldVariant || (NumberFieldVariant = {}));\nexport class NumberFieldDefinition extends StructFieldDefinition {\n    variant;\n    constructor(variant, typescriptType) {\n        void typescriptType;\n        super();\n        this.variant = variant;\n    }\n    getSize() {\n        return this.variant.size;\n    }\n    create(options, struct, value) {\n        return new NumberFieldValue(this, options, struct, value);\n    }\n    deserialize(options, stream, struct) {\n        return SyncPromise.try(() => {\n            return stream.readExactly(this.getSize());\n        })\n            .then((array) => {\n            const value = this.variant.deserialize(array, options.littleEndian);\n            return this.create(options, struct, value);\n        })\n            .valueOrPromise();\n    }\n}\nexport class NumberFieldValue extends StructFieldValue {\n    serialize(dataView, array, offset) {\n        this.definition.variant.serialize(dataView, offset, this.value, this.options.littleEndian);\n    }\n}\n//# sourceMappingURL=number.js.map","import {\n    getInt16,\n    getInt32,\n    getInt8,\n    getUint16,\n    getUint32,\n} from \"@yume-chan/no-data-view\";\n\nimport type {\n    AsyncExactReadable,\n    ExactReadable,\n    StructOptions,\n    StructValue,\n} from \"../basic/index.js\";\nimport { StructFieldDefinition, StructFieldValue } from \"../basic/index.js\";\nimport { SyncPromise } from \"../sync-promise.js\";\nimport type { ValueOrPromise } from \"../utils.js\";\n\nexport interface NumberFieldVariant {\n    signed: boolean;\n    size: number;\n    deserialize(array: Uint8Array, littleEndian: boolean): number;\n    serialize(\n        dataView: DataView,\n        offset: number,\n        value: number,\n        littleEndian: boolean,\n    ): void;\n}\n\nexport namespace NumberFieldVariant {\n    export const Uint8: NumberFieldVariant = {\n        signed: false,\n        size: 1,\n        deserialize(array) {\n            return array[0]!;\n        },\n        serialize(dataView, offset, value) {\n            dataView.setUint8(offset, value);\n        },\n    };\n\n    export const Int8: NumberFieldVariant = {\n        signed: true,\n        size: 1,\n        deserialize(array) {\n            return getInt8(array, 0);\n        },\n        serialize(dataView, offset, value) {\n            dataView.setInt8(offset, value);\n        },\n    };\n\n    export const Uint16: NumberFieldVariant = {\n        signed: false,\n        size: 2,\n        deserialize(array, littleEndian) {\n            // PERF: Creating many `DataView`s over small buffers is 90% slower\n            // than this. Even if the `DataView` is cached, `DataView#getUint16`\n            // is still 1% slower than this.\n            return getUint16(array, 0, littleEndian);\n        },\n        serialize(dataView, offset, value, littleEndian) {\n            dataView.setUint16(offset, value, littleEndian);\n        },\n    };\n\n    export const Int16: NumberFieldVariant = {\n        signed: true,\n        size: 2,\n        deserialize(array, littleEndian) {\n            return getInt16(array, 0, littleEndian);\n        },\n        serialize(dataView, offset, value, littleEndian) {\n            dataView.setInt16(offset, value, littleEndian);\n        },\n    };\n\n    export const Uint32: NumberFieldVariant = {\n        signed: false,\n        size: 4,\n        deserialize(array, littleEndian) {\n            return getUint32(array, 0, littleEndian);\n        },\n        serialize(dataView, offset, value, littleEndian) {\n            dataView.setUint32(offset, value, littleEndian);\n        },\n    };\n\n    export const Int32: NumberFieldVariant = {\n        signed: true,\n        size: 4,\n        deserialize(array, littleEndian) {\n            return getInt32(array, 0, littleEndian);\n        },\n        serialize(dataView, offset, value, littleEndian) {\n            dataView.setInt32(offset, value, littleEndian);\n        },\n    };\n}\n\nexport class NumberFieldDefinition<\n    TVariant extends NumberFieldVariant = NumberFieldVariant,\n    TTypeScriptType = number,\n> extends StructFieldDefinition<void, TTypeScriptType> {\n    readonly variant: TVariant;\n\n    constructor(variant: TVariant, typescriptType?: TTypeScriptType) {\n        void typescriptType;\n        super();\n        this.variant = variant;\n    }\n\n    getSize(): number {\n        return this.variant.size;\n    }\n\n    create(\n        options: Readonly<StructOptions>,\n        struct: StructValue,\n        value: TTypeScriptType,\n    ): NumberFieldValue<this> {\n        return new NumberFieldValue(this, options, struct, value);\n    }\n\n    override deserialize(\n        options: Readonly<StructOptions>,\n        stream: ExactReadable,\n        struct: StructValue,\n    ): NumberFieldValue<this>;\n    override deserialize(\n        options: Readonly<StructOptions>,\n        stream: AsyncExactReadable,\n        struct: StructValue,\n    ): Promise<NumberFieldValue<this>>;\n    override deserialize(\n        options: Readonly<StructOptions>,\n        stream: ExactReadable | AsyncExactReadable,\n        struct: StructValue,\n    ): ValueOrPromise<NumberFieldValue<this>> {\n        return SyncPromise.try(() => {\n            return stream.readExactly(this.getSize());\n        })\n            .then((array) => {\n                const value = this.variant.deserialize(\n                    array,\n                    options.littleEndian,\n                );\n                return this.create(options, struct, value as never);\n            })\n            .valueOrPromise();\n    }\n}\n\nexport class NumberFieldValue<\n    TDefinition extends NumberFieldDefinition<NumberFieldVariant, unknown>,\n> extends StructFieldValue<TDefinition> {\n    serialize(dataView: DataView, array: Uint8Array, offset: number): void {\n        this.definition.variant.serialize(\n            dataView,\n            offset,\n            this.value as never,\n            this.options.littleEndian,\n        );\n    }\n}\n","import { ExactReadableEndedError } from \"@yume-chan/struct\";\nimport { PushReadableStream } from \"./push-readable.js\";\nconst NOOP = () => {\n    // no-op\n};\nexport class BufferedReadableStream {\n    #buffered;\n    #bufferedOffset = 0;\n    #bufferedLength = 0;\n    #position = 0;\n    get position() {\n        return this.#position;\n    }\n    stream;\n    reader;\n    constructor(stream) {\n        this.stream = stream;\n        this.reader = stream.getReader();\n    }\n    async #readSource() {\n        const { done, value } = await this.reader.read();\n        if (done) {\n            throw new ExactReadableEndedError();\n        }\n        return value;\n    }\n    async #readAsync(length, initial) {\n        let result;\n        let index;\n        if (initial) {\n            result = new Uint8Array(length);\n            result.set(initial);\n            index = initial.length;\n            length -= initial.length;\n        }\n        else {\n            const array = await this.#readSource();\n            if (array.length === length) {\n                this.#position += length;\n                return array;\n            }\n            if (array.length > length) {\n                this.#buffered = array;\n                this.#bufferedOffset = length;\n                this.#bufferedLength = array.length - length;\n                this.#position += length;\n                return array.subarray(0, length);\n            }\n            result = new Uint8Array(length);\n            result.set(array);\n            index = array.length;\n            length -= array.length;\n            this.#position += array.length;\n        }\n        while (length > 0) {\n            const array = await this.#readSource();\n            if (array.length === length) {\n                result.set(array, index);\n                this.#position += length;\n                return result;\n            }\n            if (array.length > length) {\n                this.#buffered = array;\n                this.#bufferedOffset = length;\n                this.#bufferedLength = array.length - length;\n                result.set(array.subarray(0, length), index);\n                this.#position += length;\n                return result;\n            }\n            result.set(array, index);\n            index += array.length;\n            length -= array.length;\n            this.#position += array.length;\n        }\n        return result;\n    }\n    /**\n     *\n     * @param length\n     * @returns\n     */\n    readExactly(length) {\n        // PERF: Add a synchronous path for reading from internal buffer\n        if (this.#buffered) {\n            const array = this.#buffered;\n            const offset = this.#bufferedOffset;\n            if (this.#bufferedLength > length) {\n                // PERF: `subarray` is slow\n                // don't use it until absolutely necessary\n                this.#bufferedOffset += length;\n                this.#bufferedLength -= length;\n                this.#position += length;\n                return array.subarray(offset, offset + length);\n            }\n            this.#buffered = undefined;\n            this.#bufferedLength = 0;\n            this.#bufferedOffset = 0;\n            this.#position += array.length - offset;\n            return this.#readAsync(length, array.subarray(offset));\n        }\n        return this.#readAsync(length);\n    }\n    /**\n     * Return a readable stream with unconsumed data (if any) and\n     * all data from the wrapped stream.\n     * @returns A `ReadableStream`\n     */\n    release() {\n        if (this.#bufferedLength > 0) {\n            return new PushReadableStream(async (controller) => {\n                // Put the remaining data back to the stream\n                const buffered = this.#buffered.subarray(this.#bufferedOffset);\n                await controller.enqueue(buffered);\n                controller.abortSignal.addEventListener(\"abort\", () => {\n                    // NOOP: the reader might already be released\n                    this.reader.cancel().catch(NOOP);\n                });\n                // Manually pipe the stream\n                while (true) {\n                    const { done, value } = await this.reader.read();\n                    if (done) {\n                        return;\n                    }\n                    else {\n                        await controller.enqueue(value);\n                    }\n                }\n            });\n        }\n        else {\n            // Simply release the reader and return the stream\n            this.reader.releaseLock();\n            return this.stream;\n        }\n    }\n    async cancel(reason) {\n        await this.reader.cancel(reason);\n    }\n}\n//# sourceMappingURL=buffered.js.map","import type { AsyncExactReadable } from \"@yume-chan/struct\";\nimport { ExactReadableEndedError } from \"@yume-chan/struct\";\n\nimport { PushReadableStream } from \"./push-readable.js\";\nimport type { ReadableStream, ReadableStreamDefaultReader } from \"./stream.js\";\n\nconst NOOP = () => {\n    // no-op\n};\n\nexport class BufferedReadableStream implements AsyncExactReadable {\n    #buffered: Uint8Array | undefined;\n    #bufferedOffset = 0;\n    #bufferedLength = 0;\n\n    #position = 0;\n    get position() {\n        return this.#position;\n    }\n\n    protected readonly stream: ReadableStream<Uint8Array>;\n    protected readonly reader: ReadableStreamDefaultReader<Uint8Array>;\n\n    constructor(stream: ReadableStream<Uint8Array>) {\n        this.stream = stream;\n        this.reader = stream.getReader();\n    }\n\n    async #readSource() {\n        const { done, value } = await this.reader.read();\n        if (done) {\n            throw new ExactReadableEndedError();\n        }\n        return value;\n    }\n\n    async #readAsync(length: number, initial?: Uint8Array) {\n        let result: Uint8Array;\n        let index: number;\n\n        if (initial) {\n            result = new Uint8Array(length);\n            result.set(initial);\n            index = initial.length;\n            length -= initial.length;\n        } else {\n            const array = await this.#readSource();\n            if (array.length === length) {\n                this.#position += length;\n                return array;\n            }\n\n            if (array.length > length) {\n                this.#buffered = array;\n                this.#bufferedOffset = length;\n                this.#bufferedLength = array.length - length;\n                this.#position += length;\n                return array.subarray(0, length);\n            }\n\n            result = new Uint8Array(length);\n            result.set(array);\n            index = array.length;\n            length -= array.length;\n            this.#position += array.length;\n        }\n\n        while (length > 0) {\n            const array = await this.#readSource();\n            if (array.length === length) {\n                result.set(array, index);\n                this.#position += length;\n                return result;\n            }\n\n            if (array.length > length) {\n                this.#buffered = array;\n                this.#bufferedOffset = length;\n                this.#bufferedLength = array.length - length;\n                result.set(array.subarray(0, length), index);\n                this.#position += length;\n                return result;\n            }\n\n            result.set(array, index);\n            index += array.length;\n            length -= array.length;\n            this.#position += array.length;\n        }\n\n        return result;\n    }\n\n    /**\n     *\n     * @param length\n     * @returns\n     */\n    readExactly(length: number): Uint8Array | Promise<Uint8Array> {\n        // PERF: Add a synchronous path for reading from internal buffer\n        if (this.#buffered) {\n            const array = this.#buffered;\n            const offset = this.#bufferedOffset;\n            if (this.#bufferedLength > length) {\n                // PERF: `subarray` is slow\n                // don't use it until absolutely necessary\n                this.#bufferedOffset += length;\n                this.#bufferedLength -= length;\n                this.#position += length;\n                return array.subarray(offset, offset + length);\n            }\n\n            this.#buffered = undefined;\n            this.#bufferedLength = 0;\n            this.#bufferedOffset = 0;\n            this.#position += array.length - offset;\n            return this.#readAsync(length, array.subarray(offset));\n        }\n\n        return this.#readAsync(length);\n    }\n\n    /**\n     * Return a readable stream with unconsumed data (if any) and\n     * all data from the wrapped stream.\n     * @returns A `ReadableStream`\n     */\n    release(): ReadableStream<Uint8Array> {\n        if (this.#bufferedLength > 0) {\n            return new PushReadableStream<Uint8Array>(async (controller) => {\n                // Put the remaining data back to the stream\n                const buffered = this.#buffered!.subarray(this.#bufferedOffset);\n                await controller.enqueue(buffered);\n\n                controller.abortSignal.addEventListener(\"abort\", () => {\n                    // NOOP: the reader might already be released\n                    this.reader.cancel().catch(NOOP);\n                });\n\n                // Manually pipe the stream\n                while (true) {\n                    const { done, value } = await this.reader.read();\n                    if (done) {\n                        return;\n                    } else {\n                        await controller.enqueue(value);\n                    }\n                }\n            });\n        } else {\n            // Simply release the reader and return the stream\n            this.reader.releaseLock();\n            return this.stream;\n        }\n    }\n\n    async cancel(reason?: unknown) {\n        await this.reader.cancel(reason);\n    }\n}\n","import { PromiseResolver } from \"@yume-chan/async\";\nimport { AbortController, ReadableStream } from \"./stream.js\";\nexport class PushReadableStream extends ReadableStream {\n    #zeroHighWaterMarkAllowEnqueue = false;\n    /**\n     * Create a new `PushReadableStream` from a source.\n     *\n     * @param source If `source` returns a `Promise`, the stream will be closed\n     * when the `Promise` is resolved, and be errored when the `Promise` is rejected.\n     * @param strategy\n     */\n    constructor(source, strategy) {\n        let waterMarkLow;\n        const abortController = new AbortController();\n        super({\n            start: async (controller) => {\n                await Promise.resolve();\n                const result = source({\n                    abortSignal: abortController.signal,\n                    enqueue: async (chunk) => {\n                        if (abortController.signal.aborted) {\n                            // If the stream is already cancelled,\n                            // throw immediately.\n                            throw abortController.signal.reason;\n                        }\n                        if (controller.desiredSize === null) {\n                            // `desiredSize` being `null` means the stream is in error state,\n                            // `controller.enqueue` will throw an error for us.\n                            controller.enqueue(chunk);\n                            return;\n                        }\n                        if (this.#zeroHighWaterMarkAllowEnqueue) {\n                            this.#zeroHighWaterMarkAllowEnqueue = false;\n                            controller.enqueue(chunk);\n                            return;\n                        }\n                        if (controller.desiredSize <= 0) {\n                            waterMarkLow = new PromiseResolver();\n                            await waterMarkLow.promise;\n                        }\n                        // `controller.enqueue` will throw error for us\n                        // if the stream is already errored.\n                        controller.enqueue(chunk);\n                    },\n                    close() {\n                        controller.close();\n                    },\n                    error(e) {\n                        controller.error(e);\n                    },\n                });\n                if (result && \"then\" in result) {\n                    result.then(() => {\n                        try {\n                            controller.close();\n                        }\n                        catch (e) {\n                            // controller already closed\n                        }\n                    }, (e) => {\n                        controller.error(e);\n                    });\n                }\n            },\n            pull: () => {\n                if (waterMarkLow) {\n                    waterMarkLow.resolve();\n                    return;\n                }\n                if (strategy?.highWaterMark === 0) {\n                    this.#zeroHighWaterMarkAllowEnqueue = true;\n                }\n            },\n            cancel: (reason) => {\n                abortController.abort(reason);\n                waterMarkLow?.reject(reason);\n            },\n        }, strategy);\n    }\n}\n//# sourceMappingURL=push-readable.js.map","import { PromiseResolver } from \"@yume-chan/async\";\n\nimport type { AbortSignal, QueuingStrategy } from \"./stream.js\";\nimport { AbortController, ReadableStream } from \"./stream.js\";\n\nexport interface PushReadableStreamController<T> {\n    abortSignal: AbortSignal;\n\n    enqueue(chunk: T): Promise<void>;\n\n    close(): void;\n\n    error(e?: unknown): void;\n}\n\nexport type PushReadableStreamSource<T> = (\n    controller: PushReadableStreamController<T>,\n) => void | Promise<void>;\n\nexport class PushReadableStream<T> extends ReadableStream<T> {\n    #zeroHighWaterMarkAllowEnqueue = false;\n\n    /**\n     * Create a new `PushReadableStream` from a source.\n     *\n     * @param source If `source` returns a `Promise`, the stream will be closed\n     * when the `Promise` is resolved, and be errored when the `Promise` is rejected.\n     * @param strategy\n     */\n    constructor(\n        source: PushReadableStreamSource<T>,\n        strategy?: QueuingStrategy<T>,\n    ) {\n        let waterMarkLow: PromiseResolver<void> | undefined;\n        const abortController = new AbortController();\n\n        super(\n            {\n                start: async (controller) => {\n                    await Promise.resolve();\n\n                    const result = source({\n                        abortSignal: abortController.signal,\n                        enqueue: async (chunk) => {\n                            if (abortController.signal.aborted) {\n                                // If the stream is already cancelled,\n                                // throw immediately.\n                                throw abortController.signal.reason;\n                            }\n\n                            if (controller.desiredSize === null) {\n                                // `desiredSize` being `null` means the stream is in error state,\n                                // `controller.enqueue` will throw an error for us.\n                                controller.enqueue(chunk);\n                                return;\n                            }\n\n                            if (this.#zeroHighWaterMarkAllowEnqueue) {\n                                this.#zeroHighWaterMarkAllowEnqueue = false;\n                                controller.enqueue(chunk);\n                                return;\n                            }\n\n                            if (controller.desiredSize <= 0) {\n                                waterMarkLow = new PromiseResolver<void>();\n                                await waterMarkLow.promise;\n                            }\n\n                            // `controller.enqueue` will throw error for us\n                            // if the stream is already errored.\n                            controller.enqueue(chunk);\n                        },\n                        close() {\n                            controller.close();\n                        },\n                        error(e) {\n                            controller.error(e);\n                        },\n                    });\n\n                    if (result && \"then\" in result) {\n                        result.then(\n                            () => {\n                                try {\n                                    controller.close();\n                                } catch (e) {\n                                    // controller already closed\n                                }\n                            },\n                            (e) => {\n                                controller.error(e);\n                            },\n                        );\n                    }\n                },\n                pull: () => {\n                    if (waterMarkLow) {\n                        waterMarkLow.resolve();\n                        return;\n                    }\n                    if (strategy?.highWaterMark === 0) {\n                        this.#zeroHighWaterMarkAllowEnqueue = true;\n                    }\n                },\n                cancel: (reason) => {\n                    abortController.abort(reason);\n                    waterMarkLow?.reject(reason);\n                },\n            },\n            strategy,\n        );\n    }\n}\n","export * from './async-operation-manager';\r\nexport * from './delay';\r\nexport * from './promise-resolver';\r\n","import { PromiseResolver } from \"./promise-resolver\";\r\nvar AsyncOperationManager = (function () {\r\n    function AsyncOperationManager(startId) {\r\n        if (startId === void 0) { startId = 0; }\r\n        this.pendingResolvers = new Map();\r\n        this.nextId = startId;\r\n    }\r\n    AsyncOperationManager.prototype.add = function () {\r\n        var id = this.nextId++;\r\n        var resolver = new PromiseResolver();\r\n        this.pendingResolvers.set(id, resolver);\r\n        return [id, resolver.promise];\r\n    };\r\n    AsyncOperationManager.prototype.getResolver = function (id) {\r\n        if (!this.pendingResolvers.has(id)) {\r\n            return null;\r\n        }\r\n        var resolver = this.pendingResolvers.get(id);\r\n        this.pendingResolvers.delete(id);\r\n        return resolver;\r\n    };\r\n    AsyncOperationManager.prototype.resolve = function (id, result) {\r\n        var resolver = this.getResolver(id);\r\n        if (resolver !== null) {\r\n            resolver.resolve(result);\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    AsyncOperationManager.prototype.reject = function (id, reason) {\r\n        var resolver = this.getResolver(id);\r\n        if (resolver !== null) {\r\n            resolver.reject(reason);\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    return AsyncOperationManager;\r\n}());\r\nexport { AsyncOperationManager };\r\n//# sourceMappingURL=async-operation-manager.js.map","import { PromiseResolver } from \"./promise-resolver\";\n\nexport class AsyncOperationManager {\n    private nextId: number;\n\n    private pendingResolvers: Map<number, PromiseResolver<any>> = new Map();\n\n    public constructor(startId: number = 0) {\n        this.nextId = startId;\n    }\n\n    public add<T>(): [id: number, promise: Promise<T>] {\n        const id = this.nextId++;\n        const resolver = new PromiseResolver<T>();\n        this.pendingResolvers.set(id, resolver);\n        return [id, resolver.promise];\n    }\n\n    private getResolver(id: number): PromiseResolver<unknown> | null {\n        if (!this.pendingResolvers.has(id)) {\n            return null;\n        }\n\n        const resolver = this.pendingResolvers.get(id)!;\n        this.pendingResolvers.delete(id);\n        return resolver;\n    }\n\n    public resolve<T>(id: number, result: T): boolean {\n        const resolver = this.getResolver(id);\n        if (resolver !== null) {\n            resolver.resolve(result);\n            return true;\n        }\n        return false;\n    }\n\n    public reject(id: number, reason: Error): boolean {\n        const resolver = this.getResolver(id);\n        if (resolver !== null) {\n            resolver.reject(reason);\n            return true;\n        }\n        return false;\n    }\n}\n","var PromiseResolver = (function () {\r\n    function PromiseResolver() {\r\n        var _this = this;\r\n        this._state = 'running';\r\n        this.resolve = function (value) {\r\n            _this._resolve(value);\r\n            _this._state = 'resolved';\r\n        };\r\n        this.reject = function (reason) {\r\n            _this._reject(reason);\r\n            _this._state = 'rejected';\r\n        };\r\n        this._promise = new Promise(function (resolve, reject) {\r\n            _this._resolve = resolve;\r\n            _this._reject = reject;\r\n        });\r\n    }\r\n    Object.defineProperty(PromiseResolver.prototype, \"promise\", {\r\n        get: function () { return this._promise; },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(PromiseResolver.prototype, \"state\", {\r\n        get: function () { return this._state; },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    return PromiseResolver;\r\n}());\r\nexport { PromiseResolver };\r\n//# sourceMappingURL=promise-resolver.js.map","export type PromiseResolverState = 'running' | 'resolved' | 'rejected';\n\nexport class PromiseResolver<T> {\n    private _promise: Promise<T>;\n    public get promise(): Promise<T> { return this._promise; }\n\n    private _resolve!: (value: T | PromiseLike<T>) => void;\n    private _reject!: (reason?: any) => void;\n\n    private _state: PromiseResolverState = 'running';\n    public get state(): PromiseResolverState { return this._state; }\n\n    public constructor() {\n        this._promise = new Promise<T>((resolve, reject) => {\n            this._resolve = resolve;\n            this._reject = reject;\n        });\n    }\n\n    public resolve = (value: T | PromiseLike<T>): void => {\n        this._resolve(value);\n        this._state = 'resolved';\n    };\n\n    public reject = (reason?: any): void => {\n        this._reject(reason);\n        this._state = 'rejected';\n    };\n}\n","export function delay(time) {\r\n    return new Promise(function (resolve) {\r\n        globalThis.setTimeout(function () { return resolve(); }, time);\r\n    });\r\n}\r\n//# sourceMappingURL=delay.js.map","export function delay(time: number): Promise<void> {\n    return new Promise<void>(resolve => {\n        // Don't call `resolve` with any value.\n        (globalThis as any).setTimeout(() => resolve(), time);\n    });\n}\n","export * from \"./types.js\";\nconst Global = globalThis;\nexport const AbortController = Global.AbortController;\nexport const ReadableStream = Global.ReadableStream;\nexport const WritableStream = Global.WritableStream;\nexport const TransformStream = Global.TransformStream;\n//# sourceMappingURL=stream.js.map","import type {\n    AbortSignal,\n    ReadableStream as ReadableStreamType,\n    TransformStream as TransformStreamType,\n    WritableStream as WritableStreamType,\n} from \"./types.js\";\n\nexport * from \"./types.js\";\n\n/** A controller object that allows you to abort one or more DOM requests as and when desired. */\nexport interface AbortController {\n    /**\n     * Returns the AbortSignal object associated with this object.\n     */\n    readonly signal: AbortSignal;\n\n    /**\n     * Invoking this method will set this object's AbortSignal's aborted flag and signal to any observers that the associated activity is to be aborted.\n     */\n    abort(reason?: unknown): void;\n}\n\ninterface AbortControllerConstructor {\n    prototype: AbortController;\n    new (): AbortController;\n}\n\ninterface GlobalExtension {\n    AbortController: AbortControllerConstructor;\n    ReadableStream: typeof ReadableStreamType;\n    WritableStream: typeof WritableStreamType;\n    TransformStream: typeof TransformStreamType;\n}\n\nconst Global = globalThis as unknown as GlobalExtension;\n\nexport const AbortController = Global.AbortController;\n\nexport type ReadableStream<out T> = ReadableStreamType<T>;\nexport const ReadableStream = Global.ReadableStream;\n\nexport type WritableStream<in T> = WritableStreamType<T>;\nexport const WritableStream = Global.WritableStream;\n\nexport type TransformStream<I, O> = TransformStreamType<I, O>;\nexport const TransformStream = Global.TransformStream;\n","/// <reference lib=\"es2018.asynciterable\" />\nexport {};\n//# sourceMappingURL=types.js.map","/// <reference lib=\"es2018.asynciterable\" />\n\n/**\n * A signal object that allows you to communicate with a request and abort it if required\n * via its associated `AbortController` object.\n *\n * @remarks\n *   This interface is compatible with the `AbortSignal` interface defined in TypeScript's DOM types.\n *   It is redefined here, so it can be polyfilled without a DOM, for example with\n *   {@link https://www.npmjs.com/package/abortcontroller-polyfill | abortcontroller-polyfill} in a Node environment.\n *\n * @public\n */\nexport declare interface AbortSignal {\n    /**\n     * Whether the request is aborted.\n     */\n    readonly aborted: boolean;\n    /**\n     * If aborted, returns the reason for aborting.\n     */\n    readonly reason?: unknown;\n    /**\n     * Add an event listener to be triggered when this signal becomes aborted.\n     */\n    addEventListener(type: \"abort\", listener: () => void): void;\n    /**\n     * Remove an event listener that was previously added with {@link AbortSignal.addEventListener}.\n     */\n    removeEventListener(type: \"abort\", listener: () => void): void;\n}\n\n/**\n * A queuing strategy that counts the number of bytes in each chunk.\n *\n * @public\n */\nexport declare class ByteLengthQueuingStrategy\n    implements QueuingStrategy<ArrayBufferView>\n{\n    constructor(options: QueuingStrategyInit);\n    /**\n     * Returns the high water mark provided to the constructor.\n     */\n    get highWaterMark(): number;\n    /**\n     * Measures the size of `chunk` by returning the value of its `byteLength` property.\n     */\n    get size(): (chunk: ArrayBufferView) => number;\n}\n\n/**\n * A queuing strategy that counts the number of chunks.\n *\n * @public\n */\nexport declare class CountQueuingStrategy implements QueuingStrategy<unknown> {\n    constructor(options: QueuingStrategyInit);\n    /**\n     * Returns the high water mark provided to the constructor.\n     */\n    get highWaterMark(): number;\n    /**\n     * Measures the size of `chunk` by always returning 1.\n     * This ensures that the total queue size is a count of the number of chunks in the queue.\n     */\n    get size(): (chunk: unknown) => 1;\n}\n\n/**\n * A queuing strategy.\n *\n * @public\n */\nexport declare interface QueuingStrategy<T> {\n    /**\n     * A non-negative number indicating the high water mark of the stream using this queuing strategy.\n     */\n    highWaterMark?: number;\n    /**\n     * A function that computes and returns the finite non-negative size of the given chunk value.\n     */\n    size?: QueuingStrategySizeCallback<T>;\n}\n\n/**\n * @public\n */\nexport declare interface QueuingStrategyInit {\n    /**\n     * {@inheritDoc QueuingStrategy.highWaterMark}\n     */\n    highWaterMark: number;\n}\n\n/**\n * {@inheritDoc QueuingStrategy.size}\n * @public\n */\nexport declare type QueuingStrategySizeCallback<T> = (chunk: T) => number;\n\n/**\n * Allows control of a {@link ReadableStream | readable byte stream}'s state and internal queue.\n *\n * @public\n */\nexport declare class ReadableByteStreamController {\n    private constructor();\n    /**\n     * Returns the current BYOB pull request, or `null` if there isn't one.\n     */\n    get byobRequest(): ReadableStreamBYOBRequest | null;\n    /**\n     * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n     * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.\n     */\n    get desiredSize(): number | null;\n    /**\n     * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n     * the stream, but once those are read, the stream will become closed.\n     */\n    close(): void;\n    /**\n     * Enqueues the given chunk chunk in the controlled readable stream.\n     * The chunk has to be an `ArrayBufferView` instance, or else a `TypeError` will be thrown.\n     */\n    enqueue(chunk: ArrayBufferView): void;\n    /**\n     * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n     */\n    error(e?: unknown): void;\n}\n\n/**\n * A readable stream represents a source of data, from which you can read.\n *\n * @public\n */\nexport declare class ReadableStream<out R> implements AsyncIterable<R> {\n    constructor(\n        underlyingSource: UnderlyingByteSource,\n        strategy?: {\n            highWaterMark?: number;\n            size?: undefined;\n        },\n    );\n    constructor(\n        underlyingSource?: UnderlyingSource<R>,\n        strategy?: QueuingStrategy<R>,\n    );\n    /**\n     * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.\n     */\n    get locked(): boolean;\n    /**\n     * Cancels the stream, signaling a loss of interest in the stream by a consumer.\n     *\n     * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}\n     * method, which might or might not use it.\n     */\n    cancel(reason?: unknown): Promise<void>;\n    /**\n     * Creates a {@link ReadableStreamBYOBReader} and locks the stream to the new reader.\n     *\n     * This call behaves the same way as the no-argument variant, except that it only works on readable byte streams,\n     * i.e. streams which were constructed specifically with the ability to handle \"bring your own buffer\" reading.\n     * The returned BYOB reader provides the ability to directly read individual chunks from the stream via its\n     * {@link ReadableStreamBYOBReader.read | read()} method, into developer-supplied buffers, allowing more precise\n     * control over allocation.\n     */\n    getReader({ mode }: { mode: \"byob\" }): ReadableStreamBYOBReader;\n    /**\n     * Creates a {@link ReadableStreamDefaultReader} and locks the stream to the new reader.\n     * While the stream is locked, no other reader can be acquired until this one is released.\n     *\n     * This functionality is especially useful for creating abstractions that desire the ability to consume a stream\n     * in its entirety. By getting a reader for the stream, you can ensure nobody else can interleave reads with yours\n     * or cancel the stream, which would interfere with your abstraction.\n     */\n    getReader(): ReadableStreamDefaultReader<R>;\n    /**\n     * Provides a convenient, chainable way of piping this readable stream through a transform stream\n     * (or any other `{ writable, readable }` pair). It simply {@link ReadableStream.pipeTo | pipes} the stream\n     * into the writable side of the supplied pair, and returns the readable side for further use.\n     *\n     * Piping a stream will lock it for the duration of the pipe, preventing any other consumer from acquiring a reader.\n     */\n    pipeThrough<RS extends ReadableStream<unknown>>(\n        transform: {\n            readable: RS;\n            writable: WritableStream<R>;\n        },\n        options?: StreamPipeOptions,\n    ): RS;\n    /**\n     * Pipes this readable stream to a given writable stream. The way in which the piping process behaves under\n     * various error conditions can be customized with a number of passed options. It returns a promise that fulfills\n     * when the piping process completes successfully, or rejects if any errors were encountered.\n     *\n     * Piping a stream will lock it for the duration of the pipe, preventing any other consumer from acquiring a reader.\n     */\n    pipeTo(\n        destination: WritableStream<R>,\n        options?: StreamPipeOptions,\n    ): Promise<void>;\n    /**\n     * Tees this readable stream, returning a two-element array containing the two resulting branches as\n     * new {@link ReadableStream} instances.\n     *\n     * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.\n     * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be\n     * propagated to the stream's underlying source.\n     *\n     * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,\n     * this could allow interference between the two branches.\n     */\n    tee(): [ReadableStream<R>, ReadableStream<R>];\n    /**\n     * Asynchronously iterates over the chunks in the stream's internal queue.\n     *\n     * Asynchronously iterating over the stream will lock it, preventing any other consumer from acquiring a reader.\n     * The lock will be released if the async iterator's {@link ReadableStreamAsyncIterator.return | return()} method\n     * is called, e.g. by breaking out of the loop.\n     *\n     * By default, calling the async iterator's {@link ReadableStreamAsyncIterator.return | return()} method will also\n     * cancel the stream. To prevent this, use the stream's {@link ReadableStream.values | values()} method, passing\n     * `true` for the `preventCancel` option.\n     */\n    values(\n        options?: ReadableStreamIteratorOptions,\n    ): ReadableStreamAsyncIterator<R>;\n    /**\n     * {@inheritDoc ReadableStream.values}\n     */\n    [Symbol.asyncIterator](\n        options?: ReadableStreamIteratorOptions,\n    ): ReadableStreamAsyncIterator<R>;\n    /**\n     * Creates a new ReadableStream wrapping the provided iterable or async iterable.\n     *\n     * This can be used to adapt various kinds of objects into a readable stream,\n     * such as an array, an async generator, or a Node.js readable stream.\n     */\n    static from<R>(\n        asyncIterable: Iterable<R> | AsyncIterable<R> | ReadableStreamLike<R>,\n    ): ReadableStream<R>;\n}\n\n/**\n * An async iterator returned by {@link ReadableStream.values}.\n *\n * @public\n */\nexport declare interface ReadableStreamAsyncIterator<R>\n    extends AsyncIterableIterator<R> {\n    next(): Promise<IteratorResult<R, undefined>>;\n    return(value?: R): Promise<IteratorResult<R>>;\n}\n\n/**\n * A BYOB reader vended by a {@link ReadableStream}.\n *\n * @public\n */\nexport declare class ReadableStreamBYOBReader {\n    constructor(stream: ReadableStream<Uint8Array>);\n    /**\n     * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n     * the reader's lock is released before the stream finishes closing.\n     */\n    get closed(): Promise<undefined>;\n    /**\n     * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n     */\n    cancel(reason?: unknown): Promise<void>;\n    /**\n     * Attempts to reads bytes into view, and returns a promise resolved with the result.\n     *\n     * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n     */\n    read<T extends ArrayBufferView>(\n        view: T,\n        options?: ReadableStreamBYOBReaderReadOptions,\n    ): Promise<ReadableStreamBYOBReadResult<T>>;\n    /**\n     * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n     * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n     * from now on; otherwise, the reader will appear closed.\n     *\n     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n     * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n     * do so will throw a `TypeError` and leave the reader locked to the stream.\n     */\n    releaseLock(): void;\n}\n\n/**\n * Options for {@link ReadableStreamBYOBReader.read | reading} a stream\n * with a {@link ReadableStreamBYOBReader | BYOB reader}.\n *\n * @public\n */\nexport declare interface ReadableStreamBYOBReaderReadOptions {\n    min?: number;\n}\n\n/**\n * A result returned by {@link ReadableStreamBYOBReader.read}.\n *\n * @public\n */\nexport declare type ReadableStreamBYOBReadResult<T extends ArrayBufferView> =\n    | {\n          done: false;\n          value: T;\n      }\n    | {\n          done: true;\n          value: T | undefined;\n      };\n\n/**\n * A pull-into request in a {@link ReadableByteStreamController}.\n *\n * @public\n */\nexport declare class ReadableStreamBYOBRequest {\n    private constructor();\n    /**\n     * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.\n     */\n    get view(): ArrayBufferView | null;\n    /**\n     * Indicates to the associated readable byte stream that `bytesWritten` bytes were written into\n     * {@link ReadableStreamBYOBRequest.view | view}, causing the result be surfaced to the consumer.\n     *\n     * After this method is called, {@link ReadableStreamBYOBRequest.view | view} will be transferred and no longer\n     * modifiable.\n     */\n    respond(bytesWritten: number): void;\n    /**\n     * Indicates to the associated readable byte stream that instead of writing into\n     * {@link ReadableStreamBYOBRequest.view | view}, the underlying byte source is providing a new `ArrayBufferView`,\n     * which will be given to the consumer of the readable byte stream.\n     *\n     * After this method is called, `view` will be transferred and no longer modifiable.\n     */\n    respondWithNewView(view: ArrayBufferView): void;\n}\n\n/**\n * Allows control of a {@link ReadableStream | readable stream}'s state and internal queue.\n *\n * @public\n */\nexport declare class ReadableStreamDefaultController<R> {\n    private constructor();\n    /**\n     * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n     * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.\n     */\n    get desiredSize(): number | null;\n    /**\n     * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n     * the stream, but once those are read, the stream will become closed.\n     */\n    close(): void;\n    /**\n     * Enqueues the given chunk `chunk` in the controlled readable stream.\n     */\n    enqueue(chunk: R): void;\n    /**\n     * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n     */\n    error(e?: unknown): void;\n}\n\n/**\n * A default reader vended by a {@link ReadableStream}.\n *\n * @public\n */\nexport declare class ReadableStreamDefaultReader<out R> {\n    constructor(stream: ReadableStream<R>);\n    /**\n     * Returns a promise that will be fulfilled when the stream becomes closed,\n     * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.\n     */\n    get closed(): Promise<undefined>;\n    /**\n     * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n     */\n    cancel(reason?: unknown): Promise<void>;\n    /**\n     * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.\n     *\n     * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n     */\n    read(): Promise<ReadableStreamDefaultReadResult<R>>;\n    /**\n     * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n     * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n     * from now on; otherwise, the reader will appear closed.\n     *\n     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n     * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n     * do so will throw a `TypeError` and leave the reader locked to the stream.\n     */\n    releaseLock(): void;\n}\n\n/**\n * A common interface for a `ReadableStreamDefaultReader` implementation.\n *\n * @public\n */\nexport declare interface ReadableStreamDefaultReaderLike<R> {\n    readonly closed: Promise<undefined>;\n    cancel(reason?: unknown): Promise<void>;\n    read(): Promise<ReadableStreamDefaultReadResult<R>>;\n    releaseLock(): void;\n}\n\n/**\n * A result returned by {@link ReadableStreamDefaultReader.read}.\n *\n * @public\n */\nexport declare type ReadableStreamDefaultReadResult<T> =\n    | {\n          done: false;\n          value: T;\n      }\n    | {\n          done: true;\n          value?: undefined;\n      };\n\n/**\n * Options for {@link ReadableStream.values | async iterating} a stream.\n *\n * @public\n */\nexport declare interface ReadableStreamIteratorOptions {\n    preventCancel?: boolean;\n}\n\n/**\n * A common interface for a `ReadableStream` implementation.\n *\n * @public\n */\nexport declare interface ReadableStreamLike<R> {\n    readonly locked: boolean;\n    getReader(): ReadableStreamDefaultReaderLike<R>;\n}\n\n/**\n * A pair of a {@link ReadableStream | readable stream} and {@link WritableStream | writable stream} that can be passed\n * to {@link ReadableStream.pipeThrough}.\n *\n * @public\n */\nexport declare interface ReadableWritablePair<R, W> {\n    readable: ReadableStream<R>;\n    writable: WritableStream<W>;\n}\n\n/**\n * Options for {@link ReadableStream.pipeTo | piping} a stream.\n *\n * @public\n */\nexport declare interface StreamPipeOptions {\n    /**\n     * If set to true, {@link ReadableStream.pipeTo} will not abort the writable stream if the readable stream errors.\n     */\n    preventAbort?: boolean;\n    /**\n     * If set to true, {@link ReadableStream.pipeTo} will not cancel the readable stream if the writable stream closes\n     * or errors.\n     */\n    preventCancel?: boolean;\n    /**\n     * If set to true, {@link ReadableStream.pipeTo} will not close the writable stream if the readable stream closes.\n     */\n    preventClose?: boolean;\n    /**\n     * Can be set to an {@link AbortSignal} to allow aborting an ongoing pipe operation via the corresponding\n     * `AbortController`. In this case, the source readable stream will be canceled, and the destination writable stream\n     * aborted, unless the respective options `preventCancel` or `preventAbort` are set.\n     */\n    signal?: AbortSignal;\n}\n\n/**\n * A transformer for constructing a {@link TransformStream}.\n *\n * @public\n */\nexport declare interface Transformer<I, O> {\n    /**\n     * A function that is called immediately during creation of the {@link TransformStream}.\n     */\n    start?: TransformerStartCallback<O>;\n    /**\n     * A function called when a new chunk originally written to the writable side is ready to be transformed.\n     */\n    transform?: TransformerTransformCallback<I, O>;\n    /**\n     * A function called after all chunks written to the writable side have been transformed by successfully passing\n     * through {@link Transformer.transform | transform()}, and the writable side is about to be closed.\n     */\n    flush?: TransformerFlushCallback<O>;\n    /**\n     * A function called when the readable side is cancelled, or when the writable side is aborted.\n     */\n    cancel?: TransformerCancelCallback;\n    readableType?: undefined;\n    writableType?: undefined;\n}\n\n/** @public */\nexport declare type TransformerCancelCallback = (\n    reason: unknown,\n) => void | PromiseLike<void>;\n\n/** @public */\nexport declare type TransformerFlushCallback<O> = (\n    controller: TransformStreamDefaultController<O>,\n) => void | PromiseLike<void>;\n\n/** @public */\nexport declare type TransformerStartCallback<O> = (\n    controller: TransformStreamDefaultController<O>,\n) => void | PromiseLike<void>;\n\n/** @public */\nexport declare type TransformerTransformCallback<I, O> = (\n    chunk: I,\n    controller: TransformStreamDefaultController<O>,\n) => void | PromiseLike<void>;\n\n/**\n * A transform stream consists of a pair of streams: a {@link WritableStream | writable stream},\n * known as its writable side, and a {@link ReadableStream | readable stream}, known as its readable side.\n * In a manner specific to the transform stream in question, writes to the writable side result in new data being\n * made available for reading from the readable side.\n *\n * @public\n */\nexport declare class TransformStream<I, O> {\n    constructor(\n        transformer?: Transformer<I, O>,\n        writableStrategy?: QueuingStrategy<I>,\n        readableStrategy?: QueuingStrategy<O>,\n    );\n    /**\n     * The readable side of the transform stream.\n     */\n    get readable(): ReadableStream<O>;\n    /**\n     * The writable side of the transform stream.\n     */\n    get writable(): WritableStream<I>;\n}\n\n/**\n * Allows control of the {@link ReadableStream} and {@link WritableStream} of the associated {@link TransformStream}.\n *\n * @public\n */\nexport declare class TransformStreamDefaultController<O> {\n    private constructor();\n    /**\n     * Returns the desired size to fill the readable sides internal queue. It can be negative, if the queue is over-full.\n     */\n    get desiredSize(): number | null;\n    /**\n     * Enqueues the given chunk `chunk` in the readable side of the controlled transform stream.\n     */\n    enqueue(chunk: O): void;\n    /**\n     * Errors both the readable side and the writable side of the controlled transform stream, making all future\n     * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.\n     */\n    error(reason?: unknown): void;\n    /**\n     * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the\n     * transformer only needs to consume a portion of the chunks written to the writable side.\n     */\n    terminate(): void;\n}\n\n/**\n * An underlying byte source for constructing a {@link ReadableStream}.\n *\n * @public\n */\nexport declare interface UnderlyingByteSource {\n    /**\n     * {@inheritDoc UnderlyingSource.start}\n     */\n    start?: UnderlyingByteSourceStartCallback;\n    /**\n     * {@inheritDoc UnderlyingSource.pull}\n     */\n    pull?: UnderlyingByteSourcePullCallback;\n    /**\n     * {@inheritDoc UnderlyingSource.cancel}\n     */\n    cancel?: UnderlyingSourceCancelCallback;\n    /**\n     * Can be set to \"bytes\" to signal that the constructed {@link ReadableStream} is a readable byte stream.\n     * This ensures that the resulting {@link ReadableStream} will successfully be able to vend BYOB readers via its\n     * {@link ReadableStream.(getReader:1) | getReader()} method.\n     * It also affects the controller argument passed to the {@link UnderlyingByteSource.start | start()}\n     * and {@link UnderlyingByteSource.pull | pull()} methods.\n     */\n    type: \"bytes\";\n    /**\n     * Can be set to a positive integer to cause the implementation to automatically allocate buffers for the\n     * underlying source code to write into. In this case, when a consumer is using a default reader, the stream\n     * implementation will automatically allocate an ArrayBuffer of the given size, so that\n     * {@link ReadableByteStreamController.byobRequest | controller.byobRequest} is always present,\n     * as if the consumer was using a BYOB reader.\n     */\n    autoAllocateChunkSize?: number;\n}\n\n/** @public */\nexport declare type UnderlyingByteSourcePullCallback = (\n    controller: ReadableByteStreamController,\n) => void | PromiseLike<void>;\n\n/** @public */\nexport declare type UnderlyingByteSourceStartCallback = (\n    controller: ReadableByteStreamController,\n) => void | PromiseLike<void>;\n\n/**\n * An underlying sink for constructing a {@link WritableStream}.\n *\n * @public\n */\nexport declare interface UnderlyingSink<in W> {\n    /**\n     * A function that is called immediately during creation of the {@link WritableStream}.\n     */\n    start?: UnderlyingSinkStartCallback;\n    /**\n     * A function that is called when a new chunk of data is ready to be written to the underlying sink. The stream\n     * implementation guarantees that this function will be called only after previous writes have succeeded, and never\n     * before {@link UnderlyingSink.start | start()} has succeeded or after {@link UnderlyingSink.close | close()} or\n     * {@link UnderlyingSink.abort | abort()} have been called.\n     *\n     * This function is used to actually send the data to the resource presented by the underlying sink, for example by\n     * calling a lower-level API.\n     */\n    write?: UnderlyingSinkWriteCallback<W>;\n    /**\n     * A function that is called after the producer signals, via\n     * {@link WritableStreamDefaultWriter.close | writer.close()}, that they are done writing chunks to the stream, and\n     * subsequently all queued-up writes have successfully completed.\n     *\n     * This function can perform any actions necessary to finalize or flush writes to the underlying sink, and release\n     * access to any held resources.\n     */\n    close?: UnderlyingSinkCloseCallback;\n    /**\n     * A function that is called after the producer signals, via {@link WritableStream.abort | stream.abort()} or\n     * {@link WritableStreamDefaultWriter.abort | writer.abort()}, that they wish to abort the stream. It takes as its\n     * argument the same value as was passed to those methods by the producer.\n     *\n     * Writable streams can additionally be aborted under certain conditions during piping; see the definition of the\n     * {@link ReadableStream.pipeTo | pipeTo()} method for more details.\n     *\n     * This function can clean up any held resources, much like {@link UnderlyingSink.close | close()}, but perhaps with\n     * some custom handling.\n     */\n    abort?: UnderlyingSinkAbortCallback;\n    type?: undefined;\n}\n\n/** @public */\nexport declare type UnderlyingSinkAbortCallback = (\n    reason: unknown,\n) => void | PromiseLike<void>;\n\n/** @public */\nexport declare type UnderlyingSinkCloseCallback =\n    () => void | PromiseLike<void>;\n\n/** @public */\nexport declare type UnderlyingSinkStartCallback = (\n    controller: WritableStreamDefaultController,\n) => void | PromiseLike<void>;\n\n/** @public */\nexport declare type UnderlyingSinkWriteCallback<W> = (\n    chunk: W,\n    controller: WritableStreamDefaultController,\n) => void | PromiseLike<void>;\n\n/**\n * An underlying source for constructing a {@link ReadableStream}.\n *\n * @public\n */\nexport declare interface UnderlyingSource<R> {\n    /**\n     * A function that is called immediately during creation of the {@link ReadableStream}.\n     */\n    start?: UnderlyingSourceStartCallback<R>;\n    /**\n     * A function that is called whenever the streams internal queue of chunks becomes not full,\n     * i.e. whenever the queues desired size becomes positive. Generally, it will be called repeatedly\n     * until the queue reaches its high water mark (i.e. until the desired size becomes non-positive).\n     */\n    pull?: UnderlyingSourcePullCallback<R>;\n    /**\n     * A function that is called whenever the consumer cancels the stream, via\n     * {@link ReadableStream.cancel | stream.cancel()},\n     * {@link ReadableStreamDefaultReader.cancel | defaultReader.cancel()}, or\n     * {@link ReadableStreamBYOBReader.cancel | byobReader.cancel()}.\n     * It takes as its argument the same value as was passed to those methods by the consumer.\n     */\n    cancel?: UnderlyingSourceCancelCallback;\n    type?: undefined;\n}\n\n/** @public */\nexport declare type UnderlyingSourceCancelCallback = (\n    reason: unknown,\n) => void | PromiseLike<void>;\n\n/** @public */\nexport declare type UnderlyingSourcePullCallback<R> = (\n    controller: ReadableStreamDefaultController<R>,\n) => void | PromiseLike<void>;\n\n/** @public */\nexport declare type UnderlyingSourceStartCallback<R> = (\n    controller: ReadableStreamDefaultController<R>,\n) => void | PromiseLike<void>;\n\n/**\n * A writable stream represents a destination for data, into which you can write.\n *\n * @public\n */\nexport declare class WritableStream<in W> {\n    constructor(\n        underlyingSink?: UnderlyingSink<W>,\n        strategy?: QueuingStrategy<W>,\n    );\n    /**\n     * Returns whether or not the writable stream is locked to a writer.\n     */\n    get locked(): boolean;\n    /**\n     * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be\n     * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort\n     * mechanism of the underlying sink.\n     *\n     * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled\n     * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel\n     * the stream) if the stream is currently locked.\n     */\n    abort(reason?: unknown): Promise<void>;\n    /**\n     * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its\n     * close behavior. During this time any further attempts to write will fail (without erroring the stream).\n     *\n     * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream\n     * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with\n     * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.\n     */\n    close(): Promise<undefined>;\n    /**\n     * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream\n     * is locked, no other writer can be acquired until this one is released.\n     *\n     * This functionality is especially useful for creating abstractions that desire the ability to write to a stream\n     * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at\n     * the same time, which would cause the resulting written data to be unpredictable and probably useless.\n     */\n    getWriter(): WritableStreamDefaultWriter<W>;\n}\n\n/**\n * Allows control of a {@link WritableStream | writable stream}'s state and internal queue.\n *\n * @public\n */\nexport declare class WritableStreamDefaultController {\n    private constructor();\n    /**\n     * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.\n     *\n     * @deprecated\n     *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.\n     *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.\n     */\n    get abortReason(): unknown;\n    /**\n     * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.\n     */\n    get signal(): AbortSignal;\n    /**\n     * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.\n     *\n     * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying\n     * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the\n     * normal lifecycle of interactions with the underlying sink.\n     */\n    error(e?: unknown): void;\n}\n\n/**\n * A default writer vended by a {@link WritableStream}.\n *\n * @public\n */\nexport declare class WritableStreamDefaultWriter<in W> {\n    constructor(stream: WritableStream<W>);\n    /**\n     * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n     * the writers lock is released before the stream finishes closing.\n     */\n    get closed(): Promise<undefined>;\n    /**\n     * Returns the desired size to fill the streams internal queue. It can be negative, if the queue is over-full.\n     * A producer can use this information to determine the right amount of data to write.\n     *\n     * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort\n     * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when\n     * the writers lock is released.\n     */\n    get desiredSize(): number | null;\n    /**\n     * Returns a promise that will be fulfilled when the desired size to fill the streams internal queue transitions\n     * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips\n     * back to zero or below, the getter will return a new promise that stays pending until the next transition.\n     *\n     * If the stream becomes errored or aborted, or the writers lock is released, the returned promise will become\n     * rejected.\n     */\n    get ready(): Promise<undefined>;\n    /**\n     * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.\n     */\n    abort(reason?: unknown): Promise<void>;\n    /**\n     * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.\n     */\n    close(): Promise<void>;\n    /**\n     * Releases the writers lock on the corresponding stream. After the lock is released, the writer is no longer active.\n     * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from\n     * now on; otherwise, the writer will appear closed.\n     *\n     * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n     * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n     * Its not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n     * other producers from writing in an interleaved manner.\n     */\n    releaseLock(): void;\n    /**\n     * Writes the given chunk to the writable stream, by waiting until any previous writes have finished successfully,\n     * and then sending the chunk to the underlying sink's {@link UnderlyingSink.write | write()} method. It will return\n     * a promise that fulfills with undefined upon a successful write, or rejects if the write fails or stream becomes\n     * errored before the writing process is initiated.\n     *\n     * Note that what \"success\" means is up to the underlying sink; it might indicate simply that the chunk has been\n     * accepted, and not necessarily that it is safely saved to its ultimate destination.\n     */\n    write(chunk: W): Promise<void>;\n}\n\nexport {};\n","import { PromiseResolver } from \"@yume-chan/async\";\nimport { EMPTY_UINT8_ARRAY } from \"@yume-chan/struct\";\nimport { ReadableStream, WritableStream } from \"./stream.js\";\n// `TransformStream` only calls its `source.flush` method when its `readable` is being read.\n// If the user want to use the `Promise` interface, the `flush` method will never be called,\n// so the `PromiseResolver` will never be resolved.\n// Thus we need to implement our own `TransformStream` using a `WritableStream` and a `ReadableStream`.\n/**\n * A `TransformStream` that concatenates strings.\n *\n * Its `readable` is also a `Promise<string>`, so it's possible to `await` it to get the result.\n *\n * ```ts\n * const result: string = await readable.pipeThrough(new ConcatStringStream());\n * ```\n */\nexport class ConcatStringStream {\n    // PERF: rope (concat strings) is faster than `[].join('')`\n    #result = \"\";\n    #resolver = new PromiseResolver();\n    #writable = new WritableStream({\n        write: (chunk) => {\n            this.#result += chunk;\n        },\n        close: () => {\n            this.#resolver.resolve(this.#result);\n            this.#readableController.enqueue(this.#result);\n            this.#readableController.close();\n        },\n        abort: (reason) => {\n            this.#resolver.reject(reason);\n            this.#readableController.error(reason);\n        },\n    });\n    get writable() {\n        return this.#writable;\n    }\n    #readableController;\n    #readable = new ReadableStream({\n        start: (controller) => {\n            this.#readableController = controller;\n        },\n    });\n    get readable() {\n        return this.#readable;\n    }\n    constructor() {\n        void Object.defineProperties(this.#readable, {\n            then: {\n                get: () => this.#resolver.promise.then.bind(this.#resolver.promise),\n            },\n            catch: {\n                get: () => this.#resolver.promise.catch.bind(this.#resolver.promise),\n            },\n            finally: {\n                get: () => this.#resolver.promise.finally.bind(this.#resolver.promise),\n            },\n        });\n    }\n}\n/**\n * A `TransformStream` that concatenates `Uint8Array`s.\n *\n * If you want to decode the result as string,\n * prefer `.pipeThrough(new TextDecoderStream()).pipeThrough(new ConcatStringStream())`,\n * than `.pipeThough(new ConcatBufferStream()).pipeThrough(new TextDecoderStream())`,\n * because of JavaScript engine optimizations,\n * concatenating strings is faster than concatenating `Uint8Array`s.\n */\nexport class ConcatBufferStream {\n    #segments = [];\n    #resolver = new PromiseResolver();\n    #writable = new WritableStream({\n        write: (chunk) => {\n            this.#segments.push(chunk);\n        },\n        close: () => {\n            let result;\n            let offset = 0;\n            switch (this.#segments.length) {\n                case 0:\n                    result = EMPTY_UINT8_ARRAY;\n                    break;\n                case 1:\n                    result = this.#segments[0];\n                    break;\n                default:\n                    result = new Uint8Array(this.#segments.reduce((prev, item) => prev + item.length, 0));\n                    for (const segment of this.#segments) {\n                        result.set(segment, offset);\n                        offset += segment.length;\n                    }\n                    break;\n            }\n            this.#resolver.resolve(result);\n            this.#readableController.enqueue(result);\n            this.#readableController.close();\n        },\n        abort: (reason) => {\n            this.#resolver.reject(reason);\n            this.#readableController.error(reason);\n        },\n    });\n    get writable() {\n        return this.#writable;\n    }\n    #readableController;\n    #readable = new ReadableStream({\n        start: (controller) => {\n            this.#readableController = controller;\n        },\n    });\n    get readable() {\n        return this.#readable;\n    }\n    constructor() {\n        void Object.defineProperties(this.#readable, {\n            then: {\n                get: () => this.#resolver.promise.then.bind(this.#resolver.promise),\n            },\n            catch: {\n                get: () => this.#resolver.promise.catch.bind(this.#resolver.promise),\n            },\n            finally: {\n                get: () => this.#resolver.promise.finally.bind(this.#resolver.promise),\n            },\n        });\n    }\n}\n//# sourceMappingURL=concat.js.map","import { PromiseResolver } from \"@yume-chan/async\";\nimport { EMPTY_UINT8_ARRAY } from \"@yume-chan/struct\";\n\nimport type { ReadableStreamDefaultController } from \"./stream.js\";\nimport { ReadableStream, WritableStream } from \"./stream.js\";\n\nexport interface ConcatStringReadableStream\n    extends ReadableStream<string>,\n        Promise<string> {}\n\n// `TransformStream` only calls its `source.flush` method when its `readable` is being read.\n// If the user want to use the `Promise` interface, the `flush` method will never be called,\n// so the `PromiseResolver` will never be resolved.\n// Thus we need to implement our own `TransformStream` using a `WritableStream` and a `ReadableStream`.\n\n/**\n * A `TransformStream` that concatenates strings.\n *\n * Its `readable` is also a `Promise<string>`, so it's possible to `await` it to get the result.\n *\n * ```ts\n * const result: string = await readable.pipeThrough(new ConcatStringStream());\n * ```\n */\nexport class ConcatStringStream {\n    // PERF: rope (concat strings) is faster than `[].join('')`\n    #result = \"\";\n\n    #resolver = new PromiseResolver<string>();\n\n    #writable = new WritableStream<string>({\n        write: (chunk) => {\n            this.#result += chunk;\n        },\n        close: () => {\n            this.#resolver.resolve(this.#result);\n            this.#readableController.enqueue(this.#result);\n            this.#readableController.close();\n        },\n        abort: (reason) => {\n            this.#resolver.reject(reason);\n            this.#readableController.error(reason);\n        },\n    });\n    get writable(): WritableStream<string> {\n        return this.#writable;\n    }\n\n    #readableController!: ReadableStreamDefaultController<string>;\n    #readable = new ReadableStream<string>({\n        start: (controller) => {\n            this.#readableController = controller;\n        },\n    }) as ConcatStringReadableStream;\n    get readable(): ConcatStringReadableStream {\n        return this.#readable;\n    }\n\n    constructor() {\n        void Object.defineProperties(this.#readable, {\n            then: {\n                get: () =>\n                    this.#resolver.promise.then.bind(this.#resolver.promise),\n            },\n            catch: {\n                get: () =>\n                    this.#resolver.promise.catch.bind(this.#resolver.promise),\n            },\n            finally: {\n                get: () =>\n                    this.#resolver.promise.finally.bind(this.#resolver.promise),\n            },\n        });\n    }\n}\n\nexport interface ConcatBufferReadableStream\n    extends ReadableStream<Uint8Array>,\n        Promise<Uint8Array> {}\n\n/**\n * A `TransformStream` that concatenates `Uint8Array`s.\n *\n * If you want to decode the result as string,\n * prefer `.pipeThrough(new TextDecoderStream()).pipeThrough(new ConcatStringStream())`,\n * than `.pipeThough(new ConcatBufferStream()).pipeThrough(new TextDecoderStream())`,\n * because of JavaScript engine optimizations,\n * concatenating strings is faster than concatenating `Uint8Array`s.\n */\nexport class ConcatBufferStream {\n    #segments: Uint8Array[] = [];\n\n    #resolver = new PromiseResolver<Uint8Array>();\n\n    #writable = new WritableStream<Uint8Array>({\n        write: (chunk) => {\n            this.#segments.push(chunk);\n        },\n        close: () => {\n            let result: Uint8Array;\n            let offset = 0;\n            switch (this.#segments.length) {\n                case 0:\n                    result = EMPTY_UINT8_ARRAY;\n                    break;\n                case 1:\n                    result = this.#segments[0]!;\n                    break;\n                default:\n                    result = new Uint8Array(\n                        this.#segments.reduce(\n                            (prev, item) => prev + item.length,\n                            0,\n                        ),\n                    );\n                    for (const segment of this.#segments) {\n                        result.set(segment, offset);\n                        offset += segment.length;\n                    }\n                    break;\n            }\n\n            this.#resolver.resolve(result);\n            this.#readableController.enqueue(result);\n            this.#readableController.close();\n        },\n        abort: (reason) => {\n            this.#resolver.reject(reason);\n            this.#readableController.error(reason);\n        },\n    });\n    get writable(): WritableStream<Uint8Array> {\n        return this.#writable;\n    }\n\n    #readableController!: ReadableStreamDefaultController<Uint8Array>;\n    #readable = new ReadableStream<Uint8Array>({\n        start: (controller) => {\n            this.#readableController = controller;\n        },\n    }) as ConcatBufferReadableStream;\n    get readable(): ConcatBufferReadableStream {\n        return this.#readable;\n    }\n\n    constructor() {\n        void Object.defineProperties(this.#readable, {\n            then: {\n                get: () =>\n                    this.#resolver.promise.then.bind(this.#resolver.promise),\n            },\n            catch: {\n                get: () =>\n                    this.#resolver.promise.catch.bind(this.#resolver.promise),\n            },\n            finally: {\n                get: () =>\n                    this.#resolver.promise.finally.bind(this.#resolver.promise),\n            },\n        });\n    }\n}\n","import { PromiseResolver } from \"@yume-chan/async\";\nimport { ReadableStream as NativeReadableStream, WritableStream as NativeWritableStream, } from \"./stream.js\";\nimport { createTask } from \"./task.js\";\nfunction isPromiseLike(value) {\n    return typeof value === \"object\" && value !== null && \"then\" in value;\n}\nexport class Consumable {\n    #task;\n    #resolver;\n    value;\n    consumed;\n    constructor(value) {\n        this.#task = createTask(\"Consumable\");\n        this.value = value;\n        this.#resolver = new PromiseResolver();\n        this.consumed = this.#resolver.promise;\n    }\n    consume() {\n        this.#resolver.resolve();\n    }\n    error(error) {\n        this.#resolver.reject(error);\n    }\n    tryConsume(callback) {\n        try {\n            let result = this.#task.run(() => callback(this.value));\n            if (isPromiseLike(result)) {\n                result = result.then((value) => {\n                    this.#resolver.resolve();\n                    return value;\n                }, (e) => {\n                    this.#resolver.reject(e);\n                    throw e;\n                });\n            }\n            else {\n                this.#resolver.resolve();\n            }\n            return result;\n        }\n        catch (e) {\n            this.#resolver.reject(e);\n            throw e;\n        }\n    }\n}\n(function (Consumable) {\n    class WritableStream extends NativeWritableStream {\n        static async write(writer, value) {\n            const consumable = new Consumable(value);\n            await writer.write(consumable);\n            await consumable.consumed;\n        }\n        constructor(sink, strategy) {\n            let wrappedStrategy;\n            if (strategy) {\n                wrappedStrategy = {};\n                if (\"highWaterMark\" in strategy) {\n                    wrappedStrategy.highWaterMark = strategy.highWaterMark;\n                }\n                if (\"size\" in strategy) {\n                    wrappedStrategy.size = (chunk) => {\n                        return strategy.size(chunk instanceof Consumable ? chunk.value : chunk);\n                    };\n                }\n            }\n            super({\n                start(controller) {\n                    return sink.start?.(controller);\n                },\n                async write(chunk, controller) {\n                    await chunk.tryConsume((chunk) => sink.write?.(chunk, controller));\n                },\n                abort(reason) {\n                    return sink.abort?.(reason);\n                },\n                close() {\n                    return sink.close?.();\n                },\n            }, wrappedStrategy);\n        }\n    }\n    Consumable.WritableStream = WritableStream;\n    class ReadableStream extends NativeReadableStream {\n        static async enqueue(controller, chunk) {\n            const output = new Consumable(chunk);\n            controller.enqueue(output);\n            await output.consumed;\n        }\n        constructor(source, strategy) {\n            let wrappedController;\n            let wrappedStrategy;\n            if (strategy) {\n                wrappedStrategy = {};\n                if (\"highWaterMark\" in strategy) {\n                    wrappedStrategy.highWaterMark = strategy.highWaterMark;\n                }\n                if (\"size\" in strategy) {\n                    wrappedStrategy.size = (chunk) => {\n                        return strategy.size(chunk.value);\n                    };\n                }\n            }\n            super({\n                async start(controller) {\n                    wrappedController = {\n                        async enqueue(chunk) {\n                            await ReadableStream.enqueue(controller, chunk);\n                        },\n                        close() {\n                            controller.close();\n                        },\n                        error(reason) {\n                            controller.error(reason);\n                        },\n                    };\n                    await source.start?.(wrappedController);\n                },\n                async pull() {\n                    await source.pull?.(wrappedController);\n                },\n                async cancel(reason) {\n                    await source.cancel?.(reason);\n                },\n            }, wrappedStrategy);\n        }\n    }\n    Consumable.ReadableStream = ReadableStream;\n})(Consumable || (Consumable = {}));\n//# sourceMappingURL=consumable.js.map","import { PromiseResolver } from \"@yume-chan/async\";\n\nimport type {\n    QueuingStrategy,\n    WritableStreamDefaultController,\n    WritableStreamDefaultWriter,\n} from \"./stream.js\";\nimport {\n    ReadableStream as NativeReadableStream,\n    WritableStream as NativeWritableStream,\n} from \"./stream.js\";\nimport type { Task } from \"./task.js\";\nimport { createTask } from \"./task.js\";\n\nfunction isPromiseLike(value: unknown): value is PromiseLike<unknown> {\n    return typeof value === \"object\" && value !== null && \"then\" in value;\n}\n\nexport class Consumable<T> {\n    readonly #task: Task;\n    readonly #resolver: PromiseResolver<void>;\n\n    readonly value: T;\n    readonly consumed: Promise<void>;\n\n    constructor(value: T) {\n        this.#task = createTask(\"Consumable\");\n        this.value = value;\n        this.#resolver = new PromiseResolver<void>();\n        this.consumed = this.#resolver.promise;\n    }\n\n    consume() {\n        this.#resolver.resolve();\n    }\n\n    error(error: unknown) {\n        this.#resolver.reject(error);\n    }\n\n    tryConsume<U>(callback: (value: T) => U) {\n        try {\n            let result = this.#task.run(() => callback(this.value));\n            if (isPromiseLike(result)) {\n                result = result.then(\n                    (value) => {\n                        this.#resolver.resolve();\n                        return value;\n                    },\n                    (e) => {\n                        this.#resolver.reject(e);\n                        throw e;\n                    },\n                ) as U;\n            } else {\n                this.#resolver.resolve();\n            }\n            return result;\n        } catch (e) {\n            this.#resolver.reject(e);\n            throw e;\n        }\n    }\n}\n\nexport namespace Consumable {\n    export interface WritableStreamSink<in T> {\n        start?(\n            controller: WritableStreamDefaultController,\n        ): void | PromiseLike<void>;\n        write?(\n            chunk: T,\n            controller: WritableStreamDefaultController,\n        ): void | PromiseLike<void>;\n        abort?(reason: unknown): void | PromiseLike<void>;\n        close?(): void | PromiseLike<void>;\n    }\n\n    export class WritableStream<in T> extends NativeWritableStream<\n        Consumable<T>\n    > {\n        static async write<T>(\n            writer: WritableStreamDefaultWriter<Consumable<T>>,\n            value: T,\n        ) {\n            const consumable = new Consumable(value);\n            await writer.write(consumable);\n            await consumable.consumed;\n        }\n\n        constructor(\n            sink: WritableStreamSink<T>,\n            strategy?: QueuingStrategy<T>,\n        ) {\n            let wrappedStrategy: QueuingStrategy<Consumable<T>> | undefined;\n            if (strategy) {\n                wrappedStrategy = {};\n                if (\"highWaterMark\" in strategy) {\n                    wrappedStrategy.highWaterMark = strategy.highWaterMark;\n                }\n                if (\"size\" in strategy) {\n                    wrappedStrategy.size = (chunk) => {\n                        return strategy.size!(\n                            chunk instanceof Consumable ? chunk.value : chunk,\n                        );\n                    };\n                }\n            }\n\n            super(\n                {\n                    start(controller) {\n                        return sink.start?.(controller);\n                    },\n                    async write(chunk, controller) {\n                        await chunk.tryConsume((chunk) =>\n                            sink.write?.(chunk, controller),\n                        );\n                    },\n                    abort(reason) {\n                        return sink.abort?.(reason);\n                    },\n                    close() {\n                        return sink.close?.();\n                    },\n                },\n                wrappedStrategy,\n            );\n        }\n    }\n\n    export interface ReadableStreamController<T> {\n        enqueue(chunk: T): Promise<void>;\n        close(): void;\n        error(reason: unknown): void;\n    }\n\n    export interface ReadableStreamSource<T> {\n        start?(\n            controller: ReadableStreamController<T>,\n        ): void | PromiseLike<void>;\n        pull?(\n            controller: ReadableStreamController<T>,\n        ): void | PromiseLike<void>;\n        cancel?(reason: unknown): void | PromiseLike<void>;\n    }\n\n    export class ReadableStream<T> extends NativeReadableStream<Consumable<T>> {\n        static async enqueue<T>(\n            controller: { enqueue: (chunk: Consumable<T>) => void },\n            chunk: T,\n        ) {\n            const output = new Consumable(chunk);\n            controller.enqueue(output);\n            await output.consumed;\n        }\n\n        constructor(\n            source: ReadableStreamSource<T>,\n            strategy?: QueuingStrategy<T>,\n        ) {\n            let wrappedController: ReadableStreamController<T> | undefined;\n\n            let wrappedStrategy: QueuingStrategy<Consumable<T>> | undefined;\n            if (strategy) {\n                wrappedStrategy = {};\n                if (\"highWaterMark\" in strategy) {\n                    wrappedStrategy.highWaterMark = strategy.highWaterMark;\n                }\n                if (\"size\" in strategy) {\n                    wrappedStrategy.size = (chunk) => {\n                        return strategy.size!(chunk.value);\n                    };\n                }\n            }\n\n            super(\n                {\n                    async start(controller) {\n                        wrappedController = {\n                            async enqueue(chunk) {\n                                await ReadableStream.enqueue(controller, chunk);\n                            },\n                            close() {\n                                controller.close();\n                            },\n                            error(reason) {\n                                controller.error(reason);\n                            },\n                        };\n\n                        await source.start?.(wrappedController);\n                    },\n                    async pull() {\n                        await source.pull?.(wrappedController!);\n                    },\n                    async cancel(reason) {\n                        await source.cancel?.(reason);\n                    },\n                },\n                wrappedStrategy,\n            );\n        }\n    }\n}\n","// `createTask` allows browser DevTools to track the call stack across async boundaries.\nconst { console } = globalThis;\nexport const createTask = console?.createTask?.bind(console) ??\n    (() => ({\n        run(callback) {\n            return callback();\n        },\n    }));\n//# sourceMappingURL=task.js.map","export interface Task {\n    run<T>(callback: () => T): T;\n}\n\ninterface Console {\n    createTask(name: string): Task;\n}\n\ninterface GlobalExtension {\n    console?: Console;\n}\n\n// `createTask` allows browser DevTools to track the call stack across async boundaries.\nconst { console } = globalThis as unknown as GlobalExtension;\nexport const createTask: (name: string) => Task =\n    console?.createTask?.bind(console) ??\n    (() => ({\n        run(callback) {\n            return callback();\n        },\n    }));\n","import { Consumable } from \"./consumable.js\";\nimport { MaybeConsumable } from \"./maybe-consumable.js\";\nimport { TransformStream } from \"./stream.js\";\n/**\n * Splits or combines buffers to specified size.\n */\nexport class BufferCombiner {\n    #capacity;\n    #buffer;\n    #offset;\n    #available;\n    constructor(size) {\n        this.#capacity = size;\n        this.#buffer = new Uint8Array(size);\n        this.#offset = 0;\n        this.#available = size;\n    }\n    /**\n     * Pushes data to the combiner.\n     * @param data The input data to be split or combined.\n     * @returns\n     * A generator that yields buffers of specified size.\n     * It may yield the same buffer multiple times, consume the data before calling `next`.\n     */\n    *push(data) {\n        let offset = 0;\n        let available = data.length;\n        if (this.#offset !== 0) {\n            if (available >= this.#available) {\n                this.#buffer.set(data.subarray(0, this.#available), this.#offset);\n                offset += this.#available;\n                available -= this.#available;\n                yield this.#buffer;\n                this.#offset = 0;\n                this.#available = this.#capacity;\n                if (available === 0) {\n                    return;\n                }\n            }\n            else {\n                this.#buffer.set(data, this.#offset);\n                this.#offset += available;\n                this.#available -= available;\n                return;\n            }\n        }\n        while (available >= this.#capacity) {\n            const end = offset + this.#capacity;\n            yield data.subarray(offset, end);\n            offset = end;\n            available -= this.#capacity;\n        }\n        if (available > 0) {\n            this.#buffer.set(data.subarray(offset), this.#offset);\n            this.#offset += available;\n            this.#available -= available;\n        }\n    }\n    flush() {\n        if (this.#offset === 0) {\n            return undefined;\n        }\n        const output = this.#buffer.subarray(0, this.#offset);\n        this.#offset = 0;\n        this.#available = this.#capacity;\n        return output;\n    }\n}\nexport class DistributionStream extends TransformStream {\n    constructor(size, combine = false) {\n        const combiner = combine ? new BufferCombiner(size) : undefined;\n        super({\n            async transform(chunk, controller) {\n                await MaybeConsumable.tryConsume(chunk, async (chunk) => {\n                    if (combiner) {\n                        for (const buffer of combiner.push(chunk)) {\n                            await Consumable.ReadableStream.enqueue(controller, buffer);\n                        }\n                    }\n                    else {\n                        let offset = 0;\n                        let available = chunk.length;\n                        while (available > 0) {\n                            const end = offset + size;\n                            await Consumable.ReadableStream.enqueue(controller, chunk.subarray(offset, end));\n                            offset = end;\n                            available -= size;\n                        }\n                    }\n                });\n            },\n            flush(controller) {\n                if (combiner) {\n                    const data = combiner.flush();\n                    if (data) {\n                        controller.enqueue(data);\n                    }\n                }\n            },\n        });\n    }\n}\n//# sourceMappingURL=distribution.js.map","import { Consumable } from \"./consumable.js\";\nimport { MaybeConsumable } from \"./maybe-consumable.js\";\nimport { TransformStream } from \"./stream.js\";\n\n/**\n * Splits or combines buffers to specified size.\n */\nexport class BufferCombiner {\n    #capacity: number;\n    readonly #buffer: Uint8Array;\n    #offset: number;\n    #available: number;\n\n    constructor(size: number) {\n        this.#capacity = size;\n        this.#buffer = new Uint8Array(size);\n        this.#offset = 0;\n        this.#available = size;\n    }\n\n    /**\n     * Pushes data to the combiner.\n     * @param data The input data to be split or combined.\n     * @returns\n     * A generator that yields buffers of specified size.\n     * It may yield the same buffer multiple times, consume the data before calling `next`.\n     */\n    *push(data: Uint8Array): Generator<Uint8Array, void, void> {\n        let offset = 0;\n        let available = data.length;\n\n        if (this.#offset !== 0) {\n            if (available >= this.#available) {\n                this.#buffer.set(\n                    data.subarray(0, this.#available),\n                    this.#offset,\n                );\n                offset += this.#available;\n                available -= this.#available;\n\n                yield this.#buffer;\n                this.#offset = 0;\n                this.#available = this.#capacity;\n\n                if (available === 0) {\n                    return;\n                }\n            } else {\n                this.#buffer.set(data, this.#offset);\n                this.#offset += available;\n                this.#available -= available;\n                return;\n            }\n        }\n\n        while (available >= this.#capacity) {\n            const end = offset + this.#capacity;\n            yield data.subarray(offset, end);\n            offset = end;\n            available -= this.#capacity;\n        }\n\n        if (available > 0) {\n            this.#buffer.set(data.subarray(offset), this.#offset);\n            this.#offset += available;\n            this.#available -= available;\n        }\n    }\n\n    flush(): Uint8Array | undefined {\n        if (this.#offset === 0) {\n            return undefined;\n        }\n\n        const output = this.#buffer.subarray(0, this.#offset);\n        this.#offset = 0;\n        this.#available = this.#capacity;\n        return output;\n    }\n}\n\nexport class DistributionStream extends TransformStream<\n    MaybeConsumable<Uint8Array>,\n    MaybeConsumable<Uint8Array>\n> {\n    constructor(size: number, combine = false) {\n        const combiner = combine ? new BufferCombiner(size) : undefined;\n        super({\n            async transform(chunk, controller) {\n                await MaybeConsumable.tryConsume(chunk, async (chunk) => {\n                    if (combiner) {\n                        for (const buffer of combiner.push(chunk)) {\n                            await Consumable.ReadableStream.enqueue(\n                                controller,\n                                buffer,\n                            );\n                        }\n                    } else {\n                        let offset = 0;\n                        let available = chunk.length;\n                        while (available > 0) {\n                            const end = offset + size;\n                            await Consumable.ReadableStream.enqueue(\n                                controller,\n                                chunk.subarray(offset, end),\n                            );\n                            offset = end;\n                            available -= size;\n                        }\n                    }\n                });\n            },\n            flush(controller) {\n                if (combiner) {\n                    const data = combiner.flush();\n                    if (data) {\n                        controller.enqueue(data);\n                    }\n                }\n            },\n        });\n    }\n}\n","import { Consumable } from \"./consumable.js\";\nimport { WritableStream as NativeWritableStream, TransformStream, } from \"./stream.js\";\nexport var MaybeConsumable;\n(function (MaybeConsumable) {\n    function getValue(value) {\n        return value instanceof Consumable ? value.value : value;\n    }\n    MaybeConsumable.getValue = getValue;\n    function tryConsume(value, callback) {\n        if (value instanceof Consumable) {\n            return value.tryConsume(callback);\n        }\n        else {\n            return callback(value);\n        }\n    }\n    MaybeConsumable.tryConsume = tryConsume;\n    class UnwrapStream extends TransformStream {\n        constructor() {\n            super({\n                transform(chunk, controller) {\n                    MaybeConsumable.tryConsume(chunk, (chunk) => {\n                        controller.enqueue(chunk);\n                    });\n                },\n            });\n        }\n    }\n    MaybeConsumable.UnwrapStream = UnwrapStream;\n    class WritableStream extends NativeWritableStream {\n        constructor(sink, strategy) {\n            let wrappedStrategy;\n            if (strategy) {\n                wrappedStrategy = {};\n                if (\"highWaterMark\" in strategy) {\n                    wrappedStrategy.highWaterMark = strategy.highWaterMark;\n                }\n                if (\"size\" in strategy) {\n                    wrappedStrategy.size = (chunk) => {\n                        return strategy.size(chunk instanceof Consumable ? chunk.value : chunk);\n                    };\n                }\n            }\n            super({\n                start(controller) {\n                    return sink.start?.(controller);\n                },\n                async write(chunk, controller) {\n                    await MaybeConsumable.tryConsume(chunk, (chunk) => sink.write?.(chunk, controller));\n                },\n                abort(reason) {\n                    return sink.abort?.(reason);\n                },\n                close() {\n                    return sink.close?.();\n                },\n            }, wrappedStrategy);\n        }\n    }\n    MaybeConsumable.WritableStream = WritableStream;\n})(MaybeConsumable || (MaybeConsumable = {}));\n//# sourceMappingURL=maybe-consumable.js.map","import { Consumable } from \"./consumable.js\";\nimport type {\n    QueuingStrategy,\n    WritableStreamDefaultController,\n} from \"./stream.js\";\nimport {\n    WritableStream as NativeWritableStream,\n    TransformStream,\n} from \"./stream.js\";\n\nexport type MaybeConsumable<T> = T | Consumable<T>;\n\nexport namespace MaybeConsumable {\n    export function getValue<T>(value: MaybeConsumable<T>): T {\n        return value instanceof Consumable ? value.value : value;\n    }\n\n    export function tryConsume<T, R>(\n        value: T,\n        callback: (value: T extends Consumable<infer U> ? U : T) => R,\n    ): R {\n        if (value instanceof Consumable) {\n            return value.tryConsume(callback);\n        } else {\n            return callback(value as never);\n        }\n    }\n\n    export class UnwrapStream<T> extends TransformStream<\n        MaybeConsumable<T>,\n        T\n    > {\n        constructor() {\n            super({\n                transform(chunk, controller) {\n                    MaybeConsumable.tryConsume(chunk, (chunk) => {\n                        controller.enqueue(chunk as T);\n                    });\n                },\n            });\n        }\n    }\n\n    export interface WritableStreamSink<in T> {\n        start?(\n            controller: WritableStreamDefaultController,\n        ): void | PromiseLike<void>;\n        write?(\n            chunk: T,\n            controller: WritableStreamDefaultController,\n        ): void | PromiseLike<void>;\n        abort?(reason: unknown): void | PromiseLike<void>;\n        close?(): void | PromiseLike<void>;\n    }\n\n    export class WritableStream<in T> extends NativeWritableStream<\n        MaybeConsumable<T>\n    > {\n        constructor(\n            sink: WritableStreamSink<T>,\n            strategy?: QueuingStrategy<T>,\n        ) {\n            let wrappedStrategy:\n                | QueuingStrategy<MaybeConsumable<T>>\n                | undefined;\n            if (strategy) {\n                wrappedStrategy = {};\n                if (\"highWaterMark\" in strategy) {\n                    wrappedStrategy.highWaterMark = strategy.highWaterMark;\n                }\n                if (\"size\" in strategy) {\n                    wrappedStrategy.size = (chunk) => {\n                        return strategy.size!(\n                            chunk instanceof Consumable ? chunk.value : chunk,\n                        );\n                    };\n                }\n            }\n\n            super(\n                {\n                    start(controller) {\n                        return sink.start?.(controller);\n                    },\n                    async write(chunk, controller) {\n                        await MaybeConsumable.tryConsume(chunk, (chunk) =>\n                            sink.write?.(chunk as T, controller),\n                        );\n                    },\n                    abort(reason) {\n                        return sink.abort?.(reason);\n                    },\n                    close() {\n                        return sink.close?.();\n                    },\n                },\n                wrappedStrategy,\n            );\n        }\n    }\n}\n","import { PromiseResolver } from \"@yume-chan/async\";\nimport { WritableStream } from \"./stream.js\";\nimport { WrapReadableStream } from \"./wrap-readable.js\";\nconst NOOP = () => {\n    // no-op\n};\n/**\n * A factory for creating a duplex stream.\n *\n * It can create multiple `ReadableStream`s and `WritableStream`s,\n * when any of them is closed, all other streams will be closed as well.\n */\nexport class DuplexStreamFactory {\n    #readableControllers = [];\n    #writers = [];\n    #writableClosed = false;\n    get writableClosed() {\n        return this.#writableClosed;\n    }\n    #closed = new PromiseResolver();\n    get closed() {\n        return this.#closed.promise;\n    }\n    #options;\n    constructor(options) {\n        this.#options = options ?? {};\n    }\n    wrapReadable(readable, strategy) {\n        return new WrapReadableStream({\n            start: (controller) => {\n                this.#readableControllers.push(controller);\n                return readable;\n            },\n            cancel: async () => {\n                // cancel means the local peer wants to close the connection.\n                await this.close();\n            },\n            close: async () => {\n                // stream end means the remote peer closed the connection first.\n                await this.dispose();\n            },\n        }, strategy);\n    }\n    createWritable(stream) {\n        const writer = stream.getWriter();\n        this.#writers.push(writer);\n        // `WritableStream` has no way to tell if the remote peer has closed the connection.\n        // So it only triggers `close`.\n        return new WritableStream({\n            write: async (chunk) => {\n                await writer.write(chunk);\n            },\n            abort: async (reason) => {\n                await writer.abort(reason);\n                await this.close();\n            },\n            close: async () => {\n                // NOOP: the writer is already closed\n                await writer.close().catch(NOOP);\n                await this.close();\n            },\n        });\n    }\n    async close() {\n        if (this.#writableClosed) {\n            return;\n        }\n        this.#writableClosed = true;\n        // Call `close` first, so it can still write data to `WritableStream`s.\n        if ((await this.#options.close?.()) !== false) {\n            // `close` can return `false` to disable automatic `dispose`.\n            await this.dispose();\n        }\n        for (const writer of this.#writers) {\n            // NOOP: the writer is already closed\n            writer.close().catch(NOOP);\n        }\n    }\n    async dispose() {\n        this.#writableClosed = true;\n        this.#closed.resolve();\n        for (const controller of this.#readableControllers) {\n            try {\n                controller.close();\n            }\n            catch {\n                // ignore\n            }\n        }\n        await this.#options.dispose?.();\n    }\n}\n//# sourceMappingURL=duplex.js.map","import { PromiseResolver } from \"@yume-chan/async\";\nimport type { ValueOrPromise } from \"@yume-chan/struct\";\n\nimport type {\n    QueuingStrategy,\n    ReadableStream,\n    ReadableStreamDefaultController,\n    WritableStreamDefaultWriter,\n} from \"./stream.js\";\nimport { WritableStream } from \"./stream.js\";\nimport { WrapReadableStream } from \"./wrap-readable.js\";\n\nconst NOOP = () => {\n    // no-op\n};\n\nexport interface DuplexStreamFactoryOptions {\n    /**\n     * Callback when any `ReadableStream` is cancelled (the user doesn't need any more data),\n     * or `WritableStream` is ended (the user won't produce any more data),\n     * or `DuplexStreamFactory#close` is called.\n     *\n     * Usually you want to let the other peer know that the duplex stream should be closed.\n     *\n     * `dispose` will automatically be called after `close` completes,\n     * but if you want to wait another peer for a close confirmation and call\n     * `DuplexStreamFactory#dispose` yourself, you can return `false`\n     * (or a `Promise` that resolves to `false`) to disable the automatic call.\n     */\n    close?: (() => ValueOrPromise<boolean | void>) | undefined;\n\n    /**\n     * Callback when any `ReadableStream` is closed (the other peer doesn't produce any more data),\n     * or `WritableStream` is aborted (the other peer can't receive any more data),\n     * or `DuplexStreamFactory#abort` is called.\n     *\n     * Usually indicates the other peer has closed the duplex stream. You can clean up\n     * any resources you have allocated now.\n     */\n    dispose?: (() => void | Promise<void>) | undefined;\n}\n\n/**\n * A factory for creating a duplex stream.\n *\n * It can create multiple `ReadableStream`s and `WritableStream`s,\n * when any of them is closed, all other streams will be closed as well.\n */\nexport class DuplexStreamFactory<R, W> {\n    #readableControllers: ReadableStreamDefaultController<R>[] = [];\n    #writers: WritableStreamDefaultWriter<W>[] = [];\n\n    #writableClosed = false;\n    get writableClosed() {\n        return this.#writableClosed;\n    }\n\n    #closed = new PromiseResolver<void>();\n    get closed() {\n        return this.#closed.promise;\n    }\n\n    readonly #options: DuplexStreamFactoryOptions;\n\n    constructor(options?: DuplexStreamFactoryOptions) {\n        this.#options = options ?? {};\n    }\n\n    wrapReadable(\n        readable: ReadableStream<R>,\n        strategy?: QueuingStrategy<R>,\n    ): WrapReadableStream<R> {\n        return new WrapReadableStream<R>(\n            {\n                start: (controller) => {\n                    this.#readableControllers.push(controller);\n                    return readable;\n                },\n                cancel: async () => {\n                    // cancel means the local peer wants to close the connection.\n                    await this.close();\n                },\n                close: async () => {\n                    // stream end means the remote peer closed the connection first.\n                    await this.dispose();\n                },\n            },\n            strategy,\n        );\n    }\n\n    createWritable(stream: WritableStream<W>): WritableStream<W> {\n        const writer = stream.getWriter();\n        this.#writers.push(writer);\n\n        // `WritableStream` has no way to tell if the remote peer has closed the connection.\n        // So it only triggers `close`.\n        return new WritableStream<W>({\n            write: async (chunk) => {\n                await writer.write(chunk);\n            },\n            abort: async (reason) => {\n                await writer.abort(reason);\n                await this.close();\n            },\n            close: async () => {\n                // NOOP: the writer is already closed\n                await writer.close().catch(NOOP);\n                await this.close();\n            },\n        });\n    }\n\n    async close() {\n        if (this.#writableClosed) {\n            return;\n        }\n        this.#writableClosed = true;\n\n        // Call `close` first, so it can still write data to `WritableStream`s.\n        if ((await this.#options.close?.()) !== false) {\n            // `close` can return `false` to disable automatic `dispose`.\n            await this.dispose();\n        }\n\n        for (const writer of this.#writers) {\n            // NOOP: the writer is already closed\n            writer.close().catch(NOOP);\n        }\n    }\n\n    async dispose() {\n        this.#writableClosed = true;\n        this.#closed.resolve();\n\n        for (const controller of this.#readableControllers) {\n            try {\n                controller.close();\n            } catch {\n                // ignore\n            }\n        }\n\n        await this.#options.dispose?.();\n    }\n}\n","import { ReadableStream } from \"./stream.js\";\nfunction getWrappedReadableStream(wrapper, controller) {\n    if (\"start\" in wrapper) {\n        return wrapper.start(controller);\n    }\n    else if (typeof wrapper === \"function\") {\n        return wrapper(controller);\n    }\n    else {\n        // Can't use `wrapper instanceof ReadableStream`\n        // Because we want to be compatible with any ReadableStream-like objects\n        return wrapper;\n    }\n}\n/**\n * This class has multiple usages:\n *\n * 1. Get notified when the stream is cancelled or closed.\n * 2. Synchronously create a `ReadableStream` by asynchronously return another `ReadableStream`.\n * 3. Convert native `ReadableStream`s to polyfilled ones so they can `pipe` between.\n */\nexport class WrapReadableStream extends ReadableStream {\n    readable;\n    #reader;\n    constructor(wrapper, strategy) {\n        super({\n            start: async (controller) => {\n                // `start` is invoked before `ReadableStream`'s constructor finish,\n                // so using `this` synchronously causes\n                // \"Must call super constructor in derived class before accessing 'this' or returning from derived constructor\".\n                // Queue a microtask to avoid this.\n                await Promise.resolve();\n                this.readable = await getWrappedReadableStream(wrapper, controller);\n                this.#reader = this.readable.getReader();\n            },\n            pull: async (controller) => {\n                const result = await this.#reader.read();\n                if (result.done) {\n                    controller.close();\n                    if (\"close\" in wrapper) {\n                        await wrapper.close?.();\n                    }\n                }\n                else {\n                    controller.enqueue(result.value);\n                }\n            },\n            cancel: async (reason) => {\n                await this.#reader.cancel(reason);\n                if (\"cancel\" in wrapper) {\n                    await wrapper.cancel?.(reason);\n                }\n            },\n        }, strategy);\n    }\n}\n//# sourceMappingURL=wrap-readable.js.map","import type { ValueOrPromise } from \"@yume-chan/struct\";\n\nimport type {\n    QueuingStrategy,\n    ReadableStreamDefaultController,\n    ReadableStreamDefaultReader,\n} from \"./stream.js\";\nimport { ReadableStream } from \"./stream.js\";\n\nexport type WrapReadableStreamStart<T> = (\n    controller: ReadableStreamDefaultController<T>,\n) => ValueOrPromise<ReadableStream<T>>;\n\nexport interface ReadableStreamWrapper<T> {\n    start: WrapReadableStreamStart<T>;\n    cancel?(reason?: unknown): ValueOrPromise<void>;\n    close?(): ValueOrPromise<void>;\n}\n\nfunction getWrappedReadableStream<T>(\n    wrapper:\n        | ReadableStream<T>\n        | WrapReadableStreamStart<T>\n        | ReadableStreamWrapper<T>,\n    controller: ReadableStreamDefaultController<T>,\n) {\n    if (\"start\" in wrapper) {\n        return wrapper.start(controller);\n    } else if (typeof wrapper === \"function\") {\n        return wrapper(controller);\n    } else {\n        // Can't use `wrapper instanceof ReadableStream`\n        // Because we want to be compatible with any ReadableStream-like objects\n        return wrapper;\n    }\n}\n\n/**\n * This class has multiple usages:\n *\n * 1. Get notified when the stream is cancelled or closed.\n * 2. Synchronously create a `ReadableStream` by asynchronously return another `ReadableStream`.\n * 3. Convert native `ReadableStream`s to polyfilled ones so they can `pipe` between.\n */\nexport class WrapReadableStream<T> extends ReadableStream<T> {\n    readable!: ReadableStream<T>;\n\n    #reader!: ReadableStreamDefaultReader<T>;\n\n    constructor(\n        wrapper:\n            | ReadableStream<T>\n            | WrapReadableStreamStart<T>\n            | ReadableStreamWrapper<T>,\n        strategy?: QueuingStrategy<T>,\n    ) {\n        super(\n            {\n                start: async (controller) => {\n                    // `start` is invoked before `ReadableStream`'s constructor finish,\n                    // so using `this` synchronously causes\n                    // \"Must call super constructor in derived class before accessing 'this' or returning from derived constructor\".\n                    // Queue a microtask to avoid this.\n                    await Promise.resolve();\n\n                    this.readable = await getWrappedReadableStream(\n                        wrapper,\n                        controller,\n                    );\n                    this.#reader = this.readable.getReader();\n                },\n                pull: async (controller) => {\n                    const result = await this.#reader.read();\n                    if (result.done) {\n                        controller.close();\n                        if (\"close\" in wrapper) {\n                            await wrapper.close?.();\n                        }\n                    } else {\n                        controller.enqueue(result.value);\n                    }\n                },\n                cancel: async (reason) => {\n                    await this.#reader.cancel(reason);\n                    if (\"cancel\" in wrapper) {\n                        await wrapper.cancel?.(reason);\n                    }\n                },\n            },\n            strategy,\n        );\n    }\n}\n","const Global = globalThis;\nexport const TextDecoderStream = Global.TextDecoderStream;\nexport const TextEncoderStream = Global.TextEncoderStream;\n//# sourceMappingURL=encoding.js.map","import type { TransformStream } from \"./stream.js\";\n\nexport interface TextDecoderOptions {\n    fatal?: boolean;\n    ignoreBOM?: boolean;\n}\n\ndeclare class TextDecoderStreamType extends TransformStream<\n    ArrayBufferView | ArrayBuffer,\n    string\n> {\n    constructor(label?: string, options?: TextDecoderOptions);\n\n    readonly encoding: string;\n    readonly fatal: boolean;\n    readonly ignoreBOM: boolean;\n}\n\ndeclare class TextEncoderStreamType extends TransformStream<\n    string,\n    Uint8Array\n> {\n    constructor();\n\n    readonly encoding: string;\n}\n\ninterface GlobalExtension {\n    TextDecoderStream: typeof TextDecoderStreamType;\n    TextEncoderStream: typeof TextEncoderStreamType;\n}\n\nconst Global = globalThis as unknown as GlobalExtension;\n\nexport const TextDecoderStream = Global.TextDecoderStream;\nexport type TextDecoderStream = TextDecoderStreamType;\n\nexport const TextEncoderStream = Global.TextEncoderStream;\nexport type TextEncoderStream = TextEncoderStreamType;\n","import { TransformStream } from \"./stream.js\";\nexport class InspectStream extends TransformStream {\n    constructor(callback) {\n        super({\n            transform(chunk, controller) {\n                callback(chunk);\n                controller.enqueue(chunk);\n            },\n        });\n    }\n}\n//# sourceMappingURL=inspect.js.map","import { TransformStream } from \"./stream.js\";\n\nexport class InspectStream<T> extends TransformStream<T, T> {\n    constructor(callback: (value: T) => void) {\n        super({\n            transform(chunk, controller) {\n                callback(chunk);\n                controller.enqueue(chunk);\n            },\n        });\n    }\n}\n","import { WritableStream } from \"./stream.js\";\n/**\n * Pipe `pair.readable` to `writable`, then returns `pair.writable`.\n *\n * This is the opposite of `ReadableStream#pipeThrough()`.\n *\n * @param writable The `WritableStream` to write to.\n * @param pair A `TransformStream` that converts chunks.\n * @returns `pair`'s `writable` stream.\n */\nexport function pipeFrom(writable, pair) {\n    const writer = pair.writable.getWriter();\n    const pipe = pair.readable.pipeTo(writable);\n    return new WritableStream({\n        async write(chunk) {\n            await writer.write(chunk);\n        },\n        async close() {\n            await writer.close();\n            await pipe;\n        },\n    });\n}\n//# sourceMappingURL=pipe-from.js.map","import type { ReadableWritablePair } from \"./stream.js\";\nimport { WritableStream } from \"./stream.js\";\n\n/**\n * Pipe `pair.readable` to `writable`, then returns `pair.writable`.\n *\n * This is the opposite of `ReadableStream#pipeThrough()`.\n *\n * @param writable The `WritableStream` to write to.\n * @param pair A `TransformStream` that converts chunks.\n * @returns `pair`'s `writable` stream.\n */\nexport function pipeFrom<W, T>(\n    writable: WritableStream<W>,\n    pair: ReadableWritablePair<W, T>,\n) {\n    const writer = pair.writable.getWriter();\n    const pipe = pair.readable.pipeTo(writable);\n    return new WritableStream<T>({\n        async write(chunk) {\n            await writer.write(chunk);\n        },\n        async close() {\n            await writer.close();\n            await pipe;\n        },\n    });\n}\n","import { TransformStream } from \"./stream.js\";\nfunction* split(input, separator) {\n    let start = 0;\n    while (true) {\n        const index = input.indexOf(separator, start);\n        if (index === -1) {\n            return;\n        }\n        const part = input.substring(start, index);\n        yield part;\n        start = index + 1;\n    }\n}\nexport class SplitStringStream extends TransformStream {\n    constructor(separator) {\n        super({\n            transform(chunk, controller) {\n                for (const part of split(chunk, separator)) {\n                    controller.enqueue(part);\n                }\n            },\n        });\n    }\n}\n//# sourceMappingURL=split-string.js.map","import { TransformStream } from \"./stream.js\";\n\nfunction* split(\n    input: string,\n    separator: string,\n): Generator<string, void, void> {\n    let start = 0;\n\n    while (true) {\n        const index = input.indexOf(separator, start);\n        if (index === -1) {\n            return;\n        }\n\n        const part = input.substring(start, index);\n        yield part;\n\n        start = index + 1;\n    }\n}\n\nexport class SplitStringStream extends TransformStream<string, string> {\n    constructor(separator: string) {\n        super({\n            transform(chunk, controller) {\n                for (const part of split(chunk, separator)) {\n                    controller.enqueue(part);\n                }\n            },\n        });\n    }\n}\n","import { BufferedTransformStream } from \"./buffered-transform.js\";\nexport class StructDeserializeStream extends BufferedTransformStream {\n    constructor(struct) {\n        super((stream) => {\n            return struct.deserialize(stream);\n        });\n    }\n}\n//# sourceMappingURL=struct-deserialize.js.map","import type Struct from \"@yume-chan/struct\";\nimport type { StructValueType } from \"@yume-chan/struct\";\n\nimport { BufferedTransformStream } from \"./buffered-transform.js\";\n\nexport class StructDeserializeStream<\n    T extends Struct<object, PropertyKey, object, unknown>,\n> extends BufferedTransformStream<StructValueType<T>> {\n    constructor(struct: T) {\n        super((stream) => {\n            return struct.deserialize(stream) as never;\n        });\n    }\n}\n","import { TransformStream } from \"./stream.js\";\nexport class StructSerializeStream extends TransformStream {\n    constructor(struct) {\n        super({\n            transform(chunk, controller) {\n                controller.enqueue(struct.serialize(chunk));\n            },\n        });\n    }\n}\n//# sourceMappingURL=struct-serialize.js.map","import type Struct from \"@yume-chan/struct\";\n\nimport { TransformStream } from \"./stream.js\";\n\nexport class StructSerializeStream<\n    T extends Struct<object, PropertyKey, object, unknown>,\n> extends TransformStream<T[\"TInit\"], Uint8Array> {\n    constructor(struct: T) {\n        super({\n            transform(chunk, controller) {\n                controller.enqueue(struct.serialize(chunk));\n            },\n        });\n    }\n}\n","import { WritableStream } from \"./stream.js\";\nasync function getWrappedWritableStream(start) {\n    if (\"start\" in start) {\n        return await start.start();\n    }\n    else if (typeof start === \"function\") {\n        return await start();\n    }\n    else {\n        // Can't use `wrapper instanceof WritableStream`\n        // Because we want to be compatible with any WritableStream-like objects\n        return start;\n    }\n}\nexport class WrapWritableStream extends WritableStream {\n    writable;\n    #writer;\n    constructor(start) {\n        super({\n            start: async () => {\n                // `start` is invoked before `ReadableStream`'s constructor finish,\n                // so using `this` synchronously causes\n                // \"Must call super constructor in derived class before accessing 'this' or returning from derived constructor\".\n                // Queue a microtask to avoid this.\n                await Promise.resolve();\n                this.writable = await getWrappedWritableStream(start);\n                this.#writer = this.writable.getWriter();\n            },\n            write: async (chunk) => {\n                await this.#writer.write(chunk);\n            },\n            abort: async (reason) => {\n                await this.#writer.abort(reason);\n                if (start !== this.writable && \"close\" in start) {\n                    await start.close?.();\n                }\n            },\n            close: async () => {\n                // Close the inner stream first.\n                // Usually the inner stream is a logical sub-stream over the outer stream,\n                // closing the outer stream first will make the inner stream incapable of\n                // sending data in its `close` handler.\n                await this.#writer.close();\n                if (start !== this.writable && \"close\" in start) {\n                    await start.close?.();\n                }\n            },\n        });\n    }\n    bePipedThroughFrom(transformer) {\n        let promise;\n        return new WrapWritableStream({\n            start: () => {\n                promise = transformer.readable.pipeTo(this);\n                return transformer.writable;\n            },\n            async close() {\n                await promise;\n            },\n        });\n    }\n}\n//# sourceMappingURL=wrap-writable.js.map","import type { ValueOrPromise } from \"@yume-chan/struct\";\n\nimport type { TransformStream, WritableStreamDefaultWriter } from \"./stream.js\";\nimport { WritableStream } from \"./stream.js\";\n\nexport type WrapWritableStreamStart<T> = () => ValueOrPromise<\n    WritableStream<T>\n>;\n\nexport interface WritableStreamWrapper<T> {\n    start: WrapWritableStreamStart<T>;\n    close?(): void | Promise<void>;\n}\n\nasync function getWrappedWritableStream<T>(\n    start:\n        | WritableStream<T>\n        | WrapWritableStreamStart<T>\n        | WritableStreamWrapper<T>,\n) {\n    if (\"start\" in start) {\n        return await start.start();\n    } else if (typeof start === \"function\") {\n        return await start();\n    } else {\n        // Can't use `wrapper instanceof WritableStream`\n        // Because we want to be compatible with any WritableStream-like objects\n        return start;\n    }\n}\n\nexport class WrapWritableStream<T> extends WritableStream<T> {\n    writable!: WritableStream<T>;\n\n    #writer!: WritableStreamDefaultWriter<T>;\n\n    constructor(\n        start:\n            | WritableStream<T>\n            | WrapWritableStreamStart<T>\n            | WritableStreamWrapper<T>,\n    ) {\n        super({\n            start: async () => {\n                // `start` is invoked before `ReadableStream`'s constructor finish,\n                // so using `this` synchronously causes\n                // \"Must call super constructor in derived class before accessing 'this' or returning from derived constructor\".\n                // Queue a microtask to avoid this.\n                await Promise.resolve();\n\n                this.writable = await getWrappedWritableStream(start);\n                this.#writer = this.writable.getWriter();\n            },\n            write: async (chunk) => {\n                await this.#writer.write(chunk);\n            },\n            abort: async (reason) => {\n                await this.#writer.abort(reason);\n                if (start !== this.writable && \"close\" in start) {\n                    await start.close?.();\n                }\n            },\n            close: async () => {\n                // Close the inner stream first.\n                // Usually the inner stream is a logical sub-stream over the outer stream,\n                // closing the outer stream first will make the inner stream incapable of\n                // sending data in its `close` handler.\n                await this.#writer.close();\n                if (start !== this.writable && \"close\" in start) {\n                    await start.close?.();\n                }\n            },\n        });\n    }\n\n    bePipedThroughFrom<U>(transformer: TransformStream<U, T>) {\n        let promise: Promise<void>;\n        return new WrapWritableStream<U>({\n            start: () => {\n                promise = transformer.readable.pipeTo(this);\n                return transformer.writable;\n            },\n            async close() {\n                await promise;\n            },\n        });\n    }\n}\n","export * from \"./base.js\";\nexport * from \"./framebuffer.js\";\nexport * from \"./power.js\";\nexport * from \"./reverse.js\";\nexport * from \"./subprocess/index.js\";\nexport * from \"./sync/index.js\";\nexport * from \"./tcpip.js\";\n","import { AutoDisposable } from \"@yume-chan/event\";\nexport class AdbCommandBase extends AutoDisposable {\n    adb;\n    constructor(adb) {\n        super();\n        this.adb = adb;\n    }\n}\n//# sourceMappingURL=base.js.map","import { AutoDisposable } from \"@yume-chan/event\";\n\nimport type { Adb } from \"../adb.js\";\n\nexport class AdbCommandBase extends AutoDisposable {\n    protected adb: Adb;\n\n    constructor(adb: Adb) {\n        super();\n        this.adb = adb;\n    }\n}\n","export * from \"./disposable.js\";\nexport * from \"./event.js\";\nexport * from \"./event-emitter.js\";\nexport * from \"./utils.js\";\n","export class AutoDisposable {\n    #disposables = [];\n    constructor() {\n        this.dispose = this.dispose.bind(this);\n    }\n    addDisposable(disposable) {\n        this.#disposables.push(disposable);\n        return disposable;\n    }\n    dispose() {\n        for (const disposable of this.#disposables) {\n            disposable.dispose();\n        }\n        this.#disposables = [];\n    }\n}\nexport class DisposableList extends AutoDisposable {\n    add(disposable) {\n        return this.addDisposable(disposable);\n    }\n}\n//# sourceMappingURL=disposable.js.map","export interface Disposable {\n    dispose(): void;\n}\n\nexport class AutoDisposable implements Disposable {\n    #disposables: Disposable[] = [];\n\n    constructor() {\n        this.dispose = this.dispose.bind(this);\n    }\n\n    protected addDisposable<T extends Disposable>(disposable: T): T {\n        this.#disposables.push(disposable);\n        return disposable;\n    }\n\n    dispose() {\n        for (const disposable of this.#disposables) {\n            disposable.dispose();\n        }\n\n        this.#disposables = [];\n    }\n}\n\nexport class DisposableList extends AutoDisposable {\n    add<T extends Disposable>(disposable: T): T {\n        return this.addDisposable(disposable);\n    }\n}\n","import type { Disposable } from \"./disposable.js\";\n\nexport interface EventListener<\n    TEvent,\n    TThis,\n    TArgs extends unknown[],\n    TResult,\n> {\n    (this: TThis, e: TEvent, ...args: TArgs): TResult;\n}\n\nexport interface RemoveEventListener extends Disposable {\n    (): void;\n}\n\nexport interface Event<TEvent, TResult = unknown> {\n    /**\n     * Attaches an event listener.\n     */\n    (\n        listener: EventListener<TEvent, unknown, [], TResult>,\n    ): RemoveEventListener;\n\n    /**\n     * Attaches an event listener that bind to `this` and `args`.\n     */\n    <TThis, TArgs extends unknown[]>(\n        listener: EventListener<TEvent, TThis, TArgs, TResult>,\n        thisArg: TThis,\n        ...args: TArgs\n    ): RemoveEventListener;\n}\n","export class EventEmitter {\n    listeners = [];\n    constructor() {\n        this.event = this.event.bind(this);\n    }\n    addEventListener(info) {\n        this.listeners.push(info);\n        const remove = () => {\n            const index = this.listeners.indexOf(info);\n            if (index !== -1) {\n                this.listeners.splice(index, 1);\n            }\n        };\n        remove.dispose = remove;\n        return remove;\n    }\n    event = (listener, thisArg, ...args) => {\n        const info = {\n            listener: listener,\n            thisArg,\n            args,\n        };\n        return this.addEventListener(info);\n    };\n    fire(e) {\n        for (const info of this.listeners.slice()) {\n            info.listener.apply(info.thisArg, [e, ...info.args]);\n        }\n    }\n    dispose() {\n        this.listeners.length = 0;\n    }\n}\n//# sourceMappingURL=event-emitter.js.map","import type { Disposable } from \"./disposable.js\";\nimport type { EventListener, RemoveEventListener } from \"./event.js\";\n\nexport interface EventListenerInfo<TEvent, TResult = unknown> {\n    listener: EventListener<TEvent, unknown, unknown[], TResult>;\n\n    thisArg: unknown;\n\n    args: unknown[];\n}\n\nexport interface AddEventListener<TEvent, TResult = unknown> {\n    (\n        listener: EventListener<TEvent, unknown, [], TResult>,\n    ): RemoveEventListener;\n    <TThis, TArgs extends unknown[]>(\n        listener: EventListener<TEvent, TThis, TArgs, TResult>,\n        thisArg: TThis,\n        ...args: TArgs\n    ): RemoveEventListener;\n}\n\nexport class EventEmitter<TEvent, TResult = unknown> implements Disposable {\n    protected readonly listeners: EventListenerInfo<TEvent, TResult>[] = [];\n\n    constructor() {\n        this.event = this.event.bind(this);\n    }\n\n    protected addEventListener(\n        info: EventListenerInfo<TEvent, TResult>,\n    ): RemoveEventListener {\n        this.listeners.push(info);\n\n        const remove: RemoveEventListener = () => {\n            const index = this.listeners.indexOf(info);\n            if (index !== -1) {\n                this.listeners.splice(index, 1);\n            }\n        };\n        remove.dispose = remove;\n        return remove;\n    }\n\n    event: AddEventListener<TEvent, TResult> = <TThis, TArgs extends unknown[]>(\n        listener: EventListener<TEvent, TThis, TArgs, TResult>,\n        thisArg?: TThis,\n        ...args: TArgs\n    ) => {\n        const info: EventListenerInfo<TEvent, TResult> = {\n            listener: listener as EventListener<\n                TEvent,\n                unknown,\n                unknown[],\n                TResult\n            >,\n            thisArg,\n            args,\n        };\n        return this.addEventListener(info);\n    };\n\n    fire(e: TEvent) {\n        for (const info of this.listeners.slice()) {\n            info.listener.apply(info.thisArg, [e, ...info.args]);\n        }\n    }\n\n    dispose() {\n        this.listeners.length = 0;\n    }\n}\n","import { PromiseResolver } from \"@yume-chan/async\";\nexport async function once(event) {\n    const resolver = new PromiseResolver();\n    const dispose = event(resolver.resolve);\n    const result = await resolver.promise;\n    dispose();\n    return result;\n}\n//# sourceMappingURL=utils.js.map","import { PromiseResolver } from \"@yume-chan/async\";\n\nimport type { Event } from \"./event.js\";\n\nexport async function once<T>(event: Event<T, unknown>): Promise<T> {\n    const resolver = new PromiseResolver<T>();\n    const dispose = event(resolver.resolve);\n    const result = await resolver.promise;\n    dispose();\n    return result;\n}\n","import { BufferedReadableStream } from \"@yume-chan/stream-extra\";\nimport Struct, { StructEmptyError } from \"@yume-chan/struct\";\nconst Version = new Struct({ littleEndian: true }).uint32(\"version\");\nexport const AdbFrameBufferV1 = new Struct({ littleEndian: true })\n    .uint32(\"bpp\")\n    .uint32(\"size\")\n    .uint32(\"width\")\n    .uint32(\"height\")\n    .uint32(\"red_offset\")\n    .uint32(\"red_length\")\n    .uint32(\"blue_offset\")\n    .uint32(\"blue_length\")\n    .uint32(\"green_offset\")\n    .uint32(\"green_length\")\n    .uint32(\"alpha_offset\")\n    .uint32(\"alpha_length\")\n    .uint8Array(\"data\", { lengthField: \"size\" });\nexport const AdbFrameBufferV2 = new Struct({ littleEndian: true })\n    .uint32(\"bpp\")\n    .uint32(\"colorSpace\")\n    .uint32(\"size\")\n    .uint32(\"width\")\n    .uint32(\"height\")\n    .uint32(\"red_offset\")\n    .uint32(\"red_length\")\n    .uint32(\"blue_offset\")\n    .uint32(\"blue_length\")\n    .uint32(\"green_offset\")\n    .uint32(\"green_length\")\n    .uint32(\"alpha_offset\")\n    .uint32(\"alpha_length\")\n    .uint8Array(\"data\", { lengthField: \"size\" });\nexport class AdbFrameBufferError extends Error {\n    constructor(message, options) {\n        super(message, options);\n    }\n}\nexport class AdbFrameBufferUnsupportedVersionError extends AdbFrameBufferError {\n    constructor(version) {\n        super(`Unsupported FrameBuffer version ${version}`);\n    }\n}\nexport class AdbFrameBufferForbiddenError extends AdbFrameBufferError {\n    constructor() {\n        super(\"FrameBuffer is disabled by current app\");\n    }\n}\nexport async function framebuffer(adb) {\n    const socket = await adb.createSocket(\"framebuffer:\");\n    const stream = new BufferedReadableStream(socket.readable);\n    let version;\n    try {\n        ({ version } = await Version.deserialize(stream));\n    }\n    catch (e) {\n        if (e instanceof StructEmptyError) {\n            throw new AdbFrameBufferForbiddenError();\n        }\n        throw e;\n    }\n    switch (version) {\n        case 1:\n            // TODO: AdbFrameBuffer: does all v1 responses uses the same color space? Add it so the command returns same format for all versions.\n            return AdbFrameBufferV1.deserialize(stream);\n        case 2:\n            return AdbFrameBufferV2.deserialize(stream);\n        default:\n            throw new AdbFrameBufferUnsupportedVersionError(version);\n    }\n}\n//# sourceMappingURL=framebuffer.js.map","import { BufferedReadableStream } from \"@yume-chan/stream-extra\";\nimport Struct, { StructEmptyError } from \"@yume-chan/struct\";\n\nimport type { Adb } from \"../adb.js\";\n\nconst Version = new Struct({ littleEndian: true }).uint32(\"version\");\n\nexport const AdbFrameBufferV1 = new Struct({ littleEndian: true })\n    .uint32(\"bpp\")\n    .uint32(\"size\")\n    .uint32(\"width\")\n    .uint32(\"height\")\n    .uint32(\"red_offset\")\n    .uint32(\"red_length\")\n    .uint32(\"blue_offset\")\n    .uint32(\"blue_length\")\n    .uint32(\"green_offset\")\n    .uint32(\"green_length\")\n    .uint32(\"alpha_offset\")\n    .uint32(\"alpha_length\")\n    .uint8Array(\"data\", { lengthField: \"size\" });\n\nexport type AdbFrameBufferV1 = (typeof AdbFrameBufferV1)[\"TDeserializeResult\"];\n\nexport const AdbFrameBufferV2 = new Struct({ littleEndian: true })\n    .uint32(\"bpp\")\n    .uint32(\"colorSpace\")\n    .uint32(\"size\")\n    .uint32(\"width\")\n    .uint32(\"height\")\n    .uint32(\"red_offset\")\n    .uint32(\"red_length\")\n    .uint32(\"blue_offset\")\n    .uint32(\"blue_length\")\n    .uint32(\"green_offset\")\n    .uint32(\"green_length\")\n    .uint32(\"alpha_offset\")\n    .uint32(\"alpha_length\")\n    .uint8Array(\"data\", { lengthField: \"size\" });\n\nexport type AdbFrameBufferV2 = (typeof AdbFrameBufferV2)[\"TDeserializeResult\"];\n\n/**\n * ADB uses 8 int32 fields to describe bit depths\n *\n * The only combination I have seen is RGBA8888, which is\n *\n *   red_offset:   0\n *   red_length:   8\n *   blue_offset:  16\n *   blue_length:  8\n *   green_offset: 8\n *   green_length: 8\n *   alpha_offset: 24\n *   alpha_length: 8\n *\n * But it doesn't mean that other combinations are not possible.\n */\nexport type AdbFrameBuffer = AdbFrameBufferV1 | AdbFrameBufferV2;\n\nexport abstract class AdbFrameBufferError extends Error {\n    constructor(message: string, options?: ErrorOptions) {\n        super(message, options);\n    }\n}\n\nexport class AdbFrameBufferUnsupportedVersionError extends AdbFrameBufferError {\n    constructor(version: number) {\n        super(`Unsupported FrameBuffer version ${version}`);\n    }\n}\n\nexport class AdbFrameBufferForbiddenError extends AdbFrameBufferError {\n    constructor() {\n        super(\"FrameBuffer is disabled by current app\");\n    }\n}\n\nexport async function framebuffer(adb: Adb): Promise<AdbFrameBuffer> {\n    const socket = await adb.createSocket(\"framebuffer:\");\n    const stream = new BufferedReadableStream(socket.readable);\n\n    let version: number;\n    try {\n        ({ version } = await Version.deserialize(stream));\n    } catch (e) {\n        if (e instanceof StructEmptyError) {\n            throw new AdbFrameBufferForbiddenError();\n        }\n        throw e;\n    }\n\n    switch (version) {\n        case 1:\n            // TODO: AdbFrameBuffer: does all v1 responses uses the same color space? Add it so the command returns same format for all versions.\n            return AdbFrameBufferV1.deserialize(stream);\n        case 2:\n            return AdbFrameBufferV2.deserialize(stream);\n        default:\n            throw new AdbFrameBufferUnsupportedVersionError(version);\n    }\n}\n","// cspell: ignore bootloader\n// cspell: ignore fastboot\n// cspell: ignore keyevent\n// cspell: ignore longpress\nimport { AdbCommandBase } from \"./base.js\";\nexport class AdbPower extends AdbCommandBase {\n    reboot(mode = \"\") {\n        return this.adb.createSocketAndWait(`reboot:${mode}`);\n    }\n    bootloader() {\n        return this.reboot(\"bootloader\");\n    }\n    fastboot() {\n        return this.reboot(\"fastboot\");\n    }\n    recovery() {\n        return this.reboot(\"recovery\");\n    }\n    sideload() {\n        return this.reboot(\"sideload\");\n    }\n    /**\n     * Reboot to Qualcomm Emergency Download (EDL) Mode.\n     *\n     * Only works on some Qualcomm devices.\n     */\n    qualcommEdlMode() {\n        return this.reboot(\"edl\");\n    }\n    powerOff() {\n        return this.adb.subprocess.spawnAndWaitLegacy([\"reboot\", \"-p\"]);\n    }\n    powerButton(longPress = false) {\n        const args = [\"input\", \"keyevent\"];\n        if (longPress) {\n            args.push(\"--longpress\");\n        }\n        args.push(\"POWER\");\n        return this.adb.subprocess.spawnAndWaitLegacy(args);\n    }\n    /**\n     * Reboot to Samsung Odin download mode.\n     *\n     * Only works on Samsung devices.\n     */\n    samsungOdin() {\n        return this.reboot(\"download\");\n    }\n}\n//# sourceMappingURL=power.js.map","// cspell: ignore bootloader\n// cspell: ignore fastboot\n// cspell: ignore keyevent\n// cspell: ignore longpress\n\nimport { AdbCommandBase } from \"./base.js\";\n\nexport class AdbPower extends AdbCommandBase {\n    reboot(mode = \"\") {\n        return this.adb.createSocketAndWait(`reboot:${mode}`);\n    }\n\n    bootloader() {\n        return this.reboot(\"bootloader\");\n    }\n\n    fastboot() {\n        return this.reboot(\"fastboot\");\n    }\n\n    recovery() {\n        return this.reboot(\"recovery\");\n    }\n\n    sideload() {\n        return this.reboot(\"sideload\");\n    }\n\n    /**\n     * Reboot to Qualcomm Emergency Download (EDL) Mode.\n     *\n     * Only works on some Qualcomm devices.\n     */\n    qualcommEdlMode() {\n        return this.reboot(\"edl\");\n    }\n\n    powerOff() {\n        return this.adb.subprocess.spawnAndWaitLegacy([\"reboot\", \"-p\"]);\n    }\n\n    powerButton(longPress = false) {\n        const args = [\"input\", \"keyevent\"];\n        if (longPress) {\n            args.push(\"--longpress\");\n        }\n        args.push(\"POWER\");\n\n        return this.adb.subprocess.spawnAndWaitLegacy(args);\n    }\n\n    /**\n     * Reboot to Samsung Odin download mode.\n     *\n     * Only works on Samsung devices.\n     */\n    samsungOdin() {\n        return this.reboot(\"download\");\n    }\n}\n","// cspell: ignore killforward\nimport { AutoDisposable } from \"@yume-chan/event\";\nimport { BufferedReadableStream } from \"@yume-chan/stream-extra\";\nimport Struct, { ExactReadableEndedError, encodeUtf8 } from \"@yume-chan/struct\";\nimport { hexToNumber, sequenceEqual } from \"../utils/index.js\";\nconst AdbReverseStringResponse = new Struct()\n    .string(\"length\", { length: 4 })\n    .string(\"content\", { lengthField: \"length\", lengthFieldRadix: 16 });\nexport class AdbReverseError extends Error {\n    constructor(message) {\n        super(message);\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\nexport class AdbReverseNotSupportedError extends AdbReverseError {\n    constructor() {\n        super(\"ADB reverse tunnel is not supported on this device when connected wirelessly.\");\n    }\n}\nconst AdbReverseErrorResponse = new Struct()\n    .concat(AdbReverseStringResponse)\n    .postDeserialize((value) => {\n    // https://issuetracker.google.com/issues/37066218\n    // ADB on Android <9 can't create reverse tunnels when connected wirelessly (ADB over Wi-Fi),\n    // and returns this confusing \"more than one device/emulator\" error.\n    if (value.content === \"more than one device/emulator\") {\n        throw new AdbReverseNotSupportedError();\n    }\n    else {\n        throw new AdbReverseError(value.content);\n    }\n});\n// Like `hexToNumber`, it's much faster than first converting `buffer` to a string\nfunction decimalToNumber(buffer) {\n    let value = 0;\n    for (const byte of buffer) {\n        // Like `parseInt`, return when it encounters a non-digit character\n        if (byte < 48 || byte > 57) {\n            return value;\n        }\n        value = value * 10 + byte - 48;\n    }\n    return value;\n}\nconst OKAY = encodeUtf8(\"OKAY\");\nexport class AdbReverseCommand extends AutoDisposable {\n    adb;\n    #deviceAddressToLocalAddress = new Map();\n    constructor(adb) {\n        super();\n        this.adb = adb;\n    }\n    async createBufferedStream(service) {\n        const socket = await this.adb.createSocket(service);\n        return new BufferedReadableStream(socket.readable);\n    }\n    async sendRequest(service) {\n        const stream = await this.createBufferedStream(service);\n        const response = await stream.readExactly(4);\n        if (!sequenceEqual(response, OKAY)) {\n            await AdbReverseErrorResponse.deserialize(stream);\n        }\n        return stream;\n    }\n    async list() {\n        const stream = await this.createBufferedStream(\"reverse:list-forward\");\n        const response = await AdbReverseStringResponse.deserialize(stream);\n        return response.content\n            .split(\"\\n\")\n            .filter((line) => !!line)\n            .map((line) => {\n            const [deviceSerial, localName, remoteName] = line.split(\" \");\n            return { deviceSerial, localName, remoteName };\n        });\n        // No need to close the stream, device will close it\n    }\n    /**\n     * Add an already existing reverse tunnel. Depends on the transport type, this may not do anything.\n     * @param deviceAddress The address to be listened on device by ADB daemon. Or `tcp:0` to choose an available TCP port.\n     * @param localAddress The address that listens on the local machine.\n     * @returns `tcp:{ACTUAL_LISTENING_PORT}`, If `deviceAddress` is `tcp:0`; otherwise, `deviceAddress`.\n     */\n    async addExternal(deviceAddress, localAddress) {\n        const stream = await this.sendRequest(`reverse:forward:${deviceAddress};${localAddress}`);\n        // `tcp:0` tells the device to pick an available port.\n        // On Android >=8, device will respond with the selected port for all `tcp:` requests.\n        if (deviceAddress.startsWith(\"tcp:\")) {\n            const position = stream.position;\n            try {\n                const length = hexToNumber(await stream.readExactly(4));\n                const port = decimalToNumber(await stream.readExactly(length));\n                deviceAddress = `tcp:${port}`;\n            }\n            catch (e) {\n                if (e instanceof ExactReadableEndedError &&\n                    stream.position === position) {\n                    // Android <8 doesn't have this response.\n                    // (the stream is closed now)\n                    // Can be safely ignored.\n                }\n                else {\n                    throw e;\n                }\n            }\n        }\n        return deviceAddress;\n    }\n    /**\n     * @param deviceAddress The address to be listened on device by ADB daemon. Or `tcp:0` to choose an available TCP port.\n     * @param handler A callback to handle incoming connections.\n     * @param localAddressThe The address that listens on the local machine. May be `undefined` to let the transport choose an appropriate one.\n     * @returns `tcp:{ACTUAL_LISTENING_PORT}`, If `deviceAddress` is `tcp:0`; otherwise, `deviceAddress`.\n     * @throws {AdbReverseNotSupportedError} If ADB reverse tunnel is not supported on this device when connected wirelessly.\n     * @throws {AdbReverseError} If ADB daemon returns an error.\n     */\n    async add(deviceAddress, handler, localAddress) {\n        localAddress = await this.adb.transport.addReverseTunnel(handler, localAddress);\n        try {\n            deviceAddress = await this.addExternal(deviceAddress, localAddress);\n            this.#deviceAddressToLocalAddress.set(deviceAddress, localAddress);\n            return deviceAddress;\n        }\n        catch (e) {\n            await this.adb.transport.removeReverseTunnel(localAddress);\n            throw e;\n        }\n    }\n    async remove(deviceAddress) {\n        const localAddress = this.#deviceAddressToLocalAddress.get(deviceAddress);\n        if (localAddress) {\n            await this.adb.transport.removeReverseTunnel(localAddress);\n        }\n        await this.sendRequest(`reverse:killforward:${deviceAddress}`);\n        // No need to close the stream, device will close it\n    }\n    async removeAll() {\n        await this.adb.transport.clearReverseTunnels();\n        this.#deviceAddressToLocalAddress.clear();\n        await this.sendRequest(`reverse:killforward-all`);\n        // No need to close the stream, device will close it\n    }\n}\n//# sourceMappingURL=reverse.js.map","// cspell: ignore killforward\n\nimport { AutoDisposable } from \"@yume-chan/event\";\nimport { BufferedReadableStream } from \"@yume-chan/stream-extra\";\nimport Struct, { ExactReadableEndedError, encodeUtf8 } from \"@yume-chan/struct\";\n\nimport type { Adb, AdbIncomingSocketHandler } from \"../adb.js\";\nimport { hexToNumber, sequenceEqual } from \"../utils/index.js\";\n\nexport interface AdbForwardListener {\n    deviceSerial: string;\n\n    localName: string;\n\n    remoteName: string;\n}\n\nconst AdbReverseStringResponse = new Struct()\n    .string(\"length\", { length: 4 })\n    .string(\"content\", { lengthField: \"length\", lengthFieldRadix: 16 });\n\nexport class AdbReverseError extends Error {\n    constructor(message: string) {\n        super(message);\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\n\nexport class AdbReverseNotSupportedError extends AdbReverseError {\n    constructor() {\n        super(\n            \"ADB reverse tunnel is not supported on this device when connected wirelessly.\",\n        );\n    }\n}\n\nconst AdbReverseErrorResponse = new Struct()\n    .concat(AdbReverseStringResponse)\n    .postDeserialize((value) => {\n        // https://issuetracker.google.com/issues/37066218\n        // ADB on Android <9 can't create reverse tunnels when connected wirelessly (ADB over Wi-Fi),\n        // and returns this confusing \"more than one device/emulator\" error.\n        if (value.content === \"more than one device/emulator\") {\n            throw new AdbReverseNotSupportedError();\n        } else {\n            throw new AdbReverseError(value.content);\n        }\n    });\n\n// Like `hexToNumber`, it's much faster than first converting `buffer` to a string\nfunction decimalToNumber(buffer: Uint8Array) {\n    let value = 0;\n    for (const byte of buffer) {\n        // Like `parseInt`, return when it encounters a non-digit character\n        if (byte < 48 || byte > 57) {\n            return value;\n        }\n        value = value * 10 + byte - 48;\n    }\n    return value;\n}\n\nconst OKAY = encodeUtf8(\"OKAY\");\n\nexport class AdbReverseCommand extends AutoDisposable {\n    protected adb: Adb;\n\n    readonly #deviceAddressToLocalAddress = new Map<string, string>();\n\n    constructor(adb: Adb) {\n        super();\n\n        this.adb = adb;\n    }\n\n    protected async createBufferedStream(service: string) {\n        const socket = await this.adb.createSocket(service);\n        return new BufferedReadableStream(socket.readable);\n    }\n\n    protected async sendRequest(service: string) {\n        const stream = await this.createBufferedStream(service);\n\n        const response = await stream.readExactly(4);\n        if (!sequenceEqual(response, OKAY)) {\n            await AdbReverseErrorResponse.deserialize(stream);\n        }\n\n        return stream;\n    }\n\n    async list(): Promise<AdbForwardListener[]> {\n        const stream = await this.createBufferedStream(\"reverse:list-forward\");\n\n        const response = await AdbReverseStringResponse.deserialize(stream);\n        return response.content\n            .split(\"\\n\")\n            .filter((line) => !!line)\n            .map((line) => {\n                const [deviceSerial, localName, remoteName] = line.split(\n                    \" \",\n                ) as [string, string, string];\n                return { deviceSerial, localName, remoteName };\n            });\n\n        // No need to close the stream, device will close it\n    }\n\n    /**\n     * Add an already existing reverse tunnel. Depends on the transport type, this may not do anything.\n     * @param deviceAddress The address to be listened on device by ADB daemon. Or `tcp:0` to choose an available TCP port.\n     * @param localAddress The address that listens on the local machine.\n     * @returns `tcp:{ACTUAL_LISTENING_PORT}`, If `deviceAddress` is `tcp:0`; otherwise, `deviceAddress`.\n     */\n    async addExternal(deviceAddress: string, localAddress: string) {\n        const stream = await this.sendRequest(\n            `reverse:forward:${deviceAddress};${localAddress}`,\n        );\n\n        // `tcp:0` tells the device to pick an available port.\n        // On Android >=8, device will respond with the selected port for all `tcp:` requests.\n        if (deviceAddress.startsWith(\"tcp:\")) {\n            const position = stream.position;\n            try {\n                const length = hexToNumber(await stream.readExactly(4));\n                const port = decimalToNumber(await stream.readExactly(length));\n                deviceAddress = `tcp:${port}`;\n            } catch (e) {\n                if (\n                    e instanceof ExactReadableEndedError &&\n                    stream.position === position\n                ) {\n                    // Android <8 doesn't have this response.\n                    // (the stream is closed now)\n                    // Can be safely ignored.\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        return deviceAddress;\n    }\n\n    /**\n     * @param deviceAddress The address to be listened on device by ADB daemon. Or `tcp:0` to choose an available TCP port.\n     * @param handler A callback to handle incoming connections.\n     * @param localAddressThe The address that listens on the local machine. May be `undefined` to let the transport choose an appropriate one.\n     * @returns `tcp:{ACTUAL_LISTENING_PORT}`, If `deviceAddress` is `tcp:0`; otherwise, `deviceAddress`.\n     * @throws {AdbReverseNotSupportedError} If ADB reverse tunnel is not supported on this device when connected wirelessly.\n     * @throws {AdbReverseError} If ADB daemon returns an error.\n     */\n    async add(\n        deviceAddress: string,\n        handler: AdbIncomingSocketHandler,\n        localAddress?: string,\n    ): Promise<string> {\n        localAddress = await this.adb.transport.addReverseTunnel(\n            handler,\n            localAddress,\n        );\n\n        try {\n            deviceAddress = await this.addExternal(deviceAddress, localAddress);\n            this.#deviceAddressToLocalAddress.set(deviceAddress, localAddress);\n            return deviceAddress;\n        } catch (e) {\n            await this.adb.transport.removeReverseTunnel(localAddress);\n            throw e;\n        }\n    }\n\n    async remove(deviceAddress: string): Promise<void> {\n        const localAddress =\n            this.#deviceAddressToLocalAddress.get(deviceAddress);\n        if (localAddress) {\n            await this.adb.transport.removeReverseTunnel(localAddress);\n        }\n\n        await this.sendRequest(`reverse:killforward:${deviceAddress}`);\n\n        // No need to close the stream, device will close it\n    }\n\n    async removeAll(): Promise<void> {\n        await this.adb.transport.clearReverseTunnels();\n        this.#deviceAddressToLocalAddress.clear();\n\n        await this.sendRequest(`reverse:killforward-all`);\n\n        // No need to close the stream, device will close it\n    }\n}\n","export { decodeUtf8, encodeUtf8 } from \"@yume-chan/struct\";\nexport * from \"./auto-reset-event.js\";\nexport * from \"./base64.js\";\nexport * from \"./hex.js\";\nexport * from \"./no-op.js\";\nexport * from \"./sequence-equal.js\";\n","import { PromiseResolver } from \"@yume-chan/async\";\nexport class AutoResetEvent {\n    #set;\n    #queue = [];\n    constructor(initialSet = false) {\n        this.#set = initialSet;\n    }\n    wait() {\n        if (!this.#set) {\n            this.#set = true;\n            if (this.#queue.length === 0) {\n                return Promise.resolve();\n            }\n        }\n        const resolver = new PromiseResolver();\n        this.#queue.push(resolver);\n        return resolver.promise;\n    }\n    notifyOne() {\n        if (this.#queue.length !== 0) {\n            this.#queue.pop().resolve();\n        }\n        else {\n            this.#set = false;\n        }\n    }\n    dispose() {\n        for (const item of this.#queue) {\n            item.reject(new Error(\"The AutoResetEvent has been disposed\"));\n        }\n        this.#queue.length = 0;\n    }\n}\n//# sourceMappingURL=auto-reset-event.js.map","import { PromiseResolver } from \"@yume-chan/async\";\nimport type { Disposable } from \"@yume-chan/event\";\n\nexport class AutoResetEvent implements Disposable {\n    #set: boolean;\n    readonly #queue: PromiseResolver<void>[] = [];\n\n    constructor(initialSet = false) {\n        this.#set = initialSet;\n    }\n\n    wait(): Promise<void> {\n        if (!this.#set) {\n            this.#set = true;\n\n            if (this.#queue.length === 0) {\n                return Promise.resolve();\n            }\n        }\n\n        const resolver = new PromiseResolver<void>();\n        this.#queue.push(resolver);\n        return resolver.promise;\n    }\n\n    notifyOne() {\n        if (this.#queue.length !== 0) {\n            this.#queue.pop()!.resolve();\n        } else {\n            this.#set = false;\n        }\n    }\n\n    dispose() {\n        for (const item of this.#queue) {\n            item.reject(new Error(\"The AutoResetEvent has been disposed\"));\n        }\n        this.#queue.length = 0;\n    }\n}\n","// Array is faster than object literal or `Map`\nconst charToIndex = [];\nconst indexToChar = [];\nconst paddingChar = \"=\".charCodeAt(0);\nfunction addRange(start, end) {\n    const charCodeStart = start.charCodeAt(0);\n    const charCodeEnd = end.charCodeAt(0);\n    for (let charCode = charCodeStart; charCode <= charCodeEnd; charCode += 1) {\n        charToIndex[charCode] = indexToChar.length;\n        indexToChar.push(charCode);\n    }\n}\naddRange(\"A\", \"Z\");\naddRange(\"a\", \"z\");\naddRange(\"0\", \"9\");\naddRange(\"+\", \"+\");\naddRange(\"/\", \"/\");\n/**\n * Calculate the required length of the output buffer for the given input length.\n *\n * @param inputLength Length of the input in bytes\n * @returns Length of the output in bytes\n */\nexport function calculateBase64EncodedLength(inputLength) {\n    const remainder = inputLength % 3;\n    const paddingLength = remainder !== 0 ? 3 - remainder : 0;\n    return [((inputLength + paddingLength) / 3) * 4, paddingLength];\n}\nexport function encodeBase64(input, output) {\n    const [outputLength, paddingLength] = calculateBase64EncodedLength(input.length);\n    if (!output) {\n        output = new Uint8Array(outputLength);\n        encodeForward(input, output, paddingLength);\n        return output;\n    }\n    else {\n        if (output.length < outputLength) {\n            throw new TypeError(\"output buffer is too small\");\n        }\n        output = output.subarray(0, outputLength);\n        // When input and output are on same ArrayBuffer,\n        // we check if it's possible to encode in-place.\n        if (input.buffer !== output.buffer) {\n            encodeForward(input, output, paddingLength);\n        }\n        else if (output.byteOffset + output.length - (paddingLength + 1) <=\n            input.byteOffset + input.length) {\n            // Output ends before input ends.\n            // Can encode forwards, because writing output won't catch up with reading input.\n            // The output end is subtracted by `(paddingLength + 1)` because\n            // depending on padding length, it's possible to write 1-3 extra bytes after input ends.\n            //\n            // The following diagrams show how the last read from input and the last write to output\n            // are not conflicting.\n            //\n            // spell: disable\n            //\n            // `paddingLength === 2` can write 3 extra bytes:\n            //\n            //   input:  | aaaaaabb |          |          |          |\n            //   output: |  aaaaaa  |  bb0000  |    =     |    =     |\n            //\n            // `paddingLength === 1` can write 2 extra bytes:\n            //\n            //   input:  | aaaaaabb | bbbbcccc |          |          |\n            //   output: |  aaaaaa  |  bbbbbb  |  cccc00  |    =     |\n            //\n            // `paddingLength === 0` can write 1 extra byte:\n            //\n            //   input:  | aaaaaabb | bbbbcccc | ccdddddd |          |\n            //   output: |  aaaaaa  |  bbbbbb  |  cccccc  |  dddddd  |\n            //\n            // spell: enable\n            encodeForward(input, output, paddingLength);\n        }\n        else if (output.byteOffset >= input.byteOffset - 1) {\n            // Output starts after input starts\n            // So in backwards, writing output won't catch up with reading input.\n            // The input start is subtracted by `1`, Because as the first 3 bytes becomes 4 bytes,\n            // it's possible to write 1 extra byte before input starts.\n            // spell: disable-next-line\n            //   input:  |          | aaaaaabb | bbbbcccc | ccdddddd |\n            //   output: |  aaaaaa  |  bbbbbb  |  cccccc  |  dddddd  |\n            // Must encode backwards.\n            encodeBackward(input, output, paddingLength);\n        }\n        else {\n            // Input is in the middle of output,\n            // It's not possible to read either the first or the last three bytes\n            // before they are overwritten by the output.\n            throw new TypeError(\"input and output cannot overlap\");\n        }\n        return outputLength;\n    }\n}\nfunction encodeForward(input, output, paddingLength) {\n    let inputIndex = 0;\n    let outputIndex = 0;\n    while (inputIndex < input.length - 2) {\n        /* cspell: disable-next-line */\n        // aaaaaabb\n        const x = input[inputIndex];\n        inputIndex += 1;\n        /* cspell: disable-next-line */\n        // bbbbcccc\n        const y = input[inputIndex];\n        inputIndex += 1;\n        /* cspell: disable-next-line */\n        // ccdddddd\n        const z = input[inputIndex];\n        inputIndex += 1;\n        output[outputIndex] = indexToChar[x >> 2];\n        outputIndex += 1;\n        output[outputIndex] = indexToChar[((x & 0b11) << 4) | (y >> 4)];\n        outputIndex += 1;\n        output[outputIndex] = indexToChar[((y & 0b1111) << 2) | (z >> 6)];\n        outputIndex += 1;\n        output[outputIndex] = indexToChar[z & 0b111111];\n        outputIndex += 1;\n    }\n    if (paddingLength === 2) {\n        /* cspell: disable-next-line */\n        // aaaaaabb\n        const x = input[inputIndex];\n        inputIndex += 1;\n        output[outputIndex] = indexToChar[x >> 2];\n        outputIndex += 1;\n        output[outputIndex] = indexToChar[(x & 0b11) << 4];\n        outputIndex += 1;\n        output[outputIndex] = paddingChar;\n        outputIndex += 1;\n        output[outputIndex] = paddingChar;\n    }\n    else if (paddingLength === 1) {\n        /* cspell: disable-next-line */\n        // aaaaaabb\n        const x = input[inputIndex];\n        inputIndex += 1;\n        /* cspell: disable-next-line */\n        // bbbbcccc\n        const y = input[inputIndex];\n        inputIndex += 1;\n        output[outputIndex] = indexToChar[x >> 2];\n        outputIndex += 1;\n        output[outputIndex] = indexToChar[((x & 0b11) << 4) | (y >> 4)];\n        outputIndex += 1;\n        output[outputIndex] = indexToChar[(y & 0b1111) << 2];\n        outputIndex += 1;\n        output[outputIndex] = paddingChar;\n    }\n}\nfunction encodeBackward(input, output, paddingLength) {\n    let inputIndex = input.length - 1;\n    let outputIndex = output.length - 1;\n    if (paddingLength === 2) {\n        /* cspell: disable-next-line */\n        // aaaaaabb\n        const x = input[inputIndex];\n        inputIndex -= 1;\n        output[outputIndex] = paddingChar;\n        outputIndex -= 1;\n        output[outputIndex] = paddingChar;\n        outputIndex -= 1;\n        output[outputIndex] = indexToChar[(x & 0b11) << 4];\n        outputIndex -= 1;\n        output[outputIndex] = indexToChar[x >> 2];\n        outputIndex -= 1;\n    }\n    else if (paddingLength === 1) {\n        /* cspell: disable-next-line */\n        // bbbbcccc\n        const y = input[inputIndex];\n        inputIndex -= 1;\n        /* cspell: disable-next-line */\n        // aaaaaabb\n        const x = input[inputIndex];\n        inputIndex -= 1;\n        output[outputIndex] = paddingChar;\n        outputIndex -= 1;\n        output[outputIndex] = indexToChar[(y & 0b1111) << 2];\n        outputIndex -= 1;\n        output[outputIndex] = indexToChar[((x & 0b11) << 4) | (y >> 4)];\n        outputIndex -= 1;\n        output[outputIndex] = indexToChar[x >> 2];\n        outputIndex -= 1;\n    }\n    while (inputIndex >= 0) {\n        /* cspell: disable-next-line */\n        // ccdddddd\n        const z = input[inputIndex];\n        inputIndex -= 1;\n        /* cspell: disable-next-line */\n        // bbbbcccc\n        const y = input[inputIndex];\n        inputIndex -= 1;\n        /* cspell: disable-next-line */\n        // aaaaaabb\n        const x = input[inputIndex];\n        inputIndex -= 1;\n        output[outputIndex] = indexToChar[z & 0b111111];\n        outputIndex -= 1;\n        output[outputIndex] = indexToChar[((y & 0b1111) << 2) | (z >> 6)];\n        outputIndex -= 1;\n        output[outputIndex] = indexToChar[((x & 0b11) << 4) | (y >> 4)];\n        outputIndex -= 1;\n        output[outputIndex] = indexToChar[x >> 2];\n        outputIndex -= 1;\n    }\n}\nexport function decodeBase64(input) {\n    let padding;\n    if (input[input.length - 2] === \"=\") {\n        padding = 2;\n    }\n    else if (input[input.length - 1] === \"=\") {\n        padding = 1;\n    }\n    else {\n        padding = 0;\n    }\n    const result = new Uint8Array((input.length / 4) * 3 - padding);\n    let sIndex = 0;\n    let dIndex = 0;\n    while (sIndex < input.length - (padding !== 0 ? 4 : 0)) {\n        const a = charToIndex[input.charCodeAt(sIndex)];\n        sIndex += 1;\n        const b = charToIndex[input.charCodeAt(sIndex)];\n        sIndex += 1;\n        const c = charToIndex[input.charCodeAt(sIndex)];\n        sIndex += 1;\n        const d = charToIndex[input.charCodeAt(sIndex)];\n        sIndex += 1;\n        result[dIndex] = (a << 2) | ((b & 0b11_0000) >> 4);\n        dIndex += 1;\n        result[dIndex] = ((b & 0b1111) << 4) | ((c & 0b11_1100) >> 2);\n        dIndex += 1;\n        result[dIndex] = ((c & 0b11) << 6) | d;\n        dIndex += 1;\n    }\n    if (padding === 1) {\n        const a = charToIndex[input.charCodeAt(sIndex)];\n        sIndex += 1;\n        const b = charToIndex[input.charCodeAt(sIndex)];\n        sIndex += 1;\n        const c = charToIndex[input.charCodeAt(sIndex)];\n        result[dIndex] = (a << 2) | ((b & 0b11_0000) >> 4);\n        dIndex += 1;\n        result[dIndex] = ((b & 0b1111) << 4) | ((c & 0b11_1100) >> 2);\n    }\n    else if (padding === 2) {\n        const a = charToIndex[input.charCodeAt(sIndex)];\n        sIndex += 1;\n        const b = charToIndex[input.charCodeAt(sIndex)];\n        result[dIndex] = (a << 2) | ((b & 0b11_0000) >> 4);\n    }\n    return result;\n}\n//# sourceMappingURL=base64.js.map","// Array is faster than object literal or `Map`\nconst charToIndex: number[] = [];\nconst indexToChar: number[] = [];\nconst paddingChar = \"=\".charCodeAt(0);\n\nfunction addRange(start: string, end: string) {\n    const charCodeStart = start.charCodeAt(0);\n    const charCodeEnd = end.charCodeAt(0);\n\n    for (let charCode = charCodeStart; charCode <= charCodeEnd; charCode += 1) {\n        charToIndex[charCode] = indexToChar.length;\n        indexToChar.push(charCode);\n    }\n}\n\naddRange(\"A\", \"Z\");\naddRange(\"a\", \"z\");\naddRange(\"0\", \"9\");\naddRange(\"+\", \"+\");\naddRange(\"/\", \"/\");\n\n/**\n * Calculate the required length of the output buffer for the given input length.\n *\n * @param inputLength Length of the input in bytes\n * @returns Length of the output in bytes\n */\nexport function calculateBase64EncodedLength(\n    inputLength: number,\n): [outputLength: number, paddingLength: number] {\n    const remainder = inputLength % 3;\n    const paddingLength = remainder !== 0 ? 3 - remainder : 0;\n    return [((inputLength + paddingLength) / 3) * 4, paddingLength];\n}\n\n/**\n * Encode the given input buffer into base64.\n *\n * @param input The input buffer\n * @returns The encoded output buffer\n */\nexport function encodeBase64(input: Uint8Array): Uint8Array;\n/**\n * Encode the given input into base64 and write it to the output buffer.\n *\n * The output buffer must be at least as long as the value returned by `calculateBase64EncodedLength`.\n * It can points to the same buffer as the input, as long as `output.offset <= input.offset - input.length / 3`,\n * or `output.offset >= input.offset - 1`\n *\n * @param input The input buffer\n * @param output The output buffer\n * @returns The number of bytes written to the output buffer\n */\nexport function encodeBase64(input: Uint8Array, output: Uint8Array): number;\nexport function encodeBase64(\n    input: Uint8Array,\n    output?: Uint8Array,\n): Uint8Array | number {\n    const [outputLength, paddingLength] = calculateBase64EncodedLength(\n        input.length,\n    );\n\n    if (!output) {\n        output = new Uint8Array(outputLength);\n        encodeForward(input, output, paddingLength);\n        return output;\n    } else {\n        if (output.length < outputLength) {\n            throw new TypeError(\"output buffer is too small\");\n        }\n\n        output = output.subarray(0, outputLength);\n\n        // When input and output are on same ArrayBuffer,\n        // we check if it's possible to encode in-place.\n        if (input.buffer !== output.buffer) {\n            encodeForward(input, output, paddingLength);\n        } else if (\n            output.byteOffset + output.length - (paddingLength + 1) <=\n            input.byteOffset + input.length\n        ) {\n            // Output ends before input ends.\n            // Can encode forwards, because writing output won't catch up with reading input.\n\n            // The output end is subtracted by `(paddingLength + 1)` because\n            // depending on padding length, it's possible to write 1-3 extra bytes after input ends.\n            //\n            // The following diagrams show how the last read from input and the last write to output\n            // are not conflicting.\n            //\n            // spell: disable\n            //\n            // `paddingLength === 2` can write 3 extra bytes:\n            //\n            //   input:  | aaaaaabb |          |          |          |\n            //   output: |  aaaaaa  |  bb0000  |    =     |    =     |\n            //\n            // `paddingLength === 1` can write 2 extra bytes:\n            //\n            //   input:  | aaaaaabb | bbbbcccc |          |          |\n            //   output: |  aaaaaa  |  bbbbbb  |  cccc00  |    =     |\n            //\n            // `paddingLength === 0` can write 1 extra byte:\n            //\n            //   input:  | aaaaaabb | bbbbcccc | ccdddddd |          |\n            //   output: |  aaaaaa  |  bbbbbb  |  cccccc  |  dddddd  |\n            //\n            // spell: enable\n\n            encodeForward(input, output, paddingLength);\n        } else if (output.byteOffset >= input.byteOffset - 1) {\n            // Output starts after input starts\n            // So in backwards, writing output won't catch up with reading input.\n\n            // The input start is subtracted by `1`, Because as the first 3 bytes becomes 4 bytes,\n            // it's possible to write 1 extra byte before input starts.\n            // spell: disable-next-line\n            //   input:  |          | aaaaaabb | bbbbcccc | ccdddddd |\n            //   output: |  aaaaaa  |  bbbbbb  |  cccccc  |  dddddd  |\n\n            // Must encode backwards.\n            encodeBackward(input, output, paddingLength);\n        } else {\n            // Input is in the middle of output,\n            // It's not possible to read either the first or the last three bytes\n            // before they are overwritten by the output.\n            throw new TypeError(\"input and output cannot overlap\");\n        }\n\n        return outputLength;\n    }\n}\n\nfunction encodeForward(\n    input: Uint8Array,\n    output: Uint8Array,\n    paddingLength: number,\n) {\n    let inputIndex = 0;\n    let outputIndex = 0;\n\n    while (inputIndex < input.length - 2) {\n        /* cspell: disable-next-line */\n        // aaaaaabb\n        const x = input[inputIndex]!;\n        inputIndex += 1;\n\n        /* cspell: disable-next-line */\n        // bbbbcccc\n        const y = input[inputIndex]!;\n        inputIndex += 1;\n\n        /* cspell: disable-next-line */\n        // ccdddddd\n        const z = input[inputIndex]!;\n        inputIndex += 1;\n\n        output[outputIndex] = indexToChar[x >> 2]!;\n        outputIndex += 1;\n\n        output[outputIndex] = indexToChar[((x & 0b11) << 4) | (y >> 4)]!;\n        outputIndex += 1;\n\n        output[outputIndex] = indexToChar[((y & 0b1111) << 2) | (z >> 6)]!;\n        outputIndex += 1;\n\n        output[outputIndex] = indexToChar[z & 0b111111]!;\n        outputIndex += 1;\n    }\n\n    if (paddingLength === 2) {\n        /* cspell: disable-next-line */\n        // aaaaaabb\n        const x = input[inputIndex]!;\n        inputIndex += 1;\n\n        output[outputIndex] = indexToChar[x >> 2]!;\n        outputIndex += 1;\n\n        output[outputIndex] = indexToChar[(x & 0b11) << 4]!;\n        outputIndex += 1;\n\n        output[outputIndex] = paddingChar;\n        outputIndex += 1;\n\n        output[outputIndex] = paddingChar;\n    } else if (paddingLength === 1) {\n        /* cspell: disable-next-line */\n        // aaaaaabb\n        const x = input[inputIndex]!;\n        inputIndex += 1;\n\n        /* cspell: disable-next-line */\n        // bbbbcccc\n        const y = input[inputIndex]!;\n        inputIndex += 1;\n\n        output[outputIndex] = indexToChar[x >> 2]!;\n        outputIndex += 1;\n\n        output[outputIndex] = indexToChar[((x & 0b11) << 4) | (y >> 4)]!;\n        outputIndex += 1;\n\n        output[outputIndex] = indexToChar[(y & 0b1111) << 2]!;\n        outputIndex += 1;\n\n        output[outputIndex] = paddingChar;\n    }\n}\n\nfunction encodeBackward(\n    input: Uint8Array,\n    output: Uint8Array,\n    paddingLength: number,\n) {\n    let inputIndex = input.length - 1;\n    let outputIndex = output.length - 1;\n\n    if (paddingLength === 2) {\n        /* cspell: disable-next-line */\n        // aaaaaabb\n        const x = input[inputIndex]!;\n        inputIndex -= 1;\n\n        output[outputIndex] = paddingChar;\n        outputIndex -= 1;\n\n        output[outputIndex] = paddingChar;\n        outputIndex -= 1;\n\n        output[outputIndex] = indexToChar[(x & 0b11) << 4]!;\n        outputIndex -= 1;\n\n        output[outputIndex] = indexToChar[x >> 2]!;\n        outputIndex -= 1;\n    } else if (paddingLength === 1) {\n        /* cspell: disable-next-line */\n        // bbbbcccc\n        const y = input[inputIndex]!;\n        inputIndex -= 1;\n\n        /* cspell: disable-next-line */\n        // aaaaaabb\n        const x = input[inputIndex]!;\n        inputIndex -= 1;\n\n        output[outputIndex] = paddingChar;\n        outputIndex -= 1;\n\n        output[outputIndex] = indexToChar[(y & 0b1111) << 2]!;\n        outputIndex -= 1;\n\n        output[outputIndex] = indexToChar[((x & 0b11) << 4) | (y >> 4)]!;\n        outputIndex -= 1;\n\n        output[outputIndex] = indexToChar[x >> 2]!;\n        outputIndex -= 1;\n    }\n\n    while (inputIndex >= 0) {\n        /* cspell: disable-next-line */\n        // ccdddddd\n        const z = input[inputIndex]!;\n        inputIndex -= 1;\n\n        /* cspell: disable-next-line */\n        // bbbbcccc\n        const y = input[inputIndex]!;\n        inputIndex -= 1;\n\n        /* cspell: disable-next-line */\n        // aaaaaabb\n        const x = input[inputIndex]!;\n        inputIndex -= 1;\n\n        output[outputIndex] = indexToChar[z & 0b111111]!;\n        outputIndex -= 1;\n\n        output[outputIndex] = indexToChar[((y & 0b1111) << 2) | (z >> 6)]!;\n        outputIndex -= 1;\n\n        output[outputIndex] = indexToChar[((x & 0b11) << 4) | (y >> 4)]!;\n        outputIndex -= 1;\n\n        output[outputIndex] = indexToChar[x >> 2]!;\n        outputIndex -= 1;\n    }\n}\n\nexport function decodeBase64(input: string): Uint8Array {\n    let padding: number;\n    if (input[input.length - 2] === \"=\") {\n        padding = 2;\n    } else if (input[input.length - 1] === \"=\") {\n        padding = 1;\n    } else {\n        padding = 0;\n    }\n\n    const result = new Uint8Array((input.length / 4) * 3 - padding);\n    let sIndex = 0;\n    let dIndex = 0;\n\n    while (sIndex < input.length - (padding !== 0 ? 4 : 0)) {\n        const a = charToIndex[input.charCodeAt(sIndex)]!;\n        sIndex += 1;\n\n        const b = charToIndex[input.charCodeAt(sIndex)]!;\n        sIndex += 1;\n\n        const c = charToIndex[input.charCodeAt(sIndex)]!;\n        sIndex += 1;\n\n        const d = charToIndex[input.charCodeAt(sIndex)]!;\n        sIndex += 1;\n\n        result[dIndex] = (a << 2) | ((b & 0b11_0000) >> 4);\n        dIndex += 1;\n\n        result[dIndex] = ((b & 0b1111) << 4) | ((c & 0b11_1100) >> 2);\n        dIndex += 1;\n\n        result[dIndex] = ((c & 0b11) << 6) | d;\n        dIndex += 1;\n    }\n\n    if (padding === 1) {\n        const a = charToIndex[input.charCodeAt(sIndex)]!;\n        sIndex += 1;\n\n        const b = charToIndex[input.charCodeAt(sIndex)]!;\n        sIndex += 1;\n\n        const c = charToIndex[input.charCodeAt(sIndex)]!;\n\n        result[dIndex] = (a << 2) | ((b & 0b11_0000) >> 4);\n        dIndex += 1;\n\n        result[dIndex] = ((b & 0b1111) << 4) | ((c & 0b11_1100) >> 2);\n    } else if (padding === 2) {\n        const a = charToIndex[input.charCodeAt(sIndex)]!;\n        sIndex += 1;\n\n        const b = charToIndex[input.charCodeAt(sIndex)]!;\n\n        result[dIndex] = (a << 2) | ((b & 0b11_0000) >> 4);\n    }\n\n    return result;\n}\n","function hexCharToNumber(char) {\n    if (char < 48) {\n        throw new TypeError(`Invalid hex char ${char}`);\n    }\n    if (char < 58) {\n        // 0-9\n        return char - 48;\n    }\n    if (char < 65) {\n        throw new TypeError(`Invalid hex char ${char}`);\n    }\n    if (char < 71) {\n        // A-F\n        return char - 55;\n    }\n    if (char < 97) {\n        throw new TypeError(`Invalid hex char ${char}`);\n    }\n    if (char < 103) {\n        // a-f\n        return char - 87;\n    }\n    throw new TypeError(`Invalid hex char ${char}`);\n}\n// It's 22x faster than converting `data` to string then `Number.parseInt`\n// https://jsbench.me/dglha94ozl/1\nexport function hexToNumber(data) {\n    let result = 0;\n    for (let i = 0; i < data.length; i += 1) {\n        result = (result << 4) | hexCharToNumber(data[i]);\n    }\n    return result;\n}\nexport function write4HexDigits(buffer, index, value) {\n    const start = index;\n    index += 3;\n    while (index >= start && value > 0) {\n        const digit = value & 0xf;\n        value >>= 4;\n        if (digit < 10) {\n            buffer[index] = digit + 48; // '0'\n        }\n        else {\n            buffer[index] = digit + 87; // 'a' - 10\n        }\n        index -= 1;\n    }\n    while (index >= start) {\n        buffer[index] = 48; // '0'\n        index -= 1;\n    }\n}\n//# sourceMappingURL=hex.js.map","function hexCharToNumber(char: number) {\n    if (char < 48) {\n        throw new TypeError(`Invalid hex char ${char}`);\n    }\n    if (char < 58) {\n        // 0-9\n        return char - 48;\n    }\n\n    if (char < 65) {\n        throw new TypeError(`Invalid hex char ${char}`);\n    }\n    if (char < 71) {\n        // A-F\n        return char - 55;\n    }\n\n    if (char < 97) {\n        throw new TypeError(`Invalid hex char ${char}`);\n    }\n    if (char < 103) {\n        // a-f\n        return char - 87;\n    }\n\n    throw new TypeError(`Invalid hex char ${char}`);\n}\n\n// It's 22x faster than converting `data` to string then `Number.parseInt`\n// https://jsbench.me/dglha94ozl/1\nexport function hexToNumber(data: Uint8Array): number {\n    let result = 0;\n    for (let i = 0; i < data.length; i += 1) {\n        result = (result << 4) | hexCharToNumber(data[i]!);\n    }\n    return result;\n}\n\nexport function write4HexDigits(\n    buffer: Uint8Array,\n    index: number,\n    value: number,\n) {\n    const start = index;\n    index += 3;\n    while (index >= start && value > 0) {\n        const digit = value & 0xf;\n        value >>= 4;\n        if (digit < 10) {\n            buffer[index] = digit + 48; // '0'\n        } else {\n            buffer[index] = digit + 87; // 'a' - 10\n        }\n        index -= 1;\n    }\n    while (index >= start) {\n        buffer[index] = 48; // '0'\n        index -= 1;\n    }\n}\n","export const NOOP = () => {\n    // no-op\n};\n/**\n * When used in `Promise#catch`, means the promise should never throw errors.\n * An explicit way to suppress ESLint floating promise warnings.\n */\nexport function unreachable(...args) {\n    // Trigger runtime's unhandled rejection event.\n    throw new Error(\"Unreachable. Arguments:\\n\" + args.join(\"\\n\"));\n}\n//# sourceMappingURL=no-op.js.map","export const NOOP = () => {\n    // no-op\n};\n\n/**\n * When used in `Promise#catch`, means the promise should never throw errors.\n * An explicit way to suppress ESLint floating promise warnings.\n */\nexport function unreachable(...args: unknown[]): never {\n    // Trigger runtime's unhandled rejection event.\n    throw new Error(\"Unreachable. Arguments:\\n\" + args.join(\"\\n\"));\n}\n","export function sequenceEqual(a, b) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    for (let i = 0; i < a.length; i += 1) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n//# sourceMappingURL=sequence-equal.js.map","export function sequenceEqual(a: Uint8Array, b: Uint8Array): boolean {\n    if (a.length !== b.length) {\n        return false;\n    }\n\n    for (let i = 0; i < a.length; i += 1) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n","export * from \"./command.js\";\nexport * from \"./protocols/index.js\";\nexport * from \"./utils.js\";\n","import { ConcatStringStream, TextDecoderStream } from \"@yume-chan/stream-extra\";\nimport { AdbCommandBase } from \"../base.js\";\nimport { AdbSubprocessNoneProtocol, AdbSubprocessShellProtocol, } from \"./protocols/index.js\";\nconst DEFAULT_OPTIONS = {\n    protocols: [AdbSubprocessShellProtocol, AdbSubprocessNoneProtocol],\n};\nexport class AdbSubprocess extends AdbCommandBase {\n    async #createProtocol(mode, command, options) {\n        const { protocols } = { ...DEFAULT_OPTIONS, ...options };\n        let Constructor;\n        for (const item of protocols) {\n            // It's async so can't use `Array#find`\n            if (await item.isSupported(this.adb)) {\n                Constructor = item;\n                break;\n            }\n        }\n        if (!Constructor) {\n            throw new Error(\"No specified protocol is supported by the device\");\n        }\n        if (Array.isArray(command)) {\n            command = command.join(\" \");\n        }\n        else if (command === undefined) {\n            // spawn the default shell\n            command = \"\";\n        }\n        return await Constructor[mode](this.adb, command);\n    }\n    /**\n     * Spawns an executable in PTY mode.\n     *\n     * Redirection mode is enough for most simple commands, but PTY mode is required for\n     * commands that manipulate the terminal, such as `vi` and `less`.\n     * @param command The command to run. If omitted, the default shell will be spawned.\n     * @param options The options for creating the `AdbSubprocessProtocol`\n     * @returns A new `AdbSubprocessProtocol` instance connecting to the spawned process.\n     */\n    shell(command, options) {\n        return this.#createProtocol(\"pty\", command, options);\n    }\n    /**\n     * Spawns an executable and redirect the standard input/output stream.\n     *\n     * Redirection mode is enough for most simple commands, but PTY mode is required for\n     * commands that manipulate the terminal, such as `vi` and `less`.\n     * @param command The command to run, or an array of strings containing both command and args.\n     * @param options The options for creating the `AdbSubprocessProtocol`\n     * @returns A new `AdbSubprocessProtocol` instance connecting to the spawned process.\n     */\n    spawn(command, options) {\n        return this.#createProtocol(\"raw\", command, options);\n    }\n    /**\n     * Spawns a new process, waits until it exits, and returns the entire output.\n     * @param command The command to run\n     * @param options The options for creating the `AdbSubprocessProtocol`\n     * @returns The entire output of the command\n     */\n    async spawnAndWait(command, options) {\n        const process = await this.spawn(command, options);\n        const [stdout, stderr, exitCode] = await Promise.all([\n            process.stdout\n                .pipeThrough(new TextDecoderStream())\n                .pipeThrough(new ConcatStringStream()),\n            process.stderr\n                .pipeThrough(new TextDecoderStream())\n                .pipeThrough(new ConcatStringStream()),\n            process.exit,\n        ]);\n        return {\n            stdout,\n            stderr,\n            exitCode,\n        };\n    }\n    /**\n     * Spawns a new process, waits until it exits, and returns the entire output.\n     * @param command The command to run\n     * @returns The entire output of the command\n     */\n    async spawnAndWaitLegacy(command) {\n        const { stdout } = await this.spawnAndWait(command, {\n            protocols: [AdbSubprocessNoneProtocol],\n        });\n        return stdout;\n    }\n}\n//# sourceMappingURL=command.js.map","import { ConcatStringStream, TextDecoderStream } from \"@yume-chan/stream-extra\";\n\nimport { AdbCommandBase } from \"../base.js\";\n\nimport type {\n    AdbSubprocessProtocol,\n    AdbSubprocessProtocolConstructor,\n} from \"./protocols/index.js\";\nimport {\n    AdbSubprocessNoneProtocol,\n    AdbSubprocessShellProtocol,\n} from \"./protocols/index.js\";\n\nexport interface AdbSubprocessOptions {\n    /**\n     * A list of `AdbSubprocessProtocolConstructor`s to be used.\n     *\n     * Different `AdbSubprocessProtocol` has different capabilities, thus requires specific adaptations.\n     * Check their documentations for details.\n     *\n     * The first protocol whose `isSupported` returns `true` will be used.\n     * If no `AdbSubprocessProtocol` is supported, an error will be thrown.\n     *\n     * @default [AdbSubprocessShellProtocol, AdbSubprocessNoneProtocol]\n     */\n    protocols: AdbSubprocessProtocolConstructor[];\n}\n\nconst DEFAULT_OPTIONS: AdbSubprocessOptions = {\n    protocols: [AdbSubprocessShellProtocol, AdbSubprocessNoneProtocol],\n};\n\nexport interface AdbSubprocessWaitResult {\n    stdout: string;\n    stderr: string;\n    exitCode: number;\n}\n\nexport class AdbSubprocess extends AdbCommandBase {\n    async #createProtocol(\n        mode: \"pty\" | \"raw\",\n        command?: string | string[],\n        options?: Partial<AdbSubprocessOptions>,\n    ): Promise<AdbSubprocessProtocol> {\n        const { protocols } = { ...DEFAULT_OPTIONS, ...options };\n\n        let Constructor: AdbSubprocessProtocolConstructor | undefined;\n        for (const item of protocols) {\n            // It's async so can't use `Array#find`\n            if (await item.isSupported(this.adb)) {\n                Constructor = item;\n                break;\n            }\n        }\n\n        if (!Constructor) {\n            throw new Error(\"No specified protocol is supported by the device\");\n        }\n\n        if (Array.isArray(command)) {\n            command = command.join(\" \");\n        } else if (command === undefined) {\n            // spawn the default shell\n            command = \"\";\n        }\n        return await Constructor[mode](this.adb, command);\n    }\n\n    /**\n     * Spawns an executable in PTY mode.\n     *\n     * Redirection mode is enough for most simple commands, but PTY mode is required for\n     * commands that manipulate the terminal, such as `vi` and `less`.\n     * @param command The command to run. If omitted, the default shell will be spawned.\n     * @param options The options for creating the `AdbSubprocessProtocol`\n     * @returns A new `AdbSubprocessProtocol` instance connecting to the spawned process.\n     */\n    shell(\n        command?: string | string[],\n        options?: Partial<AdbSubprocessOptions>,\n    ): Promise<AdbSubprocessProtocol> {\n        return this.#createProtocol(\"pty\", command, options);\n    }\n\n    /**\n     * Spawns an executable and redirect the standard input/output stream.\n     *\n     * Redirection mode is enough for most simple commands, but PTY mode is required for\n     * commands that manipulate the terminal, such as `vi` and `less`.\n     * @param command The command to run, or an array of strings containing both command and args.\n     * @param options The options for creating the `AdbSubprocessProtocol`\n     * @returns A new `AdbSubprocessProtocol` instance connecting to the spawned process.\n     */\n    spawn(\n        command: string | string[],\n        options?: Partial<AdbSubprocessOptions>,\n    ): Promise<AdbSubprocessProtocol> {\n        return this.#createProtocol(\"raw\", command, options);\n    }\n\n    /**\n     * Spawns a new process, waits until it exits, and returns the entire output.\n     * @param command The command to run\n     * @param options The options for creating the `AdbSubprocessProtocol`\n     * @returns The entire output of the command\n     */\n    async spawnAndWait(\n        command: string | string[],\n        options?: Partial<AdbSubprocessOptions>,\n    ): Promise<AdbSubprocessWaitResult> {\n        const process = await this.spawn(command, options);\n\n        const [stdout, stderr, exitCode] = await Promise.all([\n            process.stdout\n                .pipeThrough(new TextDecoderStream())\n                .pipeThrough(new ConcatStringStream()),\n            process.stderr\n                .pipeThrough(new TextDecoderStream())\n                .pipeThrough(new ConcatStringStream()),\n            process.exit,\n        ]);\n\n        return {\n            stdout,\n            stderr,\n            exitCode,\n        };\n    }\n\n    /**\n     * Spawns a new process, waits until it exits, and returns the entire output.\n     * @param command The command to run\n     * @returns The entire output of the command\n     */\n    async spawnAndWaitLegacy(command: string | string[]): Promise<string> {\n        const { stdout } = await this.spawnAndWait(command, {\n            protocols: [AdbSubprocessNoneProtocol],\n        });\n        return stdout;\n    }\n}\n","export * from \"./none.js\";\nexport * from \"./shell.js\";\nexport * from \"./types.js\";\n","import { ReadableStream } from \"@yume-chan/stream-extra\";\nimport { unreachable } from \"../../../utils/index.js\";\n/**\n * The legacy shell\n *\n * Features:\n * * `stderr`: No\n * * `exit` exit code: No\n * * `resize`: No\n */\nexport class AdbSubprocessNoneProtocol {\n    static isSupported() {\n        return true;\n    }\n    static async pty(adb, command) {\n        return new AdbSubprocessNoneProtocol(await adb.createSocket(`shell:${command}`));\n    }\n    static async raw(adb, command) {\n        // `shell,raw:${command}` also triggers raw mode,\n        // But is not supported on Android version <7.\n        return new AdbSubprocessNoneProtocol(await adb.createSocket(`exec:${command}`));\n    }\n    #socket;\n    // Legacy shell forwards all data to stdin.\n    get stdin() {\n        return this.#socket.writable;\n    }\n    /**\n     * Legacy shell mixes stdout and stderr.\n     */\n    get stdout() {\n        return this.#socket.readable;\n    }\n    #stderr;\n    /**\n     * `stderr` will always be empty.\n     */\n    get stderr() {\n        return this.#stderr;\n    }\n    #exit;\n    get exit() {\n        return this.#exit;\n    }\n    constructor(socket) {\n        this.#socket = socket;\n        this.#stderr = new ReadableStream({\n            start: (controller) => {\n                this.#socket.closed\n                    .then(() => controller.close())\n                    .catch(unreachable);\n            },\n        });\n        this.#exit = socket.closed.then(() => 0);\n    }\n    resize() {\n        // Not supported, but don't throw.\n    }\n    async kill() {\n        await this.#socket.close();\n    }\n}\n//# sourceMappingURL=none.js.map","import type { MaybeConsumable, WritableStream } from \"@yume-chan/stream-extra\";\nimport { ReadableStream } from \"@yume-chan/stream-extra\";\n\nimport type { Adb, AdbSocket } from \"../../../adb.js\";\nimport { unreachable } from \"../../../utils/index.js\";\n\nimport type { AdbSubprocessProtocol } from \"./types.js\";\n\n/**\n * The legacy shell\n *\n * Features:\n * * `stderr`: No\n * * `exit` exit code: No\n * * `resize`: No\n */\nexport class AdbSubprocessNoneProtocol implements AdbSubprocessProtocol {\n    static isSupported() {\n        return true;\n    }\n\n    static async pty(adb: Adb, command: string) {\n        return new AdbSubprocessNoneProtocol(\n            await adb.createSocket(`shell:${command}`),\n        );\n    }\n\n    static async raw(adb: Adb, command: string) {\n        // `shell,raw:${command}` also triggers raw mode,\n        // But is not supported on Android version <7.\n        return new AdbSubprocessNoneProtocol(\n            await adb.createSocket(`exec:${command}`),\n        );\n    }\n\n    readonly #socket: AdbSocket;\n\n    // Legacy shell forwards all data to stdin.\n    get stdin(): WritableStream<MaybeConsumable<Uint8Array>> {\n        return this.#socket.writable;\n    }\n\n    /**\n     * Legacy shell mixes stdout and stderr.\n     */\n    get stdout(): ReadableStream<Uint8Array> {\n        return this.#socket.readable;\n    }\n\n    #stderr: ReadableStream<Uint8Array>;\n    /**\n     * `stderr` will always be empty.\n     */\n    get stderr(): ReadableStream<Uint8Array> {\n        return this.#stderr;\n    }\n\n    #exit: Promise<number>;\n    get exit() {\n        return this.#exit;\n    }\n\n    constructor(socket: AdbSocket) {\n        this.#socket = socket;\n\n        this.#stderr = new ReadableStream({\n            start: (controller) => {\n                this.#socket.closed\n                    .then(() => controller.close())\n                    .catch(unreachable);\n            },\n        });\n        this.#exit = socket.closed.then(() => 0);\n    }\n\n    resize() {\n        // Not supported, but don't throw.\n    }\n\n    async kill() {\n        await this.#socket.close();\n    }\n}\n","import { PromiseResolver } from \"@yume-chan/async\";\nimport { MaybeConsumable, PushReadableStream, StructDeserializeStream, WritableStream, } from \"@yume-chan/stream-extra\";\nimport Struct, { placeholder } from \"@yume-chan/struct\";\nimport { AdbFeature } from \"../../../features.js\";\nimport { encodeUtf8 } from \"../../../utils/index.js\";\nexport var AdbShellProtocolId;\n(function (AdbShellProtocolId) {\n    AdbShellProtocolId[AdbShellProtocolId[\"Stdin\"] = 0] = \"Stdin\";\n    AdbShellProtocolId[AdbShellProtocolId[\"Stdout\"] = 1] = \"Stdout\";\n    AdbShellProtocolId[AdbShellProtocolId[\"Stderr\"] = 2] = \"Stderr\";\n    AdbShellProtocolId[AdbShellProtocolId[\"Exit\"] = 3] = \"Exit\";\n    AdbShellProtocolId[AdbShellProtocolId[\"CloseStdin\"] = 4] = \"CloseStdin\";\n    AdbShellProtocolId[AdbShellProtocolId[\"WindowSizeChange\"] = 5] = \"WindowSizeChange\";\n})(AdbShellProtocolId || (AdbShellProtocolId = {}));\n// This packet format is used in both direction.\nconst AdbShellProtocolPacket = new Struct({ littleEndian: true })\n    .uint8(\"id\", placeholder())\n    .uint32(\"length\")\n    .uint8Array(\"data\", { lengthField: \"length\" });\n/**\n * Shell v2 a.k.a Shell Protocol\n *\n * Features:\n * * `stderr`: Yes\n * * `exit` exit code: Yes\n * * `resize`: Yes\n */\nexport class AdbSubprocessShellProtocol {\n    static isSupported(adb) {\n        return adb.canUseFeature(AdbFeature.ShellV2);\n    }\n    static async pty(adb, command) {\n        // TODO: AdbShellSubprocessProtocol: Support setting `XTERM` environment variable\n        return new AdbSubprocessShellProtocol(await adb.createSocket(`shell,v2,pty:${command}`));\n    }\n    static async raw(adb, command) {\n        return new AdbSubprocessShellProtocol(await adb.createSocket(`shell,v2,raw:${command}`));\n    }\n    #socket;\n    #writer;\n    #stdin;\n    get stdin() {\n        return this.#stdin;\n    }\n    #stdout;\n    get stdout() {\n        return this.#stdout;\n    }\n    #stderr;\n    get stderr() {\n        return this.#stderr;\n    }\n    #exit = new PromiseResolver();\n    get exit() {\n        return this.#exit.promise;\n    }\n    constructor(socket) {\n        this.#socket = socket;\n        let stdoutController;\n        let stderrController;\n        this.#stdout = new PushReadableStream((controller) => {\n            stdoutController = controller;\n        });\n        this.#stderr = new PushReadableStream((controller) => {\n            stderrController = controller;\n        });\n        socket.readable\n            .pipeThrough(new StructDeserializeStream(AdbShellProtocolPacket))\n            .pipeTo(new WritableStream({\n            write: async (chunk) => {\n                switch (chunk.id) {\n                    case AdbShellProtocolId.Exit:\n                        this.#exit.resolve(chunk.data[0]);\n                        break;\n                    case AdbShellProtocolId.Stdout:\n                        if (!stdoutController.abortSignal.aborted) {\n                            await stdoutController.enqueue(chunk.data);\n                        }\n                        break;\n                    case AdbShellProtocolId.Stderr:\n                        if (!stderrController.abortSignal.aborted) {\n                            await stderrController.enqueue(chunk.data);\n                        }\n                        break;\n                }\n            },\n        }))\n            .then(() => {\n            stdoutController.close();\n            stderrController.close();\n            // If `#exit` has already resolved, this will be a no-op\n            this.#exit.reject(new Error(\"Socket ended without exit message\"));\n        }, (e) => {\n            stdoutController.error(e);\n            stderrController.error(e);\n            // If `#exit` has already resolved, this will be a no-op\n            this.#exit.reject(e);\n        });\n        this.#writer = this.#socket.writable.getWriter();\n        this.#stdin = new MaybeConsumable.WritableStream({\n            write: async (chunk) => {\n                await this.#writer.write(AdbShellProtocolPacket.serialize({\n                    id: AdbShellProtocolId.Stdin,\n                    data: chunk,\n                }));\n            },\n        });\n    }\n    async resize(rows, cols) {\n        await this.#writer.write(AdbShellProtocolPacket.serialize({\n            id: AdbShellProtocolId.WindowSizeChange,\n            // The \"correct\" format is `${rows}x${cols},${x_pixels}x${y_pixels}`\n            // However, according to https://linux.die.net/man/4/tty_ioctl\n            // `x_pixels` and `y_pixels` are unused, so always sending `0` should be fine.\n            data: encodeUtf8(`${rows}x${cols},0x0\\0`),\n        }));\n    }\n    kill() {\n        return this.#socket.close();\n    }\n}\n//# sourceMappingURL=shell.js.map","import { PromiseResolver } from \"@yume-chan/async\";\nimport type {\n    PushReadableStreamController,\n    ReadableStream,\n    WritableStreamDefaultWriter,\n} from \"@yume-chan/stream-extra\";\nimport {\n    MaybeConsumable,\n    PushReadableStream,\n    StructDeserializeStream,\n    WritableStream,\n} from \"@yume-chan/stream-extra\";\nimport type { StructValueType } from \"@yume-chan/struct\";\nimport Struct, { placeholder } from \"@yume-chan/struct\";\n\nimport type { Adb, AdbSocket } from \"../../../adb.js\";\nimport { AdbFeature } from \"../../../features.js\";\nimport { encodeUtf8 } from \"../../../utils/index.js\";\n\nimport type { AdbSubprocessProtocol } from \"./types.js\";\n\nexport enum AdbShellProtocolId {\n    Stdin,\n    Stdout,\n    Stderr,\n    Exit,\n    CloseStdin,\n    WindowSizeChange,\n}\n\n// This packet format is used in both direction.\nconst AdbShellProtocolPacket = new Struct({ littleEndian: true })\n    .uint8(\"id\", placeholder<AdbShellProtocolId>())\n    .uint32(\"length\")\n    .uint8Array(\"data\", { lengthField: \"length\" });\n\ntype AdbShellProtocolPacket = StructValueType<typeof AdbShellProtocolPacket>;\n\n/**\n * Shell v2 a.k.a Shell Protocol\n *\n * Features:\n * * `stderr`: Yes\n * * `exit` exit code: Yes\n * * `resize`: Yes\n */\nexport class AdbSubprocessShellProtocol implements AdbSubprocessProtocol {\n    static isSupported(adb: Adb) {\n        return adb.canUseFeature(AdbFeature.ShellV2);\n    }\n\n    static async pty(adb: Adb, command: string) {\n        // TODO: AdbShellSubprocessProtocol: Support setting `XTERM` environment variable\n        return new AdbSubprocessShellProtocol(\n            await adb.createSocket(`shell,v2,pty:${command}`),\n        );\n    }\n\n    static async raw(adb: Adb, command: string) {\n        return new AdbSubprocessShellProtocol(\n            await adb.createSocket(`shell,v2,raw:${command}`),\n        );\n    }\n\n    readonly #socket: AdbSocket;\n    #writer: WritableStreamDefaultWriter<MaybeConsumable<Uint8Array>>;\n\n    #stdin: WritableStream<MaybeConsumable<Uint8Array>>;\n    get stdin() {\n        return this.#stdin;\n    }\n\n    #stdout: ReadableStream<Uint8Array>;\n    get stdout() {\n        return this.#stdout;\n    }\n\n    #stderr: ReadableStream<Uint8Array>;\n    get stderr() {\n        return this.#stderr;\n    }\n\n    readonly #exit = new PromiseResolver<number>();\n    get exit() {\n        return this.#exit.promise;\n    }\n\n    constructor(socket: AdbSocket) {\n        this.#socket = socket;\n\n        let stdoutController!: PushReadableStreamController<Uint8Array>;\n        let stderrController!: PushReadableStreamController<Uint8Array>;\n        this.#stdout = new PushReadableStream<Uint8Array>((controller) => {\n            stdoutController = controller;\n        });\n        this.#stderr = new PushReadableStream<Uint8Array>((controller) => {\n            stderrController = controller;\n        });\n\n        socket.readable\n            .pipeThrough(new StructDeserializeStream(AdbShellProtocolPacket))\n            .pipeTo(\n                new WritableStream<AdbShellProtocolPacket>({\n                    write: async (chunk) => {\n                        switch (chunk.id) {\n                            case AdbShellProtocolId.Exit:\n                                this.#exit.resolve(chunk.data[0]!);\n                                break;\n                            case AdbShellProtocolId.Stdout:\n                                if (!stdoutController.abortSignal.aborted) {\n                                    await stdoutController.enqueue(chunk.data);\n                                }\n                                break;\n                            case AdbShellProtocolId.Stderr:\n                                if (!stderrController.abortSignal.aborted) {\n                                    await stderrController.enqueue(chunk.data);\n                                }\n                                break;\n                        }\n                    },\n                }),\n            )\n            .then(\n                () => {\n                    stdoutController.close();\n                    stderrController.close();\n                    // If `#exit` has already resolved, this will be a no-op\n                    this.#exit.reject(\n                        new Error(\"Socket ended without exit message\"),\n                    );\n                },\n                (e) => {\n                    stdoutController.error(e);\n                    stderrController.error(e);\n                    // If `#exit` has already resolved, this will be a no-op\n                    this.#exit.reject(e);\n                },\n            );\n\n        this.#writer = this.#socket.writable.getWriter();\n\n        this.#stdin = new MaybeConsumable.WritableStream<Uint8Array>({\n            write: async (chunk) => {\n                await this.#writer.write(\n                    AdbShellProtocolPacket.serialize({\n                        id: AdbShellProtocolId.Stdin,\n                        data: chunk,\n                    }),\n                );\n            },\n        });\n    }\n\n    async resize(rows: number, cols: number) {\n        await this.#writer.write(\n            AdbShellProtocolPacket.serialize({\n                id: AdbShellProtocolId.WindowSizeChange,\n                // The \"correct\" format is `${rows}x${cols},${x_pixels}x${y_pixels}`\n                // However, according to https://linux.die.net/man/4/tty_ioctl\n                // `x_pixels` and `y_pixels` are unused, so always sending `0` should be fine.\n                data: encodeUtf8(`${rows}x${cols},0x0\\0`),\n            }),\n        );\n    }\n\n    kill() {\n        return this.#socket.close();\n    }\n}\n","// The order follows\n// https://cs.android.com/android/platform/superproject/+/master:packages/modules/adb/transport.cpp;l=77;drc=6d14d35d0241f6fee145f8e54ffd77252e8d29fd\nexport var AdbFeature;\n(function (AdbFeature) {\n    AdbFeature[\"ShellV2\"] = \"shell_v2\";\n    AdbFeature[\"Cmd\"] = \"cmd\";\n    AdbFeature[\"StatV2\"] = \"stat_v2\";\n    AdbFeature[\"ListV2\"] = \"ls_v2\";\n    AdbFeature[\"FixedPushMkdir\"] = \"fixed_push_mkdir\";\n    AdbFeature[\"Abb\"] = \"abb\";\n    AdbFeature[\"AbbExec\"] = \"abb_exec\";\n    AdbFeature[\"SendReceiveV2\"] = \"sendrecv_v2\";\n    AdbFeature[\"DelayedAck\"] = \"delayed_ack\";\n})(AdbFeature || (AdbFeature = {}));\n//# sourceMappingURL=features.js.map","// The order follows\n// https://cs.android.com/android/platform/superproject/+/master:packages/modules/adb/transport.cpp;l=77;drc=6d14d35d0241f6fee145f8e54ffd77252e8d29fd\nexport enum AdbFeature {\n    ShellV2 = \"shell_v2\",\n    Cmd = \"cmd\",\n    StatV2 = \"stat_v2\",\n    ListV2 = \"ls_v2\",\n    FixedPushMkdir = \"fixed_push_mkdir\",\n    Abb = \"abb\",\n    AbbExec = \"abb_exec\",\n    SendReceiveV2 = \"sendrecv_v2\",\n    DelayedAck = \"delayed_ack\",\n}\n","import type {\n    MaybeConsumable,\n    ReadableStream,\n    WritableStream,\n} from \"@yume-chan/stream-extra\";\nimport type { ValueOrPromise } from \"@yume-chan/struct\";\n\nimport type { Adb, AdbSocket } from \"../../../adb.js\";\n\nexport interface AdbSubprocessProtocol {\n    /**\n     * A WritableStream that writes to the `stdin` stream.\n     */\n    readonly stdin: WritableStream<MaybeConsumable<Uint8Array>>;\n\n    /**\n     * The `stdout` stream of the process.\n     */\n    readonly stdout: ReadableStream<Uint8Array>;\n\n    /**\n     * The `stderr` stream of the process.\n     *\n     * Note: Some `AdbSubprocessProtocol` doesn't separate `stdout` and `stderr`,\n     * All output will be sent to `stdout`.\n     */\n    readonly stderr: ReadableStream<Uint8Array>;\n\n    /**\n     * A `Promise` that resolves to the exit code of the process.\n     *\n     * Note: Some `AdbSubprocessProtocol` doesn't support exit code,\n     * They will always resolve it with `0`.\n     */\n    readonly exit: Promise<number>;\n\n    /**\n     * Resizes the current shell.\n     *\n     * Some `AdbSubprocessProtocol`s may not support resizing\n     * and will ignore calls to this method.\n     */\n    resize(rows: number, cols: number): ValueOrPromise<void>;\n\n    /**\n     * Kills the current process.\n     */\n    kill(): ValueOrPromise<void>;\n}\n\nexport interface AdbSubprocessProtocolConstructor {\n    /** Returns `true` if the `adb` instance supports this shell */\n    isSupported(adb: Adb): ValueOrPromise<boolean>;\n\n    /** Spawns an executable in PTY (interactive) mode. */\n    pty(adb: Adb, command: string): ValueOrPromise<AdbSubprocessProtocol>;\n\n    /** Spawns an executable and pipe the output. */\n    raw(adb: Adb, command: string): ValueOrPromise<AdbSubprocessProtocol>;\n\n    /** Creates a new `AdbShell` by attaching to an exist `AdbSocket` */\n    new (socket: AdbSocket): AdbSubprocessProtocol;\n}\n","export function escapeArg(s) {\n    let result = \"\";\n    result += `'`;\n    let base = 0;\n    while (true) {\n        const found = s.indexOf(`'`, base);\n        if (found === -1) {\n            result += s.substring(base);\n            break;\n        }\n        result += s.substring(base, found);\n        // a'b becomes a'\\'b (the backslash is not a escape character)\n        result += String.raw `'\\''`;\n        base = found + 1;\n    }\n    result += `'`;\n    return result;\n}\n//# sourceMappingURL=utils.js.map","export function escapeArg(s: string) {\n    let result = \"\";\n    result += `'`;\n\n    let base = 0;\n    while (true) {\n        const found = s.indexOf(`'`, base);\n        if (found === -1) {\n            result += s.substring(base);\n            break;\n        }\n        result += s.substring(base, found);\n        // a'b becomes a'\\'b (the backslash is not a escape character)\n        result += String.raw`'\\''`;\n        base = found + 1;\n    }\n\n    result += `'`;\n    return result;\n}\n","export * from \"./list.js\";\nexport * from \"./pull.js\";\nexport * from \"./push.js\";\nexport * from \"./request.js\";\nexport * from \"./response.js\";\nexport * from \"./socket.js\";\nexport * from \"./stat.js\";\nexport * from \"./sync.js\";\n","import Struct from \"@yume-chan/struct\";\nimport { AdbSyncRequestId, adbSyncWriteRequest } from \"./request.js\";\nimport { AdbSyncResponseId, adbSyncReadResponses } from \"./response.js\";\nimport { AdbSyncLstatResponse, AdbSyncStatErrorCode, AdbSyncStatResponse, } from \"./stat.js\";\nexport const AdbSyncEntryResponse = new Struct({ littleEndian: true })\n    .concat(AdbSyncLstatResponse)\n    .uint32(\"nameLength\")\n    .string(\"name\", { lengthField: \"nameLength\" });\nexport const AdbSyncEntry2Response = new Struct({ littleEndian: true })\n    .concat(AdbSyncStatResponse)\n    .uint32(\"nameLength\")\n    .string(\"name\", { lengthField: \"nameLength\" });\nexport async function* adbSyncOpenDirV2(socket, path) {\n    const locked = await socket.lock();\n    try {\n        await adbSyncWriteRequest(locked, AdbSyncRequestId.ListV2, path);\n        for await (const item of adbSyncReadResponses(locked, AdbSyncResponseId.Entry2, AdbSyncEntry2Response)) {\n            // `LST2` can return error codes for failed `lstat` calls.\n            // `LIST` just ignores them.\n            // But they only contain `name` so still pretty useless.\n            if (item.error !== AdbSyncStatErrorCode.SUCCESS) {\n                continue;\n            }\n            yield item;\n        }\n    }\n    finally {\n        locked.release();\n    }\n}\nexport async function* adbSyncOpenDirV1(socket, path) {\n    const locked = await socket.lock();\n    try {\n        await adbSyncWriteRequest(locked, AdbSyncRequestId.List, path);\n        for await (const item of adbSyncReadResponses(locked, AdbSyncResponseId.Entry, AdbSyncEntryResponse)) {\n            yield item;\n        }\n    }\n    finally {\n        locked.release();\n    }\n}\nexport async function* adbSyncOpenDir(socket, path, v2) {\n    if (v2) {\n        yield* adbSyncOpenDirV2(socket, path);\n    }\n    else {\n        for await (const item of adbSyncOpenDirV1(socket, path)) {\n            // Convert to same format as `AdbSyncEntry2Response` for easier consumption.\n            // However it will add some overhead.\n            yield {\n                mode: item.mode,\n                size: BigInt(item.size),\n                mtime: BigInt(item.mtime),\n                get type() {\n                    return item.type;\n                },\n                get permission() {\n                    return item.permission;\n                },\n                name: item.name,\n            };\n        }\n    }\n}\n//# sourceMappingURL=list.js.map","import Struct from \"@yume-chan/struct\";\n\nimport { AdbSyncRequestId, adbSyncWriteRequest } from \"./request.js\";\nimport { AdbSyncResponseId, adbSyncReadResponses } from \"./response.js\";\nimport type { AdbSyncSocket } from \"./socket.js\";\nimport type { AdbSyncStat } from \"./stat.js\";\nimport {\n    AdbSyncLstatResponse,\n    AdbSyncStatErrorCode,\n    AdbSyncStatResponse,\n} from \"./stat.js\";\n\nexport interface AdbSyncEntry extends AdbSyncStat {\n    name: string;\n}\n\nexport const AdbSyncEntryResponse = new Struct({ littleEndian: true })\n    .concat(AdbSyncLstatResponse)\n    .uint32(\"nameLength\")\n    .string(\"name\", { lengthField: \"nameLength\" });\n\nexport type AdbSyncEntryResponse =\n    (typeof AdbSyncEntryResponse)[\"TDeserializeResult\"];\n\nexport const AdbSyncEntry2Response = new Struct({ littleEndian: true })\n    .concat(AdbSyncStatResponse)\n    .uint32(\"nameLength\")\n    .string(\"name\", { lengthField: \"nameLength\" });\n\nexport type AdbSyncEntry2Response =\n    (typeof AdbSyncEntry2Response)[\"TDeserializeResult\"];\n\nexport async function* adbSyncOpenDirV2(\n    socket: AdbSyncSocket,\n    path: string,\n): AsyncGenerator<AdbSyncEntry2Response, void, void> {\n    const locked = await socket.lock();\n    try {\n        await adbSyncWriteRequest(locked, AdbSyncRequestId.ListV2, path);\n        for await (const item of adbSyncReadResponses(\n            locked,\n            AdbSyncResponseId.Entry2,\n            AdbSyncEntry2Response,\n        )) {\n            // `LST2` can return error codes for failed `lstat` calls.\n            // `LIST` just ignores them.\n            // But they only contain `name` so still pretty useless.\n            if (item.error !== AdbSyncStatErrorCode.SUCCESS) {\n                continue;\n            }\n            yield item;\n        }\n    } finally {\n        locked.release();\n    }\n}\n\nexport async function* adbSyncOpenDirV1(\n    socket: AdbSyncSocket,\n    path: string,\n): AsyncGenerator<AdbSyncEntryResponse, void, void> {\n    const locked = await socket.lock();\n    try {\n        await adbSyncWriteRequest(locked, AdbSyncRequestId.List, path);\n        for await (const item of adbSyncReadResponses(\n            locked,\n            AdbSyncResponseId.Entry,\n            AdbSyncEntryResponse,\n        )) {\n            yield item;\n        }\n    } finally {\n        locked.release();\n    }\n}\n\nexport async function* adbSyncOpenDir(\n    socket: AdbSyncSocket,\n    path: string,\n    v2: boolean,\n): AsyncGenerator<AdbSyncEntry, void, void> {\n    if (v2) {\n        yield* adbSyncOpenDirV2(socket, path);\n    } else {\n        for await (const item of adbSyncOpenDirV1(socket, path)) {\n            // Convert to same format as `AdbSyncEntry2Response` for easier consumption.\n            // However it will add some overhead.\n            yield {\n                mode: item.mode,\n                size: BigInt(item.size),\n                mtime: BigInt(item.mtime),\n                get type() {\n                    return item.type;\n                },\n                get permission() {\n                    return item.permission;\n                },\n                name: item.name,\n            };\n        }\n    }\n}\n","import Struct from \"@yume-chan/struct\";\nimport { encodeUtf8 } from \"../../utils/index.js\";\nimport { adbSyncEncodeId } from \"./response.js\";\nexport var AdbSyncRequestId;\n(function (AdbSyncRequestId) {\n    AdbSyncRequestId.List = adbSyncEncodeId(\"LIST\");\n    AdbSyncRequestId.ListV2 = adbSyncEncodeId(\"LIS2\");\n    AdbSyncRequestId.Send = adbSyncEncodeId(\"SEND\");\n    AdbSyncRequestId.SendV2 = adbSyncEncodeId(\"SND2\");\n    AdbSyncRequestId.Lstat = adbSyncEncodeId(\"STAT\");\n    AdbSyncRequestId.Stat = adbSyncEncodeId(\"STA2\");\n    AdbSyncRequestId.LstatV2 = adbSyncEncodeId(\"LST2\");\n    AdbSyncRequestId.Data = adbSyncEncodeId(\"DATA\");\n    AdbSyncRequestId.Done = adbSyncEncodeId(\"DONE\");\n    AdbSyncRequestId.Receive = adbSyncEncodeId(\"RECV\");\n})(AdbSyncRequestId || (AdbSyncRequestId = {}));\nexport const AdbSyncNumberRequest = new Struct({ littleEndian: true })\n    .uint32(\"id\")\n    .uint32(\"arg\");\nexport async function adbSyncWriteRequest(writable, id, value) {\n    if (typeof id === \"string\") {\n        id = adbSyncEncodeId(id);\n    }\n    if (typeof value === \"number\") {\n        await writable.write(AdbSyncNumberRequest.serialize({ id, arg: value }));\n        return;\n    }\n    if (typeof value === \"string\") {\n        value = encodeUtf8(value);\n    }\n    // `writable` is buffered, it copies inputs to an internal buffer,\n    // so don't concatenate headers and data here, that will be an unnecessary copy.\n    await writable.write(AdbSyncNumberRequest.serialize({ id, arg: value.length }));\n    await writable.write(value);\n}\n//# sourceMappingURL=request.js.map","import Struct from \"@yume-chan/struct\";\n\nimport { encodeUtf8 } from \"../../utils/index.js\";\n\nimport { adbSyncEncodeId } from \"./response.js\";\n\nexport namespace AdbSyncRequestId {\n    export const List = adbSyncEncodeId(\"LIST\");\n    export const ListV2 = adbSyncEncodeId(\"LIS2\");\n    export const Send = adbSyncEncodeId(\"SEND\");\n    export const SendV2 = adbSyncEncodeId(\"SND2\");\n    export const Lstat = adbSyncEncodeId(\"STAT\");\n    export const Stat = adbSyncEncodeId(\"STA2\");\n    export const LstatV2 = adbSyncEncodeId(\"LST2\");\n    export const Data = adbSyncEncodeId(\"DATA\");\n    export const Done = adbSyncEncodeId(\"DONE\");\n    export const Receive = adbSyncEncodeId(\"RECV\");\n}\n\nexport const AdbSyncNumberRequest = new Struct({ littleEndian: true })\n    .uint32(\"id\")\n    .uint32(\"arg\");\n\nexport interface AdbSyncWritable {\n    write(buffer: Uint8Array): Promise<void>;\n}\n\nexport async function adbSyncWriteRequest(\n    writable: AdbSyncWritable,\n    id: number | string,\n    value: number | string | Uint8Array,\n): Promise<void> {\n    if (typeof id === \"string\") {\n        id = adbSyncEncodeId(id);\n    }\n\n    if (typeof value === \"number\") {\n        await writable.write(\n            AdbSyncNumberRequest.serialize({ id, arg: value }),\n        );\n        return;\n    }\n\n    if (typeof value === \"string\") {\n        value = encodeUtf8(value);\n    }\n\n    // `writable` is buffered, it copies inputs to an internal buffer,\n    // so don't concatenate headers and data here, that will be an unnecessary copy.\n    await writable.write(\n        AdbSyncNumberRequest.serialize({ id, arg: value.length }),\n    );\n    await writable.write(value);\n}\n","import { getUint32LittleEndian } from \"@yume-chan/no-data-view\";\nimport Struct, { decodeUtf8 } from \"@yume-chan/struct\";\nfunction encodeAsciiUnchecked(value) {\n    const result = new Uint8Array(value.length);\n    for (let i = 0; i < value.length; i += 1) {\n        result[i] = value.charCodeAt(i);\n    }\n    return result;\n}\n/**\n * Encode ID to numbers for faster comparison\n * @param value A 4-character string\n * @returns A 32-bit integer by encoding the string as little-endian\n */\nexport function adbSyncEncodeId(value) {\n    const buffer = encodeAsciiUnchecked(value);\n    return getUint32LittleEndian(buffer, 0);\n}\nexport var AdbSyncResponseId;\n(function (AdbSyncResponseId) {\n    AdbSyncResponseId.Entry = adbSyncEncodeId(\"DENT\");\n    AdbSyncResponseId.Entry2 = adbSyncEncodeId(\"DNT2\");\n    AdbSyncResponseId.Lstat = adbSyncEncodeId(\"STAT\");\n    AdbSyncResponseId.Stat = adbSyncEncodeId(\"STA2\");\n    AdbSyncResponseId.Lstat2 = adbSyncEncodeId(\"LST2\");\n    AdbSyncResponseId.Done = adbSyncEncodeId(\"DONE\");\n    AdbSyncResponseId.Data = adbSyncEncodeId(\"DATA\");\n    AdbSyncResponseId.Ok = adbSyncEncodeId(\"OKAY\");\n    AdbSyncResponseId.Fail = adbSyncEncodeId(\"FAIL\");\n})(AdbSyncResponseId || (AdbSyncResponseId = {}));\nexport class AdbSyncError extends Error {\n}\nexport const AdbSyncFailResponse = new Struct({ littleEndian: true })\n    .uint32(\"messageLength\")\n    .string(\"message\", { lengthField: \"messageLength\" })\n    .postDeserialize((object) => {\n    throw new AdbSyncError(object.message);\n});\nexport async function adbSyncReadResponse(stream, id, type) {\n    if (typeof id === \"string\") {\n        id = adbSyncEncodeId(id);\n    }\n    const buffer = await stream.readExactly(4);\n    switch (getUint32LittleEndian(buffer, 0)) {\n        case AdbSyncResponseId.Fail:\n            await AdbSyncFailResponse.deserialize(stream);\n            throw new Error(\"Unreachable\");\n        case id:\n            return await type.deserialize(stream);\n        default:\n            throw new Error(`Expected '${id}', but got '${decodeUtf8(buffer)}'`);\n    }\n}\nexport async function* adbSyncReadResponses(stream, id, type) {\n    if (typeof id === \"string\") {\n        id = adbSyncEncodeId(id);\n    }\n    while (true) {\n        const buffer = await stream.readExactly(4);\n        switch (getUint32LittleEndian(buffer, 0)) {\n            case AdbSyncResponseId.Fail:\n                await AdbSyncFailResponse.deserialize(stream);\n                throw new Error(\"Unreachable\");\n            case AdbSyncResponseId.Done:\n                // `DONE` responses' size are always same as the request's normal response.\n                //\n                // For example, `DONE` responses for `LIST` requests are 16 bytes (same as `DENT` responses),\n                // but `DONE` responses for `STAT` requests are 12 bytes (same as `STAT` responses).\n                await stream.readExactly(type.size);\n                return;\n            case id:\n                yield (await type.deserialize(stream));\n                break;\n            default:\n                throw new Error(`Expected '${id}' or '${AdbSyncResponseId.Done}', but got '${decodeUtf8(buffer)}'`);\n        }\n    }\n}\n//# sourceMappingURL=response.js.map","import { getUint32LittleEndian } from \"@yume-chan/no-data-view\";\nimport type {\n    AsyncExactReadable,\n    StructLike,\n    StructValueType,\n} from \"@yume-chan/struct\";\nimport Struct, { decodeUtf8 } from \"@yume-chan/struct\";\n\nfunction encodeAsciiUnchecked(value: string): Uint8Array {\n    const result = new Uint8Array(value.length);\n    for (let i = 0; i < value.length; i += 1) {\n        result[i] = value.charCodeAt(i);\n    }\n    return result;\n}\n\n/**\n * Encode ID to numbers for faster comparison\n * @param value A 4-character string\n * @returns A 32-bit integer by encoding the string as little-endian\n */\nexport function adbSyncEncodeId(value: string): number {\n    const buffer = encodeAsciiUnchecked(value);\n    return getUint32LittleEndian(buffer, 0);\n}\n\nexport namespace AdbSyncResponseId {\n    export const Entry = adbSyncEncodeId(\"DENT\");\n    export const Entry2 = adbSyncEncodeId(\"DNT2\");\n    export const Lstat = adbSyncEncodeId(\"STAT\");\n    export const Stat = adbSyncEncodeId(\"STA2\");\n    export const Lstat2 = adbSyncEncodeId(\"LST2\");\n    export const Done = adbSyncEncodeId(\"DONE\");\n    export const Data = adbSyncEncodeId(\"DATA\");\n    export const Ok = adbSyncEncodeId(\"OKAY\");\n    export const Fail = adbSyncEncodeId(\"FAIL\");\n}\n\nexport class AdbSyncError extends Error {}\n\nexport const AdbSyncFailResponse = new Struct({ littleEndian: true })\n    .uint32(\"messageLength\")\n    .string(\"message\", { lengthField: \"messageLength\" })\n    .postDeserialize((object) => {\n        throw new AdbSyncError(object.message);\n    });\n\nexport async function adbSyncReadResponse<T>(\n    stream: AsyncExactReadable,\n    id: number | string,\n    type: StructLike<T>,\n): Promise<T> {\n    if (typeof id === \"string\") {\n        id = adbSyncEncodeId(id);\n    }\n\n    const buffer = await stream.readExactly(4);\n    switch (getUint32LittleEndian(buffer, 0)) {\n        case AdbSyncResponseId.Fail:\n            await AdbSyncFailResponse.deserialize(stream);\n            throw new Error(\"Unreachable\");\n        case id:\n            return await type.deserialize(stream);\n        default:\n            throw new Error(\n                `Expected '${id}', but got '${decodeUtf8(buffer)}'`,\n            );\n    }\n}\n\nexport async function* adbSyncReadResponses<\n    T extends Struct<object, PropertyKey, object, unknown>,\n>(\n    stream: AsyncExactReadable,\n    id: number | string,\n    type: T,\n): AsyncGenerator<StructValueType<T>, void, void> {\n    if (typeof id === \"string\") {\n        id = adbSyncEncodeId(id);\n    }\n\n    while (true) {\n        const buffer = await stream.readExactly(4);\n        switch (getUint32LittleEndian(buffer, 0)) {\n            case AdbSyncResponseId.Fail:\n                await AdbSyncFailResponse.deserialize(stream);\n                throw new Error(\"Unreachable\");\n            case AdbSyncResponseId.Done:\n                // `DONE` responses' size are always same as the request's normal response.\n                //\n                // For example, `DONE` responses for `LIST` requests are 16 bytes (same as `DENT` responses),\n                // but `DONE` responses for `STAT` requests are 12 bytes (same as `STAT` responses).\n                await stream.readExactly(type.size);\n                return;\n            case id:\n                yield (await type.deserialize(stream)) as StructValueType<T>;\n                break;\n            default:\n                throw new Error(\n                    `Expected '${id}' or '${AdbSyncResponseId.Done}', but got '${decodeUtf8(buffer)}'`,\n                );\n        }\n    }\n}\n","import Struct, { placeholder } from \"@yume-chan/struct\";\nimport { AdbSyncRequestId, adbSyncWriteRequest } from \"./request.js\";\nimport { AdbSyncResponseId, adbSyncReadResponse } from \"./response.js\";\n// https://github.com/python/cpython/blob/4e581d64b8aff3e2eda99b12f080c877bb78dfca/Lib/stat.py#L36\nexport var LinuxFileType;\n(function (LinuxFileType) {\n    LinuxFileType[LinuxFileType[\"Directory\"] = 4] = \"Directory\";\n    LinuxFileType[LinuxFileType[\"File\"] = 8] = \"File\";\n    LinuxFileType[LinuxFileType[\"Link\"] = 10] = \"Link\";\n})(LinuxFileType || (LinuxFileType = {}));\nexport const AdbSyncLstatResponse = new Struct({ littleEndian: true })\n    .int32(\"mode\")\n    .int32(\"size\")\n    .int32(\"mtime\")\n    .extra({\n    get type() {\n        return (this.mode >> 12);\n    },\n    get permission() {\n        return this.mode & 0b00001111_11111111;\n    },\n})\n    .postDeserialize((object) => {\n    if (object.mode === 0 && object.size === 0 && object.mtime === 0) {\n        throw new Error(\"lstat error\");\n    }\n});\nexport var AdbSyncStatErrorCode;\n(function (AdbSyncStatErrorCode) {\n    AdbSyncStatErrorCode[AdbSyncStatErrorCode[\"SUCCESS\"] = 0] = \"SUCCESS\";\n    AdbSyncStatErrorCode[AdbSyncStatErrorCode[\"EACCES\"] = 13] = \"EACCES\";\n    AdbSyncStatErrorCode[AdbSyncStatErrorCode[\"EEXIST\"] = 17] = \"EEXIST\";\n    AdbSyncStatErrorCode[AdbSyncStatErrorCode[\"EFAULT\"] = 14] = \"EFAULT\";\n    AdbSyncStatErrorCode[AdbSyncStatErrorCode[\"EFBIG\"] = 27] = \"EFBIG\";\n    AdbSyncStatErrorCode[AdbSyncStatErrorCode[\"EINTR\"] = 4] = \"EINTR\";\n    AdbSyncStatErrorCode[AdbSyncStatErrorCode[\"EINVAL\"] = 22] = \"EINVAL\";\n    AdbSyncStatErrorCode[AdbSyncStatErrorCode[\"EIO\"] = 5] = \"EIO\";\n    AdbSyncStatErrorCode[AdbSyncStatErrorCode[\"EISDIR\"] = 21] = \"EISDIR\";\n    AdbSyncStatErrorCode[AdbSyncStatErrorCode[\"ELOOP\"] = 40] = \"ELOOP\";\n    AdbSyncStatErrorCode[AdbSyncStatErrorCode[\"EMFILE\"] = 24] = \"EMFILE\";\n    AdbSyncStatErrorCode[AdbSyncStatErrorCode[\"ENAMETOOLONG\"] = 36] = \"ENAMETOOLONG\";\n    AdbSyncStatErrorCode[AdbSyncStatErrorCode[\"ENFILE\"] = 23] = \"ENFILE\";\n    AdbSyncStatErrorCode[AdbSyncStatErrorCode[\"ENOENT\"] = 2] = \"ENOENT\";\n    AdbSyncStatErrorCode[AdbSyncStatErrorCode[\"ENOMEM\"] = 12] = \"ENOMEM\";\n    AdbSyncStatErrorCode[AdbSyncStatErrorCode[\"ENOSPC\"] = 28] = \"ENOSPC\";\n    AdbSyncStatErrorCode[AdbSyncStatErrorCode[\"ENOTDIR\"] = 20] = \"ENOTDIR\";\n    AdbSyncStatErrorCode[AdbSyncStatErrorCode[\"EOVERFLOW\"] = 75] = \"EOVERFLOW\";\n    AdbSyncStatErrorCode[AdbSyncStatErrorCode[\"EPERM\"] = 1] = \"EPERM\";\n    AdbSyncStatErrorCode[AdbSyncStatErrorCode[\"EROFS\"] = 30] = \"EROFS\";\n    AdbSyncStatErrorCode[AdbSyncStatErrorCode[\"ETXTBSY\"] = 26] = \"ETXTBSY\";\n})(AdbSyncStatErrorCode || (AdbSyncStatErrorCode = {}));\nexport const AdbSyncStatResponse = new Struct({ littleEndian: true })\n    .uint32(\"error\", placeholder())\n    .uint64(\"dev\")\n    .uint64(\"ino\")\n    .uint32(\"mode\")\n    .uint32(\"nlink\")\n    .uint32(\"uid\")\n    .uint32(\"gid\")\n    .uint64(\"size\")\n    .uint64(\"atime\")\n    .uint64(\"mtime\")\n    .uint64(\"ctime\")\n    .extra({\n    get type() {\n        return (this.mode >> 12);\n    },\n    get permission() {\n        return this.mode & 0b00001111_11111111;\n    },\n})\n    .postDeserialize((object) => {\n    if (object.error) {\n        throw new Error(AdbSyncStatErrorCode[object.error]);\n    }\n});\nexport async function adbSyncLstat(socket, path, v2) {\n    const locked = await socket.lock();\n    try {\n        if (v2) {\n            await adbSyncWriteRequest(locked, AdbSyncRequestId.LstatV2, path);\n            return await adbSyncReadResponse(locked, AdbSyncResponseId.Lstat2, AdbSyncStatResponse);\n        }\n        else {\n            await adbSyncWriteRequest(locked, AdbSyncRequestId.Lstat, path);\n            const response = await adbSyncReadResponse(locked, AdbSyncResponseId.Lstat, AdbSyncLstatResponse);\n            return {\n                mode: response.mode,\n                // Convert to `BigInt` to make it compatible with `AdbSyncStatResponse`\n                size: BigInt(response.size),\n                mtime: BigInt(response.mtime),\n                get type() {\n                    return response.type;\n                },\n                get permission() {\n                    return response.permission;\n                },\n            };\n        }\n    }\n    finally {\n        locked.release();\n    }\n}\nexport async function adbSyncStat(socket, path) {\n    const locked = await socket.lock();\n    try {\n        await adbSyncWriteRequest(locked, AdbSyncRequestId.Stat, path);\n        return await adbSyncReadResponse(locked, AdbSyncResponseId.Stat, AdbSyncStatResponse);\n    }\n    finally {\n        locked.release();\n    }\n}\n//# sourceMappingURL=stat.js.map","import Struct, { placeholder } from \"@yume-chan/struct\";\n\nimport { AdbSyncRequestId, adbSyncWriteRequest } from \"./request.js\";\nimport { AdbSyncResponseId, adbSyncReadResponse } from \"./response.js\";\nimport type { AdbSyncSocket } from \"./socket.js\";\n\n// https://github.com/python/cpython/blob/4e581d64b8aff3e2eda99b12f080c877bb78dfca/Lib/stat.py#L36\nexport enum LinuxFileType {\n    Directory = 0o04,\n    File = 0o10,\n    Link = 0o12,\n}\n\nexport interface AdbSyncStat {\n    mode: number;\n    size: bigint;\n    mtime: bigint;\n    get type(): LinuxFileType;\n    get permission(): number;\n\n    uid?: number;\n    gid?: number;\n    atime?: bigint;\n    ctime?: bigint;\n}\n\nexport const AdbSyncLstatResponse = new Struct({ littleEndian: true })\n    .int32(\"mode\")\n    .int32(\"size\")\n    .int32(\"mtime\")\n    .extra({\n        get type() {\n            return (this.mode >> 12) as LinuxFileType;\n        },\n        get permission() {\n            return this.mode & 0b00001111_11111111;\n        },\n    })\n    .postDeserialize((object) => {\n        if (object.mode === 0 && object.size === 0 && object.mtime === 0) {\n            throw new Error(\"lstat error\");\n        }\n    });\n\nexport type AdbSyncLstatResponse =\n    (typeof AdbSyncLstatResponse)[\"TDeserializeResult\"];\n\nexport enum AdbSyncStatErrorCode {\n    SUCCESS = 0,\n    EACCES = 13,\n    EEXIST = 17,\n    EFAULT = 14,\n    EFBIG = 27,\n    EINTR = 4,\n    EINVAL = 22,\n    EIO = 5,\n    EISDIR = 21,\n    ELOOP = 40,\n    EMFILE = 24,\n    ENAMETOOLONG = 36,\n    ENFILE = 23,\n    ENOENT = 2,\n    ENOMEM = 12,\n    ENOSPC = 28,\n    ENOTDIR = 20,\n    EOVERFLOW = 75,\n    EPERM = 1,\n    EROFS = 30,\n    ETXTBSY = 26,\n}\n\nexport const AdbSyncStatResponse = new Struct({ littleEndian: true })\n    .uint32(\"error\", placeholder<AdbSyncStatErrorCode>())\n    .uint64(\"dev\")\n    .uint64(\"ino\")\n    .uint32(\"mode\")\n    .uint32(\"nlink\")\n    .uint32(\"uid\")\n    .uint32(\"gid\")\n    .uint64(\"size\")\n    .uint64(\"atime\")\n    .uint64(\"mtime\")\n    .uint64(\"ctime\")\n    .extra({\n        get type() {\n            return (this.mode >> 12) as LinuxFileType;\n        },\n        get permission() {\n            return this.mode & 0b00001111_11111111;\n        },\n    })\n    .postDeserialize((object) => {\n        if (object.error) {\n            throw new Error(AdbSyncStatErrorCode[object.error]);\n        }\n    });\n\nexport type AdbSyncStatResponse =\n    (typeof AdbSyncStatResponse)[\"TDeserializeResult\"];\n\nexport async function adbSyncLstat(\n    socket: AdbSyncSocket,\n    path: string,\n    v2: boolean,\n): Promise<AdbSyncStat> {\n    const locked = await socket.lock();\n    try {\n        if (v2) {\n            await adbSyncWriteRequest(locked, AdbSyncRequestId.LstatV2, path);\n            return await adbSyncReadResponse(\n                locked,\n                AdbSyncResponseId.Lstat2,\n                AdbSyncStatResponse,\n            );\n        } else {\n            await adbSyncWriteRequest(locked, AdbSyncRequestId.Lstat, path);\n            const response = await adbSyncReadResponse(\n                locked,\n                AdbSyncResponseId.Lstat,\n                AdbSyncLstatResponse,\n            );\n            return {\n                mode: response.mode,\n                // Convert to `BigInt` to make it compatible with `AdbSyncStatResponse`\n                size: BigInt(response.size),\n                mtime: BigInt(response.mtime),\n                get type() {\n                    return response.type;\n                },\n                get permission() {\n                    return response.permission;\n                },\n            };\n        }\n    } finally {\n        locked.release();\n    }\n}\n\nexport async function adbSyncStat(\n    socket: AdbSyncSocket,\n    path: string,\n): Promise<AdbSyncStatResponse> {\n    const locked = await socket.lock();\n    try {\n        await adbSyncWriteRequest(locked, AdbSyncRequestId.Stat, path);\n        return await adbSyncReadResponse(\n            locked,\n            AdbSyncResponseId.Stat,\n            AdbSyncStatResponse,\n        );\n    } finally {\n        locked.release();\n    }\n}\n","import { PushReadableStream } from \"@yume-chan/stream-extra\";\nimport Struct from \"@yume-chan/struct\";\nimport { AdbSyncRequestId, adbSyncWriteRequest } from \"./request.js\";\nimport { AdbSyncResponseId, adbSyncReadResponses } from \"./response.js\";\nexport const AdbSyncDataResponse = new Struct({ littleEndian: true })\n    .uint32(\"dataLength\")\n    .uint8Array(\"data\", { lengthField: \"dataLength\" });\nexport async function* adbSyncPullGenerator(socket, path) {\n    const locked = await socket.lock();\n    let done = false;\n    try {\n        await adbSyncWriteRequest(locked, AdbSyncRequestId.Receive, path);\n        for await (const packet of adbSyncReadResponses(locked, AdbSyncResponseId.Data, AdbSyncDataResponse)) {\n            yield packet.data;\n        }\n        done = true;\n    }\n    catch (e) {\n        done = true;\n        throw e;\n    }\n    finally {\n        if (!done) {\n            // sync pull can't be cancelled, so we have to read all data\n            for await (const packet of adbSyncReadResponses(locked, AdbSyncResponseId.Data, AdbSyncDataResponse)) {\n                void packet;\n            }\n        }\n        locked.release();\n    }\n}\nexport function adbSyncPull(socket, path) {\n    // TODO: use `ReadableStream.from` when it's supported\n    return new PushReadableStream(async (controller) => {\n        for await (const data of adbSyncPullGenerator(socket, path)) {\n            await controller.enqueue(data);\n        }\n    });\n}\n//# sourceMappingURL=pull.js.map","import type { ReadableStream } from \"@yume-chan/stream-extra\";\nimport { PushReadableStream } from \"@yume-chan/stream-extra\";\nimport Struct from \"@yume-chan/struct\";\n\nimport { AdbSyncRequestId, adbSyncWriteRequest } from \"./request.js\";\nimport { AdbSyncResponseId, adbSyncReadResponses } from \"./response.js\";\nimport type { AdbSyncSocket } from \"./socket.js\";\n\nexport const AdbSyncDataResponse = new Struct({ littleEndian: true })\n    .uint32(\"dataLength\")\n    .uint8Array(\"data\", { lengthField: \"dataLength\" });\n\nexport type AdbSyncDataResponse =\n    (typeof AdbSyncDataResponse)[\"TDeserializeResult\"];\n\nexport async function* adbSyncPullGenerator(\n    socket: AdbSyncSocket,\n    path: string,\n): AsyncGenerator<Uint8Array, void, void> {\n    const locked = await socket.lock();\n    let done = false;\n    try {\n        await adbSyncWriteRequest(locked, AdbSyncRequestId.Receive, path);\n        for await (const packet of adbSyncReadResponses(\n            locked,\n            AdbSyncResponseId.Data,\n            AdbSyncDataResponse,\n        )) {\n            yield packet.data;\n        }\n        done = true;\n    } catch (e) {\n        done = true;\n        throw e;\n    } finally {\n        if (!done) {\n            // sync pull can't be cancelled, so we have to read all data\n            for await (const packet of adbSyncReadResponses(\n                locked,\n                AdbSyncResponseId.Data,\n                AdbSyncDataResponse,\n            )) {\n                void packet;\n            }\n        }\n        locked.release();\n    }\n}\n\nexport function adbSyncPull(\n    socket: AdbSyncSocket,\n    path: string,\n): ReadableStream<Uint8Array> {\n    // TODO: use `ReadableStream.from` when it's supported\n    return new PushReadableStream(async (controller) => {\n        for await (const data of adbSyncPullGenerator(socket, path)) {\n            await controller.enqueue(data);\n        }\n    });\n}\n","import { AbortController, DistributionStream, MaybeConsumable, } from \"@yume-chan/stream-extra\";\nimport Struct, { placeholder } from \"@yume-chan/struct\";\nimport { NOOP } from \"../../utils/index.js\";\nimport { AdbSyncRequestId, adbSyncWriteRequest } from \"./request.js\";\nimport { AdbSyncResponseId, adbSyncReadResponse } from \"./response.js\";\nimport { LinuxFileType } from \"./stat.js\";\nexport const ADB_SYNC_MAX_PACKET_SIZE = 64 * 1024;\nexport const AdbSyncOkResponse = new Struct({ littleEndian: true }).uint32(\"unused\");\nasync function pipeFileData(locked, file, packetSize, mtime) {\n    // Read and write in parallel,\n    // allow error response to abort the write.\n    const abortController = new AbortController();\n    file.pipeThrough(new DistributionStream(packetSize, true))\n        .pipeTo(new MaybeConsumable.WritableStream({\n        write: async (chunk) => {\n            await adbSyncWriteRequest(locked, AdbSyncRequestId.Data, chunk);\n        },\n    }), { signal: abortController.signal })\n        .then(async () => {\n        await adbSyncWriteRequest(locked, AdbSyncRequestId.Done, mtime);\n        await locked.flush();\n    }, NOOP);\n    await adbSyncReadResponse(locked, AdbSyncResponseId.Ok, AdbSyncOkResponse).catch((e) => {\n        abortController.abort();\n        throw e;\n    });\n}\nexport async function adbSyncPushV1({ socket, filename, file, type = LinuxFileType.File, permission = 0o666, mtime = (Date.now() / 1000) | 0, packetSize = ADB_SYNC_MAX_PACKET_SIZE, }) {\n    const locked = await socket.lock();\n    try {\n        const mode = (type << 12) | permission;\n        const pathAndMode = `${filename},${mode.toString()}`;\n        await adbSyncWriteRequest(locked, AdbSyncRequestId.Send, pathAndMode);\n        await pipeFileData(locked, file, packetSize, mtime);\n    }\n    finally {\n        locked.release();\n    }\n}\nexport var AdbSyncSendV2Flags;\n(function (AdbSyncSendV2Flags) {\n    AdbSyncSendV2Flags[AdbSyncSendV2Flags[\"None\"] = 0] = \"None\";\n    AdbSyncSendV2Flags[AdbSyncSendV2Flags[\"Brotli\"] = 1] = \"Brotli\";\n    /**\n     * 2\n     */\n    AdbSyncSendV2Flags[AdbSyncSendV2Flags[\"Lz4\"] = 2] = \"Lz4\";\n    /**\n     * 4\n     */\n    AdbSyncSendV2Flags[AdbSyncSendV2Flags[\"Zstd\"] = 4] = \"Zstd\";\n    AdbSyncSendV2Flags[AdbSyncSendV2Flags[\"DryRun\"] = 2147483648] = \"DryRun\";\n})(AdbSyncSendV2Flags || (AdbSyncSendV2Flags = {}));\nexport const AdbSyncSendV2Request = new Struct({ littleEndian: true })\n    .uint32(\"id\")\n    .uint32(\"mode\")\n    .uint32(\"flags\", placeholder());\nexport async function adbSyncPushV2({ socket, filename, file, type = LinuxFileType.File, permission = 0o666, mtime = (Date.now() / 1000) | 0, packetSize = ADB_SYNC_MAX_PACKET_SIZE, dryRun = false, }) {\n    const locked = await socket.lock();\n    try {\n        await adbSyncWriteRequest(locked, AdbSyncRequestId.SendV2, filename);\n        const mode = (type << 12) | permission;\n        let flags = AdbSyncSendV2Flags.None;\n        if (dryRun) {\n            flags |= AdbSyncSendV2Flags.DryRun;\n        }\n        await locked.write(AdbSyncSendV2Request.serialize({\n            id: AdbSyncRequestId.SendV2,\n            mode,\n            flags,\n        }));\n        await pipeFileData(locked, file, packetSize, mtime);\n    }\n    finally {\n        locked.release();\n    }\n}\nexport function adbSyncPush(options) {\n    if (options.v2) {\n        return adbSyncPushV2(options);\n    }\n    if (options.dryRun) {\n        throw new Error(\"dryRun is not supported in v1\");\n    }\n    return adbSyncPushV1(options);\n}\n//# sourceMappingURL=push.js.map","import type { ReadableStream } from \"@yume-chan/stream-extra\";\nimport {\n    AbortController,\n    DistributionStream,\n    MaybeConsumable,\n} from \"@yume-chan/stream-extra\";\nimport Struct, { placeholder } from \"@yume-chan/struct\";\n\nimport { NOOP } from \"../../utils/index.js\";\n\nimport { AdbSyncRequestId, adbSyncWriteRequest } from \"./request.js\";\nimport { AdbSyncResponseId, adbSyncReadResponse } from \"./response.js\";\nimport type { AdbSyncSocket, AdbSyncSocketLocked } from \"./socket.js\";\nimport { LinuxFileType } from \"./stat.js\";\n\nexport const ADB_SYNC_MAX_PACKET_SIZE = 64 * 1024;\n\nexport interface AdbSyncPushV1Options {\n    socket: AdbSyncSocket;\n    filename: string;\n    file: ReadableStream<MaybeConsumable<Uint8Array>>;\n    type?: LinuxFileType;\n    permission?: number;\n    mtime?: number;\n    packetSize?: number;\n}\n\nexport const AdbSyncOkResponse = new Struct({ littleEndian: true }).uint32(\n    \"unused\",\n);\n\nasync function pipeFileData(\n    locked: AdbSyncSocketLocked,\n    file: ReadableStream<MaybeConsumable<Uint8Array>>,\n    packetSize: number,\n    mtime: number,\n) {\n    // Read and write in parallel,\n    // allow error response to abort the write.\n    const abortController = new AbortController();\n    file.pipeThrough(new DistributionStream(packetSize, true))\n        .pipeTo(\n            new MaybeConsumable.WritableStream({\n                write: async (chunk) => {\n                    await adbSyncWriteRequest(\n                        locked,\n                        AdbSyncRequestId.Data,\n                        chunk,\n                    );\n                },\n            }),\n            { signal: abortController.signal },\n        )\n        .then(async () => {\n            await adbSyncWriteRequest(locked, AdbSyncRequestId.Done, mtime);\n            await locked.flush();\n        }, NOOP);\n\n    await adbSyncReadResponse(\n        locked,\n        AdbSyncResponseId.Ok,\n        AdbSyncOkResponse,\n    ).catch((e) => {\n        abortController.abort();\n        throw e;\n    });\n}\n\nexport async function adbSyncPushV1({\n    socket,\n    filename,\n    file,\n    type = LinuxFileType.File,\n    permission = 0o666,\n    mtime = (Date.now() / 1000) | 0,\n    packetSize = ADB_SYNC_MAX_PACKET_SIZE,\n}: AdbSyncPushV1Options) {\n    const locked = await socket.lock();\n    try {\n        const mode = (type << 12) | permission;\n        const pathAndMode = `${filename},${mode.toString()}`;\n        await adbSyncWriteRequest(locked, AdbSyncRequestId.Send, pathAndMode);\n        await pipeFileData(locked, file, packetSize, mtime);\n    } finally {\n        locked.release();\n    }\n}\n\nexport enum AdbSyncSendV2Flags {\n    None = 0,\n    Brotli = 1,\n    /**\n     * 2\n     */\n    Lz4 = 1 << 1,\n    /**\n     * 4\n     */\n    Zstd = 1 << 2,\n    DryRun = 0x80000000,\n}\n\nexport interface AdbSyncPushV2Options extends AdbSyncPushV1Options {\n    /**\n     * Don't write the file to disk. Requires the `sendrecv_v2` feature.\n     *\n     * It was used during ADB development to benchmark the performance of\n     * compression algorithms.\n     */\n    dryRun?: boolean;\n}\n\nexport const AdbSyncSendV2Request = new Struct({ littleEndian: true })\n    .uint32(\"id\")\n    .uint32(\"mode\")\n    .uint32(\"flags\", placeholder<AdbSyncSendV2Flags>());\n\nexport async function adbSyncPushV2({\n    socket,\n    filename,\n    file,\n    type = LinuxFileType.File,\n    permission = 0o666,\n    mtime = (Date.now() / 1000) | 0,\n    packetSize = ADB_SYNC_MAX_PACKET_SIZE,\n    dryRun = false,\n}: AdbSyncPushV2Options) {\n    const locked = await socket.lock();\n    try {\n        await adbSyncWriteRequest(locked, AdbSyncRequestId.SendV2, filename);\n\n        const mode = (type << 12) | permission;\n        let flags: AdbSyncSendV2Flags = AdbSyncSendV2Flags.None;\n        if (dryRun) {\n            flags |= AdbSyncSendV2Flags.DryRun;\n        }\n        await locked.write(\n            AdbSyncSendV2Request.serialize({\n                id: AdbSyncRequestId.SendV2,\n                mode,\n                flags,\n            }),\n        );\n\n        await pipeFileData(locked, file, packetSize, mtime);\n    } finally {\n        locked.release();\n    }\n}\n\nexport interface AdbSyncPushOptions extends AdbSyncPushV2Options {\n    /**\n     * Whether to use the v2 protocol. Requires the `sendrecv_v2` feature.\n     */\n    v2: boolean;\n}\n\nexport function adbSyncPush(options: AdbSyncPushOptions) {\n    if (options.v2) {\n        return adbSyncPushV2(options);\n    }\n\n    if (options.dryRun) {\n        throw new Error(\"dryRun is not supported in v1\");\n    }\n\n    return adbSyncPushV1(options);\n}\n","import { BufferCombiner, BufferedReadableStream, Consumable, } from \"@yume-chan/stream-extra\";\nimport { AutoResetEvent } from \"../../utils/index.js\";\nexport class AdbSyncSocketLocked {\n    #writer;\n    #readable;\n    #socketLock;\n    #writeLock = new AutoResetEvent();\n    #combiner;\n    get position() {\n        return this.#readable.position;\n    }\n    constructor(writer, readable, bufferSize, lock) {\n        this.#writer = writer;\n        this.#readable = readable;\n        this.#socketLock = lock;\n        this.#combiner = new BufferCombiner(bufferSize);\n    }\n    async #write(buffer) {\n        // `#combiner` will reuse the buffer, so we need to use the Consumable pattern\n        await Consumable.WritableStream.write(this.#writer, buffer);\n    }\n    async flush() {\n        try {\n            await this.#writeLock.wait();\n            const buffer = this.#combiner.flush();\n            if (buffer) {\n                await this.#write(buffer);\n            }\n        }\n        finally {\n            this.#writeLock.notifyOne();\n        }\n    }\n    async write(data) {\n        try {\n            await this.#writeLock.wait();\n            for (const buffer of this.#combiner.push(data)) {\n                await this.#write(buffer);\n            }\n        }\n        finally {\n            this.#writeLock.notifyOne();\n        }\n    }\n    async readExactly(length) {\n        // The request may still be in the internal buffer.\n        // Call `flush` to send it before starting reading\n        await this.flush();\n        return await this.#readable.readExactly(length);\n    }\n    release() {\n        // In theory, the writer shouldn't leave anything in the buffer,\n        // but to be safe, call `flush` to throw away any remaining data.\n        this.#combiner.flush();\n        this.#socketLock.notifyOne();\n    }\n    async close() {\n        await this.#readable.cancel();\n    }\n}\nexport class AdbSyncSocket {\n    #lock = new AutoResetEvent();\n    #socket;\n    #locked;\n    constructor(socket, bufferSize) {\n        this.#socket = socket;\n        this.#locked = new AdbSyncSocketLocked(socket.writable.getWriter(), new BufferedReadableStream(socket.readable), bufferSize, this.#lock);\n    }\n    async lock() {\n        await this.#lock.wait();\n        return this.#locked;\n    }\n    async close() {\n        await this.#locked.close();\n        await this.#socket.close();\n    }\n}\n//# sourceMappingURL=socket.js.map","import type {\n    MaybeConsumable,\n    WritableStreamDefaultWriter,\n} from \"@yume-chan/stream-extra\";\nimport {\n    BufferCombiner,\n    BufferedReadableStream,\n    Consumable,\n} from \"@yume-chan/stream-extra\";\nimport type { AsyncExactReadable } from \"@yume-chan/struct\";\n\nimport type { AdbSocket } from \"../../adb.js\";\nimport { AutoResetEvent } from \"../../utils/index.js\";\n\nexport class AdbSyncSocketLocked implements AsyncExactReadable {\n    readonly #writer: WritableStreamDefaultWriter<MaybeConsumable<Uint8Array>>;\n    readonly #readable: BufferedReadableStream;\n    readonly #socketLock: AutoResetEvent;\n    readonly #writeLock = new AutoResetEvent();\n    readonly #combiner: BufferCombiner;\n\n    get position() {\n        return this.#readable.position;\n    }\n\n    constructor(\n        writer: WritableStreamDefaultWriter<MaybeConsumable<Uint8Array>>,\n        readable: BufferedReadableStream,\n        bufferSize: number,\n        lock: AutoResetEvent,\n    ) {\n        this.#writer = writer;\n        this.#readable = readable;\n        this.#socketLock = lock;\n        this.#combiner = new BufferCombiner(bufferSize);\n    }\n\n    async #write(buffer: Uint8Array) {\n        // `#combiner` will reuse the buffer, so we need to use the Consumable pattern\n        await Consumable.WritableStream.write(this.#writer, buffer);\n    }\n\n    async flush() {\n        try {\n            await this.#writeLock.wait();\n            const buffer = this.#combiner.flush();\n            if (buffer) {\n                await this.#write(buffer);\n            }\n        } finally {\n            this.#writeLock.notifyOne();\n        }\n    }\n\n    async write(data: Uint8Array) {\n        try {\n            await this.#writeLock.wait();\n            for (const buffer of this.#combiner.push(data)) {\n                await this.#write(buffer);\n            }\n        } finally {\n            this.#writeLock.notifyOne();\n        }\n    }\n\n    async readExactly(length: number) {\n        // The request may still be in the internal buffer.\n        // Call `flush` to send it before starting reading\n        await this.flush();\n        return await this.#readable.readExactly(length);\n    }\n\n    release(): void {\n        // In theory, the writer shouldn't leave anything in the buffer,\n        // but to be safe, call `flush` to throw away any remaining data.\n        this.#combiner.flush();\n        this.#socketLock.notifyOne();\n    }\n\n    async close() {\n        await this.#readable.cancel();\n    }\n}\n\nexport class AdbSyncSocket {\n    readonly #lock = new AutoResetEvent();\n    readonly #socket: AdbSocket;\n    readonly #locked: AdbSyncSocketLocked;\n\n    constructor(socket: AdbSocket, bufferSize: number) {\n        this.#socket = socket;\n        this.#locked = new AdbSyncSocketLocked(\n            socket.writable.getWriter(),\n            new BufferedReadableStream(socket.readable),\n            bufferSize,\n            this.#lock,\n        );\n    }\n\n    async lock() {\n        await this.#lock.wait();\n        return this.#locked;\n    }\n\n    async close() {\n        await this.#locked.close();\n        await this.#socket.close();\n    }\n}\n","import { AutoDisposable } from \"@yume-chan/event\";\nimport { AdbFeature } from \"../../features.js\";\nimport { escapeArg } from \"../subprocess/index.js\";\nimport { adbSyncOpenDir } from \"./list.js\";\nimport { adbSyncPull } from \"./pull.js\";\nimport { adbSyncPush } from \"./push.js\";\nimport { AdbSyncSocket } from \"./socket.js\";\nimport { adbSyncLstat, adbSyncStat } from \"./stat.js\";\n/**\n * A simplified `dirname` function that only handles absolute unix paths.\n * @param path an absolute unix path\n * @returns the directory name of the input path\n */\nexport function dirname(path) {\n    const end = path.lastIndexOf(\"/\");\n    if (end === -1) {\n        throw new Error(`Invalid path`);\n    }\n    if (end === 0) {\n        return \"/\";\n    }\n    return path.substring(0, end);\n}\nexport class AdbSync extends AutoDisposable {\n    _adb;\n    _socket;\n    #supportsStat;\n    #supportsListV2;\n    #fixedPushMkdir;\n    #supportsSendReceiveV2;\n    #needPushMkdirWorkaround;\n    get supportsStat() {\n        return this.#supportsStat;\n    }\n    get supportsListV2() {\n        return this.#supportsListV2;\n    }\n    get fixedPushMkdir() {\n        return this.#fixedPushMkdir;\n    }\n    get supportsSendReceiveV2() {\n        return this.#supportsSendReceiveV2;\n    }\n    get needPushMkdirWorkaround() {\n        return this.#needPushMkdirWorkaround;\n    }\n    constructor(adb, socket) {\n        super();\n        this._adb = adb;\n        this._socket = new AdbSyncSocket(socket, adb.maxPayloadSize);\n        this.#supportsStat = adb.canUseFeature(AdbFeature.StatV2);\n        this.#supportsListV2 = adb.canUseFeature(AdbFeature.ListV2);\n        this.#fixedPushMkdir = adb.canUseFeature(AdbFeature.FixedPushMkdir);\n        this.#supportsSendReceiveV2 = adb.canUseFeature(AdbFeature.SendReceiveV2);\n        // https://android.googlesource.com/platform/packages/modules/adb/+/91768a57b7138166e0a3d11f79cd55909dda7014/client/file_sync_client.cpp#1361\n        this.#needPushMkdirWorkaround =\n            this._adb.canUseFeature(AdbFeature.ShellV2) && !this.fixedPushMkdir;\n    }\n    /**\n     * Gets information of a file or folder.\n     *\n     * If `path` points to a symbolic link, the returned information is about the link itself (with `type` being `LinuxFileType.Link`).\n     */\n    async lstat(path) {\n        return await adbSyncLstat(this._socket, path, this.#supportsStat);\n    }\n    /**\n     * Gets the information of a file or folder.\n     *\n     * If `path` points to a symbolic link, it will be resolved and the returned information is about the target (with `type` being `LinuxFileType.File` or `LinuxFileType.Directory`).\n     */\n    async stat(path) {\n        if (!this.#supportsStat) {\n            throw new Error(\"Not supported\");\n        }\n        return await adbSyncStat(this._socket, path);\n    }\n    /**\n     * Checks if `path` is a directory, or a symbolic link to a directory.\n     *\n     * This uses `lstat` internally, thus works on all Android versions.\n     */\n    async isDirectory(path) {\n        try {\n            await this.lstat(path + \"/\");\n            return true;\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    opendir(path) {\n        return adbSyncOpenDir(this._socket, path, this.supportsListV2);\n    }\n    async readdir(path) {\n        const results = [];\n        for await (const entry of this.opendir(path)) {\n            results.push(entry);\n        }\n        return results;\n    }\n    /**\n     * Reads the content of a file on device.\n     *\n     * @param filename The full path of the file on device to read.\n     * @returns A `ReadableStream` that contains the file content.\n     */\n    read(filename) {\n        return adbSyncPull(this._socket, filename);\n    }\n    /**\n     * Writes a file on device. If the file name already exists, it will be overwritten.\n     *\n     * @param options The content and options of the file to write.\n     */\n    async write(options) {\n        if (this.needPushMkdirWorkaround) {\n            // It may fail if `filename` already exists.\n            // Ignore the result.\n            // TODO: sync: test push mkdir workaround (need an Android 8 device)\n            await this._adb.subprocess.spawnAndWait([\n                \"mkdir\",\n                \"-p\",\n                escapeArg(dirname(options.filename)),\n            ]);\n        }\n        await adbSyncPush({\n            v2: this.supportsSendReceiveV2,\n            socket: this._socket,\n            ...options,\n        });\n    }\n    lockSocket() {\n        return this._socket.lock();\n    }\n    async dispose() {\n        super.dispose();\n        await this._socket.close();\n    }\n}\n//# sourceMappingURL=sync.js.map","import { AutoDisposable } from \"@yume-chan/event\";\nimport type { MaybeConsumable, ReadableStream } from \"@yume-chan/stream-extra\";\n\nimport type { Adb, AdbSocket } from \"../../adb.js\";\nimport { AdbFeature } from \"../../features.js\";\nimport { escapeArg } from \"../subprocess/index.js\";\n\nimport type { AdbSyncEntry } from \"./list.js\";\nimport { adbSyncOpenDir } from \"./list.js\";\nimport { adbSyncPull } from \"./pull.js\";\nimport { adbSyncPush } from \"./push.js\";\nimport type { AdbSyncSocketLocked } from \"./socket.js\";\nimport { AdbSyncSocket } from \"./socket.js\";\nimport type { AdbSyncStat, LinuxFileType } from \"./stat.js\";\nimport { adbSyncLstat, adbSyncStat } from \"./stat.js\";\n\n/**\n * A simplified `dirname` function that only handles absolute unix paths.\n * @param path an absolute unix path\n * @returns the directory name of the input path\n */\nexport function dirname(path: string): string {\n    const end = path.lastIndexOf(\"/\");\n    if (end === -1) {\n        throw new Error(`Invalid path`);\n    }\n    if (end === 0) {\n        return \"/\";\n    }\n    return path.substring(0, end);\n}\n\nexport interface AdbSyncWriteOptions {\n    filename: string;\n    file: ReadableStream<MaybeConsumable<Uint8Array>>;\n    type?: LinuxFileType;\n    permission?: number;\n    mtime?: number;\n    dryRun?: boolean;\n}\n\nexport class AdbSync extends AutoDisposable {\n    protected _adb: Adb;\n    protected _socket: AdbSyncSocket;\n\n    readonly #supportsStat: boolean;\n    readonly #supportsListV2: boolean;\n    readonly #fixedPushMkdir: boolean;\n    readonly #supportsSendReceiveV2: boolean;\n    readonly #needPushMkdirWorkaround: boolean;\n\n    get supportsStat(): boolean {\n        return this.#supportsStat;\n    }\n\n    get supportsListV2(): boolean {\n        return this.#supportsListV2;\n    }\n\n    get fixedPushMkdir(): boolean {\n        return this.#fixedPushMkdir;\n    }\n\n    get supportsSendReceiveV2(): boolean {\n        return this.#supportsSendReceiveV2;\n    }\n\n    get needPushMkdirWorkaround(): boolean {\n        return this.#needPushMkdirWorkaround;\n    }\n\n    constructor(adb: Adb, socket: AdbSocket) {\n        super();\n\n        this._adb = adb;\n        this._socket = new AdbSyncSocket(socket, adb.maxPayloadSize);\n\n        this.#supportsStat = adb.canUseFeature(AdbFeature.StatV2);\n        this.#supportsListV2 = adb.canUseFeature(AdbFeature.ListV2);\n        this.#fixedPushMkdir = adb.canUseFeature(AdbFeature.FixedPushMkdir);\n        this.#supportsSendReceiveV2 = adb.canUseFeature(\n            AdbFeature.SendReceiveV2,\n        );\n        // https://android.googlesource.com/platform/packages/modules/adb/+/91768a57b7138166e0a3d11f79cd55909dda7014/client/file_sync_client.cpp#1361\n        this.#needPushMkdirWorkaround =\n            this._adb.canUseFeature(AdbFeature.ShellV2) && !this.fixedPushMkdir;\n    }\n\n    /**\n     * Gets information of a file or folder.\n     *\n     * If `path` points to a symbolic link, the returned information is about the link itself (with `type` being `LinuxFileType.Link`).\n     */\n    async lstat(path: string): Promise<AdbSyncStat> {\n        return await adbSyncLstat(this._socket, path, this.#supportsStat);\n    }\n\n    /**\n     * Gets the information of a file or folder.\n     *\n     * If `path` points to a symbolic link, it will be resolved and the returned information is about the target (with `type` being `LinuxFileType.File` or `LinuxFileType.Directory`).\n     */\n    async stat(path: string) {\n        if (!this.#supportsStat) {\n            throw new Error(\"Not supported\");\n        }\n\n        return await adbSyncStat(this._socket, path);\n    }\n\n    /**\n     * Checks if `path` is a directory, or a symbolic link to a directory.\n     *\n     * This uses `lstat` internally, thus works on all Android versions.\n     */\n    async isDirectory(path: string): Promise<boolean> {\n        try {\n            await this.lstat(path + \"/\");\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    opendir(path: string): AsyncGenerator<AdbSyncEntry, void, void> {\n        return adbSyncOpenDir(this._socket, path, this.supportsListV2);\n    }\n\n    async readdir(path: string) {\n        const results: AdbSyncEntry[] = [];\n        for await (const entry of this.opendir(path)) {\n            results.push(entry);\n        }\n        return results;\n    }\n\n    /**\n     * Reads the content of a file on device.\n     *\n     * @param filename The full path of the file on device to read.\n     * @returns A `ReadableStream` that contains the file content.\n     */\n    read(filename: string): ReadableStream<Uint8Array> {\n        return adbSyncPull(this._socket, filename);\n    }\n\n    /**\n     * Writes a file on device. If the file name already exists, it will be overwritten.\n     *\n     * @param options The content and options of the file to write.\n     */\n    async write(options: AdbSyncWriteOptions): Promise<void> {\n        if (this.needPushMkdirWorkaround) {\n            // It may fail if `filename` already exists.\n            // Ignore the result.\n            // TODO: sync: test push mkdir workaround (need an Android 8 device)\n            await this._adb.subprocess.spawnAndWait([\n                \"mkdir\",\n                \"-p\",\n                escapeArg(dirname(options.filename)),\n            ]);\n        }\n\n        await adbSyncPush({\n            v2: this.supportsSendReceiveV2,\n            socket: this._socket,\n            ...options,\n        });\n    }\n\n    lockSocket(): Promise<AdbSyncSocketLocked> {\n        return this._socket.lock();\n    }\n\n    override async dispose() {\n        super.dispose();\n        await this._socket.close();\n    }\n}\n","import { AdbCommandBase } from \"./base.js\";\nexport class AdbTcpIpCommand extends AdbCommandBase {\n    #parsePort(value) {\n        if (!value || value === \"0\") {\n            return undefined;\n        }\n        return Number.parseInt(value, 10);\n    }\n    async getListenAddresses() {\n        const serviceListenAddresses = await this.adb.getProp(\"service.adb.listen_addrs\");\n        const servicePort = await this.adb.getProp(\"service.adb.tcp.port\");\n        const persistPort = await this.adb.getProp(\"persist.adb.tcp.port\");\n        return {\n            serviceListenAddresses: serviceListenAddresses != \"\"\n                ? serviceListenAddresses.split(\",\")\n                : [],\n            servicePort: this.#parsePort(servicePort),\n            persistPort: this.#parsePort(persistPort),\n        };\n    }\n    async setPort(port) {\n        if (port <= 0) {\n            throw new TypeError(`Invalid port ${port}`);\n        }\n        const output = await this.adb.createSocketAndWait(`tcpip:${port}`);\n        if (output !== `restarting in TCP mode port: ${port}\\n`) {\n            throw new Error(output);\n        }\n        return output;\n    }\n    async disable() {\n        const output = await this.adb.createSocketAndWait(\"usb:\");\n        if (output !== \"restarting in USB mode\\n\") {\n            throw new Error(output);\n        }\n        return output;\n    }\n}\n//# sourceMappingURL=tcpip.js.map","import { AdbCommandBase } from \"./base.js\";\n\n/**\n * ADB daemon checks for the following properties in the order of\n *\n * * `serviceListenAddresses` (`service.adb.listen_addrs`)\n * * `servicePort` (`service.adb.tcp.port`)\n * * `persistPort` (`persist.adb.tcp.port`)\n *\n * Once it finds a non-empty value, it will use it and ignore the rest.\n *\n * `serviceListenAddresses` and `persistPort` are fixed at build time,\n * only `servicePort` can be changed using `setPort` and `disable`.\n * This means if either `serviceListenAddresses` or `persistPort` is non-empty,\n * ADB over WiFi is always enabled.\n */\nexport interface AdbTcpIpListenAddresses {\n    serviceListenAddresses: string[];\n    servicePort: number | undefined;\n    persistPort: number | undefined;\n}\n\nexport class AdbTcpIpCommand extends AdbCommandBase {\n    #parsePort(value: string): number | undefined {\n        if (!value || value === \"0\") {\n            return undefined;\n        }\n        return Number.parseInt(value, 10);\n    }\n\n    async getListenAddresses(): Promise<AdbTcpIpListenAddresses> {\n        const serviceListenAddresses = await this.adb.getProp(\n            \"service.adb.listen_addrs\",\n        );\n        const servicePort = await this.adb.getProp(\"service.adb.tcp.port\");\n        const persistPort = await this.adb.getProp(\"persist.adb.tcp.port\");\n\n        return {\n            serviceListenAddresses:\n                serviceListenAddresses != \"\"\n                    ? serviceListenAddresses.split(\",\")\n                    : [],\n            servicePort: this.#parsePort(servicePort),\n            persistPort: this.#parsePort(persistPort),\n        };\n    }\n\n    async setPort(port: number): Promise<string> {\n        if (port <= 0) {\n            throw new TypeError(`Invalid port ${port}`);\n        }\n\n        const output = await this.adb.createSocketAndWait(`tcpip:${port}`);\n        if (output !== `restarting in TCP mode port: ${port}\\n`) {\n            throw new Error(output);\n        }\n        return output;\n    }\n\n    async disable(): Promise<string> {\n        const output = await this.adb.createSocketAndWait(\"usb:\");\n        if (output !== \"restarting in USB mode\\n\") {\n            throw new Error(output);\n        }\n        return output;\n    }\n}\n","export var AdbBannerKey;\n(function (AdbBannerKey) {\n    AdbBannerKey[\"Product\"] = \"ro.product.name\";\n    AdbBannerKey[\"Model\"] = \"ro.product.model\";\n    AdbBannerKey[\"Device\"] = \"ro.product.device\";\n    AdbBannerKey[\"Features\"] = \"features\";\n})(AdbBannerKey || (AdbBannerKey = {}));\nexport class AdbBanner {\n    static parse(banner) {\n        let product;\n        let model;\n        let device;\n        let features = [];\n        const pieces = banner.split(\"::\");\n        if (pieces.length > 1) {\n            const props = pieces[1];\n            for (const prop of props.split(\";\")) {\n                // istanbul ignore if\n                if (!prop) {\n                    continue;\n                }\n                const keyValue = prop.split(\"=\");\n                if (keyValue.length !== 2) {\n                    continue;\n                }\n                const [key, value] = keyValue;\n                switch (key) {\n                    case AdbBannerKey.Product:\n                        product = value;\n                        break;\n                    case AdbBannerKey.Model:\n                        model = value;\n                        break;\n                    case AdbBannerKey.Device:\n                        device = value;\n                        break;\n                    case AdbBannerKey.Features:\n                        features = value.split(\",\");\n                        break;\n                }\n            }\n        }\n        return new AdbBanner(product, model, device, features);\n    }\n    #product;\n    get product() {\n        return this.#product;\n    }\n    #model;\n    get model() {\n        return this.#model;\n    }\n    #device;\n    get device() {\n        return this.#device;\n    }\n    #features = [];\n    get features() {\n        return this.#features;\n    }\n    constructor(product, model, device, features) {\n        this.#product = product;\n        this.#model = model;\n        this.#device = device;\n        this.#features = features;\n    }\n}\n//# sourceMappingURL=banner.js.map","import type { AdbFeature } from \"./features.js\";\n\nexport enum AdbBannerKey {\n    Product = \"ro.product.name\",\n    Model = \"ro.product.model\",\n    Device = \"ro.product.device\",\n    Features = \"features\",\n}\n\nexport class AdbBanner {\n    static parse(banner: string) {\n        let product: string | undefined;\n        let model: string | undefined;\n        let device: string | undefined;\n        let features: AdbFeature[] = [];\n\n        const pieces = banner.split(\"::\");\n        if (pieces.length > 1) {\n            const props = pieces[1]!;\n            for (const prop of props.split(\";\")) {\n                // istanbul ignore if\n                if (!prop) {\n                    continue;\n                }\n\n                const keyValue = prop.split(\"=\");\n                if (keyValue.length !== 2) {\n                    continue;\n                }\n\n                const [key, value] = keyValue;\n                switch (key) {\n                    case AdbBannerKey.Product:\n                        product = value;\n                        break;\n                    case AdbBannerKey.Model:\n                        model = value;\n                        break;\n                    case AdbBannerKey.Device:\n                        device = value;\n                        break;\n                    case AdbBannerKey.Features:\n                        features = value!.split(\",\") as AdbFeature[];\n                        break;\n                }\n            }\n        }\n\n        return new AdbBanner(product, model, device, features);\n    }\n\n    #product: string | undefined;\n    get product() {\n        return this.#product;\n    }\n\n    #model: string | undefined;\n    get model() {\n        return this.#model;\n    }\n\n    #device: string | undefined;\n    get device() {\n        return this.#device;\n    }\n\n    #features: AdbFeature[] = [];\n    get features() {\n        return this.#features;\n    }\n\n    constructor(\n        product: string | undefined,\n        model: string | undefined,\n        device: string | undefined,\n        features: AdbFeature[],\n    ) {\n        this.#product = product;\n        this.#model = model;\n        this.#device = device;\n        this.#features = features;\n    }\n}\n","export * from \"./auth.js\";\nexport * from \"./crypto.js\";\nexport * from \"./device.js\";\nexport * from \"./dispatcher.js\";\nexport * from \"./packet.js\";\nexport * from \"./socket.js\";\nexport * from \"./transport.js\";\n","import { PromiseResolver } from \"@yume-chan/async\";\nimport { EMPTY_UINT8_ARRAY } from \"@yume-chan/struct\";\nimport { calculateBase64EncodedLength, encodeBase64, encodeUtf8, } from \"../utils/index.js\";\nimport { adbGeneratePublicKey, adbGetPublicKeySize, rsaSign, } from \"./crypto.js\";\nimport { AdbCommand } from \"./packet.js\";\nexport var AdbAuthType;\n(function (AdbAuthType) {\n    AdbAuthType[AdbAuthType[\"Token\"] = 1] = \"Token\";\n    AdbAuthType[AdbAuthType[\"Signature\"] = 2] = \"Signature\";\n    AdbAuthType[AdbAuthType[\"PublicKey\"] = 3] = \"PublicKey\";\n})(AdbAuthType || (AdbAuthType = {}));\nexport const AdbSignatureAuthenticator = async function* (credentialStore, getNextRequest) {\n    for await (const key of credentialStore.iterateKeys()) {\n        const packet = await getNextRequest();\n        if (packet.arg0 !== AdbAuthType.Token) {\n            return;\n        }\n        const signature = rsaSign(key.buffer, packet.payload);\n        yield {\n            command: AdbCommand.Auth,\n            arg0: AdbAuthType.Signature,\n            arg1: 0,\n            payload: signature,\n        };\n    }\n};\nexport const AdbPublicKeyAuthenticator = async function* (credentialStore, getNextRequest) {\n    const packet = await getNextRequest();\n    if (packet.arg0 !== AdbAuthType.Token) {\n        return;\n    }\n    let privateKey;\n    for await (const key of credentialStore.iterateKeys()) {\n        privateKey = key;\n        break;\n    }\n    if (!privateKey) {\n        privateKey = await credentialStore.generateKey();\n    }\n    const publicKeyLength = adbGetPublicKeySize();\n    const [publicKeyBase64Length] = calculateBase64EncodedLength(publicKeyLength);\n    const nameBuffer = privateKey.name?.length\n        ? encodeUtf8(privateKey.name)\n        : EMPTY_UINT8_ARRAY;\n    const publicKeyBuffer = new Uint8Array(publicKeyBase64Length +\n        (nameBuffer.length ? nameBuffer.length + 1 : 0) + // Space character + name\n        1);\n    adbGeneratePublicKey(privateKey.buffer, publicKeyBuffer);\n    encodeBase64(publicKeyBuffer.subarray(0, publicKeyLength), publicKeyBuffer);\n    if (nameBuffer.length) {\n        publicKeyBuffer[publicKeyBase64Length] = 0x20;\n        publicKeyBuffer.set(nameBuffer, publicKeyBase64Length + 1);\n    }\n    yield {\n        command: AdbCommand.Auth,\n        arg0: AdbAuthType.PublicKey,\n        arg1: 0,\n        payload: publicKeyBuffer,\n    };\n};\nexport const ADB_DEFAULT_AUTHENTICATORS = [\n    AdbSignatureAuthenticator,\n    AdbPublicKeyAuthenticator,\n];\nexport class AdbAuthenticationProcessor {\n    authenticators;\n    #credentialStore;\n    #pendingRequest = new PromiseResolver();\n    #iterator;\n    constructor(authenticators, credentialStore) {\n        this.authenticators = authenticators;\n        this.#credentialStore = credentialStore;\n    }\n    #getNextRequest = () => {\n        return this.#pendingRequest.promise;\n    };\n    async *#invokeAuthenticator() {\n        for (const authenticator of this.authenticators) {\n            for await (const packet of authenticator(this.#credentialStore, this.#getNextRequest)) {\n                // If the authenticator yielded a response\n                // Prepare `nextRequest` for next authentication request\n                this.#pendingRequest = new PromiseResolver();\n                // Yield the response to outer layer\n                yield packet;\n            }\n            // If the authenticator returned,\n            // Next authenticator will be given the same `pendingRequest`\n        }\n    }\n    async process(packet) {\n        if (!this.#iterator) {\n            this.#iterator = this.#invokeAuthenticator();\n        }\n        this.#pendingRequest.resolve(packet);\n        const result = await this.#iterator.next();\n        if (result.done) {\n            throw new Error(\"No authenticator can handle the request\");\n        }\n        return result.value;\n    }\n    dispose() {\n        void this.#iterator?.return?.();\n    }\n}\n//# sourceMappingURL=auth.js.map","import { PromiseResolver } from \"@yume-chan/async\";\nimport type { Disposable } from \"@yume-chan/event\";\nimport type { ValueOrPromise } from \"@yume-chan/struct\";\nimport { EMPTY_UINT8_ARRAY } from \"@yume-chan/struct\";\n\nimport {\n    calculateBase64EncodedLength,\n    encodeBase64,\n    encodeUtf8,\n} from \"../utils/index.js\";\n\nimport {\n    adbGeneratePublicKey,\n    adbGetPublicKeySize,\n    rsaSign,\n} from \"./crypto.js\";\nimport type { AdbPacketData } from \"./packet.js\";\nimport { AdbCommand } from \"./packet.js\";\n\nexport interface AdbPrivateKey {\n    /**\n     * The private key in PKCS #8 format.\n     */\n    buffer: Uint8Array;\n    name?: string | undefined;\n}\n\nexport type AdbKeyIterable =\n    | Iterable<AdbPrivateKey>\n    | AsyncIterable<AdbPrivateKey>;\n\nexport interface AdbCredentialStore {\n    /**\n     * Generates and stores a RSA private key with modulus length `2048` and public exponent `65537`.\n     */\n    generateKey(): ValueOrPromise<AdbPrivateKey>;\n\n    /**\n     * Synchronously or asynchronously iterates through all stored RSA private keys.\n     *\n     * Each call to `iterateKeys` must return a different iterator that iterate through all stored keys.\n     */\n    iterateKeys(): AdbKeyIterable;\n}\n\nexport enum AdbAuthType {\n    Token = 1,\n    Signature = 2,\n    PublicKey = 3,\n}\n\nexport interface AdbAuthenticator {\n    /**\n     * @param getNextRequest\n     *\n     * Call this function to get the next authentication request packet from device.\n     *\n     * After calling `getNextRequest`, authenticator can `yield` a packet as response, or `return` to indicate its incapability of handling the request.\n     *\n     * After `return`, the `AdbAuthenticatorHandler` will move on to next authenticator and never go back.\n     *\n     * Calling `getNextRequest` multiple times without `yield` or `return` will always return the same request.\n     */\n    (\n        credentialStore: AdbCredentialStore,\n        getNextRequest: () => Promise<AdbPacketData>,\n    ): AsyncIterable<AdbPacketData>;\n}\n\nexport const AdbSignatureAuthenticator: AdbAuthenticator = async function* (\n    credentialStore: AdbCredentialStore,\n    getNextRequest: () => Promise<AdbPacketData>,\n): AsyncIterable<AdbPacketData> {\n    for await (const key of credentialStore.iterateKeys()) {\n        const packet = await getNextRequest();\n\n        if (packet.arg0 !== AdbAuthType.Token) {\n            return;\n        }\n\n        const signature = rsaSign(key.buffer, packet.payload);\n        yield {\n            command: AdbCommand.Auth,\n            arg0: AdbAuthType.Signature,\n            arg1: 0,\n            payload: signature,\n        };\n    }\n};\n\nexport const AdbPublicKeyAuthenticator: AdbAuthenticator = async function* (\n    credentialStore: AdbCredentialStore,\n    getNextRequest: () => Promise<AdbPacketData>,\n): AsyncIterable<AdbPacketData> {\n    const packet = await getNextRequest();\n\n    if (packet.arg0 !== AdbAuthType.Token) {\n        return;\n    }\n\n    let privateKey: AdbPrivateKey | undefined;\n    for await (const key of credentialStore.iterateKeys()) {\n        privateKey = key;\n        break;\n    }\n\n    if (!privateKey) {\n        privateKey = await credentialStore.generateKey();\n    }\n\n    const publicKeyLength = adbGetPublicKeySize();\n    const [publicKeyBase64Length] =\n        calculateBase64EncodedLength(publicKeyLength);\n\n    const nameBuffer = privateKey.name?.length\n        ? encodeUtf8(privateKey.name)\n        : EMPTY_UINT8_ARRAY;\n    const publicKeyBuffer = new Uint8Array(\n        publicKeyBase64Length +\n            (nameBuffer.length ? nameBuffer.length + 1 : 0) + // Space character + name\n            1, // Null character\n    );\n\n    adbGeneratePublicKey(privateKey.buffer, publicKeyBuffer);\n    encodeBase64(publicKeyBuffer.subarray(0, publicKeyLength), publicKeyBuffer);\n\n    if (nameBuffer.length) {\n        publicKeyBuffer[publicKeyBase64Length] = 0x20;\n        publicKeyBuffer.set(nameBuffer, publicKeyBase64Length + 1);\n    }\n\n    yield {\n        command: AdbCommand.Auth,\n        arg0: AdbAuthType.PublicKey,\n        arg1: 0,\n        payload: publicKeyBuffer,\n    };\n};\n\nexport const ADB_DEFAULT_AUTHENTICATORS: AdbAuthenticator[] = [\n    AdbSignatureAuthenticator,\n    AdbPublicKeyAuthenticator,\n];\n\nexport class AdbAuthenticationProcessor implements Disposable {\n    readonly authenticators: readonly AdbAuthenticator[];\n\n    readonly #credentialStore: AdbCredentialStore;\n\n    #pendingRequest = new PromiseResolver<AdbPacketData>();\n    #iterator: AsyncIterator<AdbPacketData, void, void> | undefined;\n\n    constructor(\n        authenticators: readonly AdbAuthenticator[],\n        credentialStore: AdbCredentialStore,\n    ) {\n        this.authenticators = authenticators;\n        this.#credentialStore = credentialStore;\n    }\n\n    #getNextRequest = (): Promise<AdbPacketData> => {\n        return this.#pendingRequest.promise;\n    };\n\n    async *#invokeAuthenticator(): AsyncGenerator<AdbPacketData, void, void> {\n        for (const authenticator of this.authenticators) {\n            for await (const packet of authenticator(\n                this.#credentialStore,\n                this.#getNextRequest,\n            )) {\n                // If the authenticator yielded a response\n                // Prepare `nextRequest` for next authentication request\n                this.#pendingRequest = new PromiseResolver();\n\n                // Yield the response to outer layer\n                yield packet;\n            }\n\n            // If the authenticator returned,\n            // Next authenticator will be given the same `pendingRequest`\n        }\n    }\n\n    async process(packet: AdbPacketData): Promise<AdbPacketData> {\n        if (!this.#iterator) {\n            this.#iterator = this.#invokeAuthenticator();\n        }\n\n        this.#pendingRequest.resolve(packet);\n\n        const result = await this.#iterator.next();\n        if (result.done) {\n            throw new Error(\"No authenticator can handle the request\");\n        }\n\n        return result.value;\n    }\n\n    dispose() {\n        void this.#iterator?.return?.();\n    }\n}\n","import { getUint64BigEndian, setInt64BigEndian, setInt64LittleEndian, } from \"@yume-chan/no-data-view\";\n/**\n * Gets the `BigInt` value at the specified byte offset and length from the start of the view. There is\n * no alignment constraint; multi-byte values may be fetched from any offset.\n *\n * Only supports Big-Endian, because that's what ADB uses.\n * @param byteOffset The place in the buffer at which the value should be retrieved.\n */\nexport function getBigUint(array, byteOffset, length) {\n    let result = 0n;\n    // Currently `length` must be a multiplication of 8\n    // Support for arbitrary length can be easily added\n    for (let i = byteOffset; i < byteOffset + length; i += 8) {\n        result <<= 64n;\n        const value = getUint64BigEndian(array, i);\n        result |= value;\n    }\n    return result;\n}\n/**\n * Stores an arbitrary-precision positive `BigInt` value at the specified byte offset from the start of the view.\n * @param byteOffset The place in the buffer at which the value should be set.\n * @param length The number of bytes to set.\n * @param value The value to set.\n * @param littleEndian If `false` or `undefined`, a big-endian value should be written,\n * otherwise a little-endian value should be written.\n */\nexport function setBigUint(array, byteOffset, length, value, littleEndian) {\n    if (littleEndian) {\n        while (value > 0n) {\n            setInt64LittleEndian(array, byteOffset, value);\n            byteOffset += 8;\n            value >>= 64n;\n        }\n    }\n    else {\n        let position = byteOffset + length - 8;\n        while (value > 0n) {\n            setInt64BigEndian(array, position, value);\n            position -= 8;\n            value >>= 64n;\n        }\n    }\n}\n// These values are correct only if\n// modulus length is 2048 and\n// public exponent (e) is 65537\n// Anyway, that's how this library generates keys\n// To support other parameters,\n// a proper ASN.1 parser can be used\n// References:\n//\n//   https://tools.ietf.org/html/rfc8017#appendix-A.1.2\n//   PKCS #1: RSA Cryptography Specifications Version 2.2\n//     A.1.2.  RSA Private Key Syntax\n//\n//   https://lapo.it/asn1js/\n//   https://github.com/lapo-luchini/asn1js\n//   ASN.1 JavaScript decoder\n//\n//   https://www.itu.int/rec/T-REC-X.690-201508-I/en\n//   X.690: Specification of Distinguished Encoding Rules (DER)\nconst RsaPrivateKeyNOffset = 38;\nconst RsaPrivateKeyNLength = 2048 / 8;\nconst RsaPrivateKeyDOffset = 303;\nconst RsaPrivateKeyDLength = 2048 / 8;\nexport function rsaParsePrivateKey(key) {\n    const n = getBigUint(key, RsaPrivateKeyNOffset, RsaPrivateKeyNLength);\n    const d = getBigUint(key, RsaPrivateKeyDOffset, RsaPrivateKeyDLength);\n    return [n, d];\n}\nfunction nonNegativeMod(m, d) {\n    const r = m % d;\n    if (r > 0) {\n        return r;\n    }\n    return r + (d > 0 ? d : -d);\n}\n// https://en.wikipedia.org/wiki/Modular_multiplicative_inverse\n// Solve for the smallest positive `x` in the equation `a * x  1 (mod m)`,\n// or in other words, `a * x % m = 1`\n// Taken from https://stackoverflow.com/a/51562038\n// Only used with numbers smaller than 2^32 so doesn't need BigInt\nexport function modInverse(a, m) {\n    a = nonNegativeMod(a, m);\n    if (!a || m < 2) {\n        return NaN; // invalid input\n    }\n    // find the gcd\n    const s = [];\n    let b = m;\n    while (b) {\n        [a, b] = [b, a % b];\n        s.push({ a, b });\n    }\n    /* istanbul ignore next */\n    if (a !== 1) {\n        return NaN; // inverse does not exists\n    }\n    // find the inverse\n    let x = 1;\n    let y = 0;\n    for (let i = s.length - 2; i >= 0; i -= 1) {\n        [x, y] = [y, x - y * Math.floor(s[i].a / s[i].b)];\n    }\n    return nonNegativeMod(y, m);\n}\nconst ModulusLengthInBytes = 2048 / 8;\nconst ModulusLengthInWords = ModulusLengthInBytes / 4;\nexport function adbGetPublicKeySize() {\n    return 4 + 4 + ModulusLengthInBytes + ModulusLengthInBytes + 4;\n}\nexport function adbGeneratePublicKey(privateKey, output) {\n    // cspell: ignore: mincrypt\n    // Android 6 and earlier has its own encryption library called mincrypt\n    // This is the RSA public key format used by mincrypt:\n    // https://android.googlesource.com/platform/system/core/+/bb0c180e62703c2068a1b2c9f8ba6d634bf1553c/include/mincrypt/rsa.h#46\n    // `n0inv` and `rr` are pre-calculated to speed up RSA operations\n    // Android 7 switched its encryption library to BoringSSL, but still keeps the key format:\n    // https://android.googlesource.com/platform/system/core.git/+/91784040db2b9273687f88d8b95f729d4a61ecc2/libcrypto_utils/android_pubkey.cpp#38\n    // Except when reading a key, `n0inv` and `rr` are ignored (they are still populated when generating a key):\n    // https://android.googlesource.com/platform/system/core.git/+/91784040db2b9273687f88d8b95f729d4a61ecc2/libcrypto_utils/android_pubkey.cpp#55\n    // The public key is a struct (in little endian) of:\n    //\n    // [\n    //   modulusLengthInWords, // 32-bit integer, a \"word\" is 32-bit so it must be 2048 / 8 / 4\n    //                         // (the comment in Android source code is incorrect saying \"This must be ANDROID_PUBKEY_MODULUS_SIZE\")\n    //   n0inv,                // 32-bit integer, the modular inverse of (lower 32 bits of `n`)\n    //   modulus,              // `n`\n    //   rr,                   // Montgomery parameter R^2\n    //   exponent,             // 32-bit integer, must be 3 or 65537\n    // ]\n    let outputType;\n    const outputLength = adbGetPublicKeySize();\n    if (!output) {\n        output = new Uint8Array(outputLength);\n        outputType = \"Uint8Array\";\n    }\n    else {\n        if (output.length < outputLength) {\n            throw new TypeError(\"output buffer is too small\");\n        }\n        outputType = \"number\";\n    }\n    const outputView = new DataView(output.buffer, output.byteOffset, output.length);\n    let outputOffset = 0;\n    // modulusLengthInWords\n    outputView.setUint32(outputOffset, ModulusLengthInWords, true);\n    outputOffset += 4;\n    // extract `n` from private key\n    const [n] = rsaParsePrivateKey(privateKey);\n    // Calculate `n0inv`\n    const n0inv = -modInverse(Number(n % 2n ** 32n), 2 ** 32);\n    outputView.setInt32(outputOffset, n0inv, true);\n    outputOffset += 4;\n    // Write `n` (a.k.a. `modulus`)\n    setBigUint(output, outputOffset, ModulusLengthInBytes, n, true);\n    outputOffset += ModulusLengthInBytes;\n    // Calculate rr = (2 ** (rsa_size)) ** 2 % n\n    const rr = 2n ** 4096n % n;\n    setBigUint(output, outputOffset, ModulusLengthInBytes, rr, true);\n    outputOffset += ModulusLengthInBytes;\n    // exponent\n    outputView.setUint32(outputOffset, 65537, true);\n    outputOffset += 4;\n    if (outputType === \"Uint8Array\") {\n        return output;\n    }\n    else {\n        return outputLength;\n    }\n}\n/**\n * Modular exponentiation.\n *\n * Calculate `(base ** exponent) % modulus` without actually calculating `(base ** exponent)`.\n *\n * See https://en.wikipedia.org/wiki/Modular_exponentiation#Implementation_in_Lua\n */\nexport function powMod(base, exponent, modulus) {\n    if (modulus === 1n) {\n        return 0n;\n    }\n    let r = 1n;\n    base = base % modulus;\n    while (exponent > 0n) {\n        if (BigInt.asUintN(1, exponent) === 1n) {\n            r = (r * base) % modulus;\n        }\n        base = (base * base) % modulus;\n        exponent >>= 1n;\n    }\n    return r;\n}\nexport const SHA1_DIGEST_LENGTH = 20;\nexport const ASN1_SEQUENCE = 0x30;\nexport const ASN1_OCTET_STRING = 0x04;\nexport const ASN1_NULL = 0x05;\nexport const ASN1_OID = 0x06;\n// PKCS#1 SHA-1 hash digest info\nexport const SHA1_DIGEST_INFO = new Uint8Array([\n    ASN1_SEQUENCE,\n    0x0d + SHA1_DIGEST_LENGTH,\n    ASN1_SEQUENCE,\n    0x09,\n    // SHA-1 (1 3 14 3 2 26)\n    ASN1_OID,\n    0x05,\n    1 * 40 + 3,\n    14,\n    3,\n    2,\n    26,\n    ASN1_NULL,\n    0x00,\n    ASN1_OCTET_STRING,\n    SHA1_DIGEST_LENGTH,\n]);\n// SubtleCrypto.sign() will hash the given data and sign the hash\n// But we don't need the hashing step\n// (In another word, ADB just requires the client to\n// encrypt the given data with its private key)\n// However SubtileCrypto.encrypt() doesn't accept 'RSASSA-PKCS1-v1_5' algorithm\n// So we need to implement the encryption by ourself\nexport function rsaSign(privateKey, data) {\n    const [n, d] = rsaParsePrivateKey(privateKey);\n    // PKCS#1 padding\n    const padded = new Uint8Array(256);\n    let index = 0;\n    padded[index] = 0;\n    index += 1;\n    padded[index] = 1;\n    index += 1;\n    const fillLength = padded.length - SHA1_DIGEST_INFO.length - data.length - 1;\n    while (index < fillLength) {\n        padded[index] = 0xff;\n        index += 1;\n    }\n    padded[index] = 0;\n    index += 1;\n    padded.set(SHA1_DIGEST_INFO, index);\n    index += SHA1_DIGEST_INFO.length;\n    padded.set(data, index);\n    // Encryption\n    // signature = padded ** d % n\n    const signature = powMod(getBigUint(padded, 0, padded.length), d, n);\n    // `padded` is not used anymore,\n    // re-use the buffer to store the result\n    setBigUint(padded, 0, padded.length, signature, false);\n    return padded;\n}\n//# sourceMappingURL=crypto.js.map","import {\n    getUint64BigEndian,\n    setInt64BigEndian,\n    setInt64LittleEndian,\n} from \"@yume-chan/no-data-view\";\n\n/**\n * Gets the `BigInt` value at the specified byte offset and length from the start of the view. There is\n * no alignment constraint; multi-byte values may be fetched from any offset.\n *\n * Only supports Big-Endian, because that's what ADB uses.\n * @param byteOffset The place in the buffer at which the value should be retrieved.\n */\nexport function getBigUint(\n    array: Uint8Array,\n    byteOffset: number,\n    length: number,\n): bigint {\n    let result = 0n;\n\n    // Currently `length` must be a multiplication of 8\n    // Support for arbitrary length can be easily added\n\n    for (let i = byteOffset; i < byteOffset + length; i += 8) {\n        result <<= 64n;\n        const value = getUint64BigEndian(array, i);\n        result |= value;\n    }\n\n    return result;\n}\n\n/**\n * Stores an arbitrary-precision positive `BigInt` value at the specified byte offset from the start of the view.\n * @param byteOffset The place in the buffer at which the value should be set.\n * @param length The number of bytes to set.\n * @param value The value to set.\n * @param littleEndian If `false` or `undefined`, a big-endian value should be written,\n * otherwise a little-endian value should be written.\n */\nexport function setBigUint(\n    array: Uint8Array,\n    byteOffset: number,\n    length: number,\n    value: bigint,\n    littleEndian?: boolean,\n) {\n    if (littleEndian) {\n        while (value > 0n) {\n            setInt64LittleEndian(array, byteOffset, value);\n            byteOffset += 8;\n            value >>= 64n;\n        }\n    } else {\n        let position = byteOffset + length - 8;\n        while (value > 0n) {\n            setInt64BigEndian(array, position, value);\n            position -= 8;\n            value >>= 64n;\n        }\n    }\n}\n\n// These values are correct only if\n// modulus length is 2048 and\n// public exponent (e) is 65537\n// Anyway, that's how this library generates keys\n\n// To support other parameters,\n// a proper ASN.1 parser can be used\n\n// References:\n//\n//   https://tools.ietf.org/html/rfc8017#appendix-A.1.2\n//   PKCS #1: RSA Cryptography Specifications Version 2.2\n//     A.1.2.  RSA Private Key Syntax\n//\n//   https://lapo.it/asn1js/\n//   https://github.com/lapo-luchini/asn1js\n//   ASN.1 JavaScript decoder\n//\n//   https://www.itu.int/rec/T-REC-X.690-201508-I/en\n//   X.690: Specification of Distinguished Encoding Rules (DER)\n\nconst RsaPrivateKeyNOffset = 38;\nconst RsaPrivateKeyNLength = 2048 / 8;\nconst RsaPrivateKeyDOffset = 303;\nconst RsaPrivateKeyDLength = 2048 / 8;\n\nexport function rsaParsePrivateKey(key: Uint8Array): [n: bigint, d: bigint] {\n    const n = getBigUint(key, RsaPrivateKeyNOffset, RsaPrivateKeyNLength);\n    const d = getBigUint(key, RsaPrivateKeyDOffset, RsaPrivateKeyDLength);\n    return [n, d];\n}\n\nfunction nonNegativeMod(m: number, d: number) {\n    const r = m % d;\n    if (r > 0) {\n        return r;\n    }\n    return r + (d > 0 ? d : -d);\n}\n\n// https://en.wikipedia.org/wiki/Modular_multiplicative_inverse\n// Solve for the smallest positive `x` in the equation `a * x  1 (mod m)`,\n// or in other words, `a * x % m = 1`\n// Taken from https://stackoverflow.com/a/51562038\n// Only used with numbers smaller than 2^32 so doesn't need BigInt\nexport function modInverse(a: number, m: number) {\n    a = nonNegativeMod(a, m);\n    if (!a || m < 2) {\n        return NaN; // invalid input\n    }\n    // find the gcd\n    const s = [];\n    let b = m;\n    while (b) {\n        [a, b] = [b, a % b];\n        s.push({ a, b });\n    }\n    /* istanbul ignore next */\n    if (a !== 1) {\n        return NaN; // inverse does not exists\n    }\n    // find the inverse\n    let x = 1;\n    let y = 0;\n    for (let i = s.length - 2; i >= 0; i -= 1) {\n        [x, y] = [y, x - y * Math.floor(s[i]!.a / s[i]!.b)];\n    }\n    return nonNegativeMod(y, m);\n}\n\nconst ModulusLengthInBytes = 2048 / 8;\nconst ModulusLengthInWords = ModulusLengthInBytes / 4;\n\nexport function adbGetPublicKeySize() {\n    return 4 + 4 + ModulusLengthInBytes + ModulusLengthInBytes + 4;\n}\n\nexport function adbGeneratePublicKey(privateKey: Uint8Array): Uint8Array;\nexport function adbGeneratePublicKey(\n    privateKey: Uint8Array,\n    output: Uint8Array,\n): number;\nexport function adbGeneratePublicKey(\n    privateKey: Uint8Array,\n    output?: Uint8Array,\n): Uint8Array | number {\n    // cspell: ignore: mincrypt\n    // Android 6 and earlier has its own encryption library called mincrypt\n    // This is the RSA public key format used by mincrypt:\n    // https://android.googlesource.com/platform/system/core/+/bb0c180e62703c2068a1b2c9f8ba6d634bf1553c/include/mincrypt/rsa.h#46\n    // `n0inv` and `rr` are pre-calculated to speed up RSA operations\n\n    // Android 7 switched its encryption library to BoringSSL, but still keeps the key format:\n    // https://android.googlesource.com/platform/system/core.git/+/91784040db2b9273687f88d8b95f729d4a61ecc2/libcrypto_utils/android_pubkey.cpp#38\n    // Except when reading a key, `n0inv` and `rr` are ignored (they are still populated when generating a key):\n    // https://android.googlesource.com/platform/system/core.git/+/91784040db2b9273687f88d8b95f729d4a61ecc2/libcrypto_utils/android_pubkey.cpp#55\n\n    // The public key is a struct (in little endian) of:\n    //\n    // [\n    //   modulusLengthInWords, // 32-bit integer, a \"word\" is 32-bit so it must be 2048 / 8 / 4\n    //                         // (the comment in Android source code is incorrect saying \"This must be ANDROID_PUBKEY_MODULUS_SIZE\")\n    //   n0inv,                // 32-bit integer, the modular inverse of (lower 32 bits of `n`)\n    //   modulus,              // `n`\n    //   rr,                   // Montgomery parameter R^2\n    //   exponent,             // 32-bit integer, must be 3 or 65537\n    // ]\n\n    let outputType: \"Uint8Array\" | \"number\";\n    const outputLength = adbGetPublicKeySize();\n    if (!output) {\n        output = new Uint8Array(outputLength);\n        outputType = \"Uint8Array\";\n    } else {\n        if (output.length < outputLength) {\n            throw new TypeError(\"output buffer is too small\");\n        }\n\n        outputType = \"number\";\n    }\n\n    const outputView = new DataView(\n        output.buffer,\n        output.byteOffset,\n        output.length,\n    );\n    let outputOffset = 0;\n\n    // modulusLengthInWords\n    outputView.setUint32(outputOffset, ModulusLengthInWords, true);\n    outputOffset += 4;\n\n    // extract `n` from private key\n    const [n] = rsaParsePrivateKey(privateKey);\n\n    // Calculate `n0inv`\n    const n0inv = -modInverse(Number(n % 2n ** 32n), 2 ** 32);\n    outputView.setInt32(outputOffset, n0inv, true);\n    outputOffset += 4;\n\n    // Write `n` (a.k.a. `modulus`)\n    setBigUint(output, outputOffset, ModulusLengthInBytes, n, true);\n    outputOffset += ModulusLengthInBytes;\n\n    // Calculate rr = (2 ** (rsa_size)) ** 2 % n\n    const rr = 2n ** 4096n % n;\n    setBigUint(output, outputOffset, ModulusLengthInBytes, rr, true);\n    outputOffset += ModulusLengthInBytes;\n\n    // exponent\n    outputView.setUint32(outputOffset, 65537, true);\n    outputOffset += 4;\n\n    if (outputType === \"Uint8Array\") {\n        return output;\n    } else {\n        return outputLength;\n    }\n}\n\n/**\n * Modular exponentiation.\n *\n * Calculate `(base ** exponent) % modulus` without actually calculating `(base ** exponent)`.\n *\n * See https://en.wikipedia.org/wiki/Modular_exponentiation#Implementation_in_Lua\n */\nexport function powMod(\n    base: bigint,\n    exponent: bigint,\n    modulus: bigint,\n): bigint {\n    if (modulus === 1n) {\n        return 0n;\n    }\n\n    let r = 1n;\n    base = base % modulus;\n\n    while (exponent > 0n) {\n        if (BigInt.asUintN(1, exponent) === 1n) {\n            r = (r * base) % modulus;\n        }\n\n        base = (base * base) % modulus;\n        exponent >>= 1n;\n    }\n\n    return r;\n}\n\nexport const SHA1_DIGEST_LENGTH = 20;\n\nexport const ASN1_SEQUENCE = 0x30;\nexport const ASN1_OCTET_STRING = 0x04;\nexport const ASN1_NULL = 0x05;\nexport const ASN1_OID = 0x06;\n\n// PKCS#1 SHA-1 hash digest info\nexport const SHA1_DIGEST_INFO = new Uint8Array([\n    ASN1_SEQUENCE,\n    0x0d + SHA1_DIGEST_LENGTH,\n    ASN1_SEQUENCE,\n    0x09,\n    // SHA-1 (1 3 14 3 2 26)\n    ASN1_OID,\n    0x05,\n    1 * 40 + 3,\n    14,\n    3,\n    2,\n    26,\n    ASN1_NULL,\n    0x00,\n    ASN1_OCTET_STRING,\n    SHA1_DIGEST_LENGTH,\n]);\n\n// SubtleCrypto.sign() will hash the given data and sign the hash\n// But we don't need the hashing step\n// (In another word, ADB just requires the client to\n// encrypt the given data with its private key)\n// However SubtileCrypto.encrypt() doesn't accept 'RSASSA-PKCS1-v1_5' algorithm\n// So we need to implement the encryption by ourself\nexport function rsaSign(privateKey: Uint8Array, data: Uint8Array): Uint8Array {\n    const [n, d] = rsaParsePrivateKey(privateKey);\n\n    // PKCS#1 padding\n    const padded = new Uint8Array(256);\n    let index = 0;\n\n    padded[index] = 0;\n    index += 1;\n\n    padded[index] = 1;\n    index += 1;\n\n    const fillLength =\n        padded.length - SHA1_DIGEST_INFO.length - data.length - 1;\n    while (index < fillLength) {\n        padded[index] = 0xff;\n        index += 1;\n    }\n\n    padded[index] = 0;\n    index += 1;\n\n    padded.set(SHA1_DIGEST_INFO, index);\n    index += SHA1_DIGEST_INFO.length;\n\n    padded.set(data, index);\n\n    // Encryption\n    // signature = padded ** d % n\n    const signature = powMod(getBigUint(padded, 0, padded.length), d, n);\n\n    // `padded` is not used anymore,\n    // re-use the buffer to store the result\n    setBigUint(padded, 0, padded.length, signature, false);\n\n    return padded;\n}\n","import { Consumable, TransformStream } from \"@yume-chan/stream-extra\";\nimport Struct from \"@yume-chan/struct\";\nexport var AdbCommand;\n(function (AdbCommand) {\n    AdbCommand[AdbCommand[\"Auth\"] = 1213486401] = \"Auth\";\n    AdbCommand[AdbCommand[\"Close\"] = 1163086915] = \"Close\";\n    AdbCommand[AdbCommand[\"Connect\"] = 1314410051] = \"Connect\";\n    AdbCommand[AdbCommand[\"Okay\"] = 1497451343] = \"Okay\";\n    AdbCommand[AdbCommand[\"Open\"] = 1313165391] = \"Open\";\n    AdbCommand[AdbCommand[\"Write\"] = 1163154007] = \"Write\";\n})(AdbCommand || (AdbCommand = {}));\nexport const AdbPacketHeader = new Struct({ littleEndian: true })\n    .uint32(\"command\")\n    .uint32(\"arg0\")\n    .uint32(\"arg1\")\n    .uint32(\"payloadLength\")\n    .uint32(\"checksum\")\n    .int32(\"magic\");\nexport const AdbPacket = new Struct({ littleEndian: true })\n    .concat(AdbPacketHeader)\n    .uint8Array(\"payload\", { lengthField: \"payloadLength\" });\nexport function calculateChecksum(payload) {\n    return payload.reduce((result, item) => result + item, 0);\n}\nexport class AdbPacketSerializeStream extends TransformStream {\n    constructor() {\n        const headerBuffer = new Uint8Array(AdbPacketHeader.size);\n        super({\n            transform: async (chunk, controller) => {\n                await chunk.tryConsume(async (chunk) => {\n                    const init = chunk;\n                    init.payloadLength = init.payload.length;\n                    await Consumable.ReadableStream.enqueue(controller, AdbPacketHeader.serialize(init, headerBuffer));\n                    if (init.payloadLength) {\n                        // USB protocol preserves packet boundaries,\n                        // so we must write payload separately as native ADB does,\n                        // otherwise the read operation on device will fail.\n                        await Consumable.ReadableStream.enqueue(controller, init.payload);\n                    }\n                });\n            },\n        });\n    }\n}\n//# sourceMappingURL=packet.js.map","import { Consumable, TransformStream } from \"@yume-chan/stream-extra\";\nimport Struct from \"@yume-chan/struct\";\n\nexport enum AdbCommand {\n    Auth = 0x48545541, // 'AUTH'\n    Close = 0x45534c43, // 'CLSE'\n    Connect = 0x4e584e43, // 'CNXN'\n    Okay = 0x59414b4f, // 'OKAY'\n    Open = 0x4e45504f, // 'OPEN'\n    Write = 0x45545257, // 'WRTE'\n}\n\nexport const AdbPacketHeader = new Struct({ littleEndian: true })\n    .uint32(\"command\")\n    .uint32(\"arg0\")\n    .uint32(\"arg1\")\n    .uint32(\"payloadLength\")\n    .uint32(\"checksum\")\n    .int32(\"magic\");\n\nexport type AdbPacketHeader = (typeof AdbPacketHeader)[\"TDeserializeResult\"];\n\ntype AdbPacketHeaderInit = (typeof AdbPacketHeader)[\"TInit\"];\n\nexport const AdbPacket = new Struct({ littleEndian: true })\n    .concat(AdbPacketHeader)\n    .uint8Array(\"payload\", { lengthField: \"payloadLength\" });\n\nexport type AdbPacket = (typeof AdbPacket)[\"TDeserializeResult\"];\n\n/**\n * `AdbPacketData` contains all the useful fields of `AdbPacket`.\n *\n * `AdvDaemonConnection#connect` will return a `ReadableStream<AdbPacketData>`,\n * allow each connection to encode `AdbPacket` in different methods.\n *\n * `AdbDaemonConnection#connect` will return a `WritableStream<AdbPacketInit>`,\n * however, `AdbDaemonTransport` will transform `AdbPacketData` to `AdbPacketInit` for you,\n * so `AdbSocket#writable#write` only needs `AdbPacketData`.\n */\nexport type AdbPacketData = Omit<\n    (typeof AdbPacket)[\"TInit\"],\n    \"checksum\" | \"magic\"\n>;\n\nexport type AdbPacketInit = (typeof AdbPacket)[\"TInit\"];\n\nexport function calculateChecksum(payload: Uint8Array): number {\n    return payload.reduce((result, item) => result + item, 0);\n}\n\nexport class AdbPacketSerializeStream extends TransformStream<\n    Consumable<AdbPacketInit>,\n    Consumable<Uint8Array>\n> {\n    constructor() {\n        const headerBuffer = new Uint8Array(AdbPacketHeader.size);\n        super({\n            transform: async (chunk, controller) => {\n                await chunk.tryConsume(async (chunk) => {\n                    const init = chunk as AdbPacketInit & AdbPacketHeaderInit;\n                    init.payloadLength = init.payload.length;\n\n                    await Consumable.ReadableStream.enqueue(\n                        controller,\n                        AdbPacketHeader.serialize(init, headerBuffer),\n                    );\n\n                    if (init.payloadLength) {\n                        // USB protocol preserves packet boundaries,\n                        // so we must write payload separately as native ADB does,\n                        // otherwise the read operation on device will fail.\n                        await Consumable.ReadableStream.enqueue(\n                            controller,\n                            init.payload,\n                        );\n                    }\n                });\n            },\n        });\n    }\n}\n","import type { Consumable, ReadableWritablePair } from \"@yume-chan/stream-extra\";\nimport type { ValueOrPromise } from \"@yume-chan/struct\";\n\nimport type { AdbPacketData, AdbPacketInit } from \"./packet.js\";\n\nexport interface AdbDaemonDevice {\n    readonly serial: string;\n\n    readonly name: string | undefined;\n\n    connect(): ValueOrPromise<\n        ReadableWritablePair<AdbPacketData, Consumable<AdbPacketInit>>\n    >;\n}\n","import { AsyncOperationManager, PromiseResolver, delay, } from \"@yume-chan/async\";\nimport { getUint32LittleEndian, setUint32LittleEndian, } from \"@yume-chan/no-data-view\";\nimport { AbortController, Consumable, WritableStream, } from \"@yume-chan/stream-extra\";\nimport { EMPTY_UINT8_ARRAY, decodeUtf8, encodeUtf8 } from \"@yume-chan/struct\";\nimport { AdbCommand, calculateChecksum } from \"./packet.js\";\nimport { AdbDaemonSocketController } from \"./socket.js\";\n/**\n * The dispatcher is the \"dumb\" part of the connection handling logic.\n *\n * Except some options to change some minor behaviors,\n * its only job is forwarding packets between authenticated underlying streams\n * and abstracted socket objects.\n *\n * The `Adb` class is responsible for doing the authentication,\n * negotiating the options, and has shortcuts to high-level services.\n */\nexport class AdbPacketDispatcher {\n    // ADB socket id starts from 1\n    // (0 means open failed)\n    #initializers = new AsyncOperationManager(1);\n    /**\n     * Socket local ID to the socket controller.\n     */\n    #sockets = new Map();\n    #writer;\n    options;\n    #closed = false;\n    #disconnected = new PromiseResolver();\n    get disconnected() {\n        return this.#disconnected.promise;\n    }\n    #incomingSocketHandlers = new Map();\n    #readAbortController = new AbortController();\n    constructor(connection, options) {\n        this.options = options;\n        // Don't allow negative values in dispatcher\n        if (this.options.initialDelayedAckBytes < 0) {\n            this.options.initialDelayedAckBytes = 0;\n        }\n        connection.readable\n            .pipeTo(new WritableStream({\n            write: async (packet) => {\n                switch (packet.command) {\n                    case AdbCommand.Close:\n                        await this.#handleClose(packet);\n                        break;\n                    case AdbCommand.Okay:\n                        this.#handleOkay(packet);\n                        break;\n                    case AdbCommand.Open:\n                        await this.#handleOpen(packet);\n                        break;\n                    case AdbCommand.Write:\n                        await this.#handleWrite(packet);\n                        break;\n                    default:\n                        // Junk data may only appear in the authentication phase,\n                        // since the dispatcher only works after authentication,\n                        // all packets should have a valid command.\n                        // (although it's possible that Adb added new commands in the future)\n                        throw new Error(`Unknown command: ${packet.command.toString(16)}`);\n                }\n            },\n        }), {\n            preventCancel: options.preserveConnection ?? false,\n            signal: this.#readAbortController.signal,\n        })\n            .then(() => {\n            this.#dispose();\n        }, (e) => {\n            if (!this.#closed) {\n                this.#disconnected.reject(e);\n            }\n            this.#dispose();\n        });\n        this.#writer = connection.writable.getWriter();\n    }\n    async #handleClose(packet) {\n        // If the socket is still pending\n        if (packet.arg0 === 0 &&\n            this.#initializers.reject(packet.arg1, new Error(\"Socket open failed\"))) {\n            // Device failed to create the socket\n            // (unknown service string, failed to execute command, etc.)\n            // it doesn't break the connection,\n            // so only reject the socket creation promise,\n            // don't throw an error here.\n            return;\n        }\n        // From https://android.googlesource.com/platform/packages/modules/adb/+/65d18e2c1cc48b585811954892311b28a4c3d188/adb.cpp#459\n        /* According to protocol.txt, p->msg.arg0 might be 0 to indicate\n         * a failed OPEN only. However, due to a bug in previous ADB\n         * versions, CLOSE(0, remote-id, \"\") was also used for normal\n         * CLOSE() operations.\n         */\n        // Ignore `arg0` and search for the socket\n        const socket = this.#sockets.get(packet.arg1);\n        if (socket) {\n            await socket.close();\n            socket.dispose();\n            this.#sockets.delete(packet.arg1);\n            return;\n        }\n        // TODO: adb: is double closing an socket a catastrophic error?\n        // If the client sends two `CLSE` packets for one socket,\n        // the device may also respond with two `CLSE` packets.\n    }\n    #handleOkay(packet) {\n        let ackBytes;\n        if (this.options.initialDelayedAckBytes !== 0) {\n            if (packet.payload.length !== 4) {\n                throw new Error(\"Invalid OKAY packet. Payload size should be 4\");\n            }\n            ackBytes = getUint32LittleEndian(packet.payload, 0);\n        }\n        else {\n            if (packet.payload.length !== 0) {\n                throw new Error(\"Invalid OKAY packet. Payload size should be 0\");\n            }\n            ackBytes = Infinity;\n        }\n        if (this.#initializers.resolve(packet.arg1, {\n            remoteId: packet.arg0,\n            availableWriteBytes: ackBytes,\n        })) {\n            // Device successfully created the socket\n            return;\n        }\n        const socket = this.#sockets.get(packet.arg1);\n        if (socket) {\n            // When delayed ack is enabled, `ackBytes` is a positive number represents\n            // how many bytes the device has received from this socket.\n            // When delayed ack is disabled, `ackBytes` is always `Infinity` represents\n            // the device has received last `WRTE` packet from the socket.\n            socket.ack(ackBytes);\n            return;\n        }\n        // Maybe the device is responding to a packet of last connection\n        // Tell the device to close the socket\n        void this.sendPacket(AdbCommand.Close, packet.arg1, packet.arg0, EMPTY_UINT8_ARRAY);\n    }\n    #sendOkay(localId, remoteId, ackBytes) {\n        let payload;\n        if (this.options.initialDelayedAckBytes !== 0) {\n            // TODO: try reusing this buffer to reduce memory allocation\n            // However, that requires blocking reentrance of `sendOkay`, which might be more expensive\n            payload = new Uint8Array(4);\n            setUint32LittleEndian(payload, 0, ackBytes);\n        }\n        else {\n            payload = EMPTY_UINT8_ARRAY;\n        }\n        return this.sendPacket(AdbCommand.Okay, localId, remoteId, payload);\n    }\n    async #handleOpen(packet) {\n        // Allocate a local ID for the socket from `#initializers`.\n        // `AsyncOperationManager` doesn't directly support returning the next ID,\n        // so use `add` + `resolve` to simulate this\n        const [localId] = this.#initializers.add();\n        this.#initializers.resolve(localId, undefined);\n        const remoteId = packet.arg0;\n        let availableWriteBytes = packet.arg1;\n        let service = decodeUtf8(packet.payload);\n        // ADB Daemon still adds a null character to the service string\n        if (service.endsWith(\"\\0\")) {\n            service = service.substring(0, service.length - 1);\n        }\n        // Check remote delayed ack enablement is consistent with local\n        if (this.options.initialDelayedAckBytes === 0) {\n            if (availableWriteBytes !== 0) {\n                throw new Error(\"Invalid OPEN packet. arg1 should be 0\");\n            }\n            availableWriteBytes = Infinity;\n        }\n        else {\n            if (availableWriteBytes === 0) {\n                throw new Error(\"Invalid OPEN packet. arg1 should be greater than 0\");\n            }\n        }\n        const handler = this.#incomingSocketHandlers.get(service);\n        if (!handler) {\n            await this.sendPacket(AdbCommand.Close, 0, remoteId, EMPTY_UINT8_ARRAY);\n            return;\n        }\n        const controller = new AdbDaemonSocketController({\n            dispatcher: this,\n            localId,\n            remoteId,\n            localCreated: false,\n            service,\n            availableWriteBytes,\n        });\n        try {\n            await handler(controller.socket);\n            this.#sockets.set(localId, controller);\n            await this.#sendOkay(localId, remoteId, this.options.initialDelayedAckBytes);\n        }\n        catch (e) {\n            await this.sendPacket(AdbCommand.Close, 0, remoteId, EMPTY_UINT8_ARRAY);\n        }\n    }\n    async #handleWrite(packet) {\n        const socket = this.#sockets.get(packet.arg1);\n        if (!socket) {\n            throw new Error(`Unknown local socket id: ${packet.arg1}`);\n        }\n        let handled = false;\n        const promises = [\n            (async () => {\n                await socket.enqueue(packet.payload);\n                await this.#sendOkay(packet.arg1, packet.arg0, packet.payload.length);\n                handled = true;\n            })(),\n        ];\n        if (this.options.readTimeLimit) {\n            promises.push((async () => {\n                await delay(this.options.readTimeLimit);\n                if (!handled) {\n                    throw new Error(`readable of \\`${socket.service}\\` has stalled for ${this.options.readTimeLimit} milliseconds`);\n                }\n            })());\n        }\n        await Promise.race(promises);\n    }\n    async createSocket(service) {\n        if (this.options.appendNullToServiceString) {\n            service += \"\\0\";\n        }\n        const [localId, initializer] = this.#initializers.add();\n        await this.sendPacket(AdbCommand.Open, localId, this.options.initialDelayedAckBytes, service);\n        // Fulfilled by `handleOkay`\n        const { remoteId, availableWriteBytes } = await initializer;\n        const controller = new AdbDaemonSocketController({\n            dispatcher: this,\n            localId,\n            remoteId,\n            localCreated: true,\n            service,\n            availableWriteBytes,\n        });\n        this.#sockets.set(localId, controller);\n        return controller.socket;\n    }\n    addReverseTunnel(service, handler) {\n        this.#incomingSocketHandlers.set(service, handler);\n    }\n    removeReverseTunnel(address) {\n        this.#incomingSocketHandlers.delete(address);\n    }\n    clearReverseTunnels() {\n        this.#incomingSocketHandlers.clear();\n    }\n    async sendPacket(command, arg0, arg1, \n    // PERF: It's slightly faster to not use default parameter values\n    payload) {\n        if (typeof payload === \"string\") {\n            payload = encodeUtf8(payload);\n        }\n        if (payload.length > this.options.maxPayloadSize) {\n            throw new TypeError(\"payload too large\");\n        }\n        await Consumable.WritableStream.write(this.#writer, {\n            command,\n            arg0,\n            arg1,\n            payload,\n            checksum: this.options.calculateChecksum\n                ? calculateChecksum(payload)\n                : 0,\n            magic: command ^ 0xffffffff,\n        });\n    }\n    async close() {\n        // Send `CLSE` packets for all sockets\n        await Promise.all(Array.from(this.#sockets.values(), (socket) => socket.close()));\n        // Stop receiving\n        // It's possible that we haven't received all `CLSE` confirm packets,\n        // but it doesn't matter, the next connection can cope with them.\n        this.#closed = true;\n        this.#readAbortController.abort();\n        if (this.options.preserveConnection) {\n            this.#writer.releaseLock();\n        }\n        else {\n            await this.#writer.close();\n        }\n        // `pipe().then()` will call `dispose`\n    }\n    #dispose() {\n        for (const socket of this.#sockets.values()) {\n            socket.dispose();\n        }\n        this.#disconnected.resolve();\n    }\n}\n//# sourceMappingURL=dispatcher.js.map","import {\n    AsyncOperationManager,\n    PromiseResolver,\n    delay,\n} from \"@yume-chan/async\";\nimport {\n    getUint32LittleEndian,\n    setUint32LittleEndian,\n} from \"@yume-chan/no-data-view\";\nimport type {\n    ReadableWritablePair,\n    WritableStreamDefaultWriter,\n} from \"@yume-chan/stream-extra\";\nimport {\n    AbortController,\n    Consumable,\n    WritableStream,\n} from \"@yume-chan/stream-extra\";\nimport { EMPTY_UINT8_ARRAY, decodeUtf8, encodeUtf8 } from \"@yume-chan/struct\";\n\nimport type { AdbIncomingSocketHandler, AdbSocket, Closeable } from \"../adb.js\";\n\nimport type { AdbPacketData, AdbPacketInit } from \"./packet.js\";\nimport { AdbCommand, calculateChecksum } from \"./packet.js\";\nimport { AdbDaemonSocketController } from \"./socket.js\";\n\nexport interface AdbPacketDispatcherOptions {\n    /**\n     * From Android 9.0, ADB stopped checking the checksum in packet header to improve performance.\n     *\n     * The value should be inferred from the device's ADB protocol version.\n     */\n    calculateChecksum: boolean;\n\n    /**\n     * Before Android 9.0, ADB uses `char*` to parse service strings,\n     * thus requires a null character to terminate.\n     *\n     * The value should be inferred from the device's ADB protocol version.\n     * Usually it should have the same value as `calculateChecksum`, since they both changed\n     * in Android 9.0.\n     */\n    appendNullToServiceString: boolean;\n\n    maxPayloadSize: number;\n\n    /**\n     * Whether to keep the `connection` open (don't call `writable.close` and `readable.cancel`)\n     * when `AdbPacketDispatcher.close` is called.\n     *\n     * @default false\n     */\n    preserveConnection?: boolean | undefined;\n\n    /**\n     * The number of bytes the device can send before receiving an ack packet.\n     * Using delayed ack can improve the throughput,\n     * especially when the device is connected over Wi-Fi (so the latency is higher).\n     *\n     * This must be the negotiated value between the client and device. If the device enabled\n     * delayed ack but the client didn't, the device will throw an error when the client sends\n     * the first `WRTE` packet. And vice versa.\n     */\n    initialDelayedAckBytes: number;\n\n    /**\n     * When set, the dispatcher will throw an error when\n     * one of the socket readable stalls for this amount of milliseconds.\n     *\n     * Because ADB is a multiplexed protocol, blocking one socket will also block all other sockets.\n     * It's important to always read from all sockets to prevent stalling.\n     *\n     * This option is helpful to detect bugs in the client code.\n     *\n     * @default false\n     */\n    readTimeLimit?: number | undefined;\n}\n\ninterface SocketOpenResult {\n    remoteId: number;\n    availableWriteBytes: number;\n}\n\n/**\n * The dispatcher is the \"dumb\" part of the connection handling logic.\n *\n * Except some options to change some minor behaviors,\n * its only job is forwarding packets between authenticated underlying streams\n * and abstracted socket objects.\n *\n * The `Adb` class is responsible for doing the authentication,\n * negotiating the options, and has shortcuts to high-level services.\n */\nexport class AdbPacketDispatcher implements Closeable {\n    // ADB socket id starts from 1\n    // (0 means open failed)\n    readonly #initializers = new AsyncOperationManager(1);\n    /**\n     * Socket local ID to the socket controller.\n     */\n    readonly #sockets = new Map<number, AdbDaemonSocketController>();\n\n    #writer: WritableStreamDefaultWriter<Consumable<AdbPacketInit>>;\n\n    readonly options: AdbPacketDispatcherOptions;\n\n    #closed = false;\n    #disconnected = new PromiseResolver<void>();\n    get disconnected() {\n        return this.#disconnected.promise;\n    }\n\n    #incomingSocketHandlers = new Map<string, AdbIncomingSocketHandler>();\n    #readAbortController = new AbortController();\n\n    constructor(\n        connection: ReadableWritablePair<\n            AdbPacketData,\n            Consumable<AdbPacketInit>\n        >,\n        options: AdbPacketDispatcherOptions,\n    ) {\n        this.options = options;\n        // Don't allow negative values in dispatcher\n        if (this.options.initialDelayedAckBytes < 0) {\n            this.options.initialDelayedAckBytes = 0;\n        }\n\n        connection.readable\n            .pipeTo(\n                new WritableStream({\n                    write: async (packet) => {\n                        switch (packet.command) {\n                            case AdbCommand.Close:\n                                await this.#handleClose(packet);\n                                break;\n                            case AdbCommand.Okay:\n                                this.#handleOkay(packet);\n                                break;\n                            case AdbCommand.Open:\n                                await this.#handleOpen(packet);\n                                break;\n                            case AdbCommand.Write:\n                                await this.#handleWrite(packet);\n                                break;\n                            default:\n                                // Junk data may only appear in the authentication phase,\n                                // since the dispatcher only works after authentication,\n                                // all packets should have a valid command.\n                                // (although it's possible that Adb added new commands in the future)\n                                throw new Error(\n                                    `Unknown command: ${packet.command.toString(\n                                        16,\n                                    )}`,\n                                );\n                        }\n                    },\n                }),\n                {\n                    preventCancel: options.preserveConnection ?? false,\n                    signal: this.#readAbortController.signal,\n                },\n            )\n            .then(\n                () => {\n                    this.#dispose();\n                },\n                (e) => {\n                    if (!this.#closed) {\n                        this.#disconnected.reject(e);\n                    }\n                    this.#dispose();\n                },\n            );\n\n        this.#writer = connection.writable.getWriter();\n    }\n\n    async #handleClose(packet: AdbPacketData) {\n        // If the socket is still pending\n        if (\n            packet.arg0 === 0 &&\n            this.#initializers.reject(\n                packet.arg1,\n                new Error(\"Socket open failed\"),\n            )\n        ) {\n            // Device failed to create the socket\n            // (unknown service string, failed to execute command, etc.)\n            // it doesn't break the connection,\n            // so only reject the socket creation promise,\n            // don't throw an error here.\n            return;\n        }\n\n        // From https://android.googlesource.com/platform/packages/modules/adb/+/65d18e2c1cc48b585811954892311b28a4c3d188/adb.cpp#459\n        /* According to protocol.txt, p->msg.arg0 might be 0 to indicate\n         * a failed OPEN only. However, due to a bug in previous ADB\n         * versions, CLOSE(0, remote-id, \"\") was also used for normal\n         * CLOSE() operations.\n         */\n\n        // Ignore `arg0` and search for the socket\n        const socket = this.#sockets.get(packet.arg1);\n        if (socket) {\n            await socket.close();\n            socket.dispose();\n            this.#sockets.delete(packet.arg1);\n            return;\n        }\n\n        // TODO: adb: is double closing an socket a catastrophic error?\n        // If the client sends two `CLSE` packets for one socket,\n        // the device may also respond with two `CLSE` packets.\n    }\n\n    #handleOkay(packet: AdbPacketData) {\n        let ackBytes: number;\n        if (this.options.initialDelayedAckBytes !== 0) {\n            if (packet.payload.length !== 4) {\n                throw new Error(\n                    \"Invalid OKAY packet. Payload size should be 4\",\n                );\n            }\n            ackBytes = getUint32LittleEndian(packet.payload, 0);\n        } else {\n            if (packet.payload.length !== 0) {\n                throw new Error(\n                    \"Invalid OKAY packet. Payload size should be 0\",\n                );\n            }\n            ackBytes = Infinity;\n        }\n\n        if (\n            this.#initializers.resolve(packet.arg1, {\n                remoteId: packet.arg0,\n                availableWriteBytes: ackBytes,\n            } satisfies SocketOpenResult)\n        ) {\n            // Device successfully created the socket\n            return;\n        }\n\n        const socket = this.#sockets.get(packet.arg1);\n        if (socket) {\n            // When delayed ack is enabled, `ackBytes` is a positive number represents\n            // how many bytes the device has received from this socket.\n            // When delayed ack is disabled, `ackBytes` is always `Infinity` represents\n            // the device has received last `WRTE` packet from the socket.\n            socket.ack(ackBytes);\n            return;\n        }\n\n        // Maybe the device is responding to a packet of last connection\n        // Tell the device to close the socket\n        void this.sendPacket(\n            AdbCommand.Close,\n            packet.arg1,\n            packet.arg0,\n            EMPTY_UINT8_ARRAY,\n        );\n    }\n\n    #sendOkay(localId: number, remoteId: number, ackBytes: number) {\n        let payload: Uint8Array;\n        if (this.options.initialDelayedAckBytes !== 0) {\n            // TODO: try reusing this buffer to reduce memory allocation\n            // However, that requires blocking reentrance of `sendOkay`, which might be more expensive\n            payload = new Uint8Array(4);\n            setUint32LittleEndian(payload, 0, ackBytes);\n        } else {\n            payload = EMPTY_UINT8_ARRAY;\n        }\n\n        return this.sendPacket(AdbCommand.Okay, localId, remoteId, payload);\n    }\n\n    async #handleOpen(packet: AdbPacketData) {\n        // Allocate a local ID for the socket from `#initializers`.\n        // `AsyncOperationManager` doesn't directly support returning the next ID,\n        // so use `add` + `resolve` to simulate this\n        const [localId] = this.#initializers.add<number>();\n        this.#initializers.resolve(localId, undefined);\n\n        const remoteId = packet.arg0;\n        let availableWriteBytes = packet.arg1;\n        let service = decodeUtf8(packet.payload);\n        // ADB Daemon still adds a null character to the service string\n        if (service.endsWith(\"\\0\")) {\n            service = service.substring(0, service.length - 1);\n        }\n\n        // Check remote delayed ack enablement is consistent with local\n        if (this.options.initialDelayedAckBytes === 0) {\n            if (availableWriteBytes !== 0) {\n                throw new Error(\"Invalid OPEN packet. arg1 should be 0\");\n            }\n            availableWriteBytes = Infinity;\n        } else {\n            if (availableWriteBytes === 0) {\n                throw new Error(\n                    \"Invalid OPEN packet. arg1 should be greater than 0\",\n                );\n            }\n        }\n\n        const handler = this.#incomingSocketHandlers.get(service);\n        if (!handler) {\n            await this.sendPacket(\n                AdbCommand.Close,\n                0,\n                remoteId,\n                EMPTY_UINT8_ARRAY,\n            );\n            return;\n        }\n\n        const controller = new AdbDaemonSocketController({\n            dispatcher: this,\n            localId,\n            remoteId,\n            localCreated: false,\n            service,\n            availableWriteBytes,\n        });\n\n        try {\n            await handler(controller.socket);\n            this.#sockets.set(localId, controller);\n            await this.#sendOkay(\n                localId,\n                remoteId,\n                this.options.initialDelayedAckBytes,\n            );\n        } catch (e) {\n            await this.sendPacket(\n                AdbCommand.Close,\n                0,\n                remoteId,\n                EMPTY_UINT8_ARRAY,\n            );\n        }\n    }\n\n    async #handleWrite(packet: AdbPacketData) {\n        const socket = this.#sockets.get(packet.arg1);\n        if (!socket) {\n            throw new Error(`Unknown local socket id: ${packet.arg1}`);\n        }\n\n        let handled = false;\n\n        const promises: Promise<void>[] = [\n            (async () => {\n                await socket.enqueue(packet.payload);\n                await this.#sendOkay(\n                    packet.arg1,\n                    packet.arg0,\n                    packet.payload.length,\n                );\n                handled = true;\n            })(),\n        ];\n\n        if (this.options.readTimeLimit) {\n            promises.push(\n                (async () => {\n                    await delay(this.options.readTimeLimit!);\n                    if (!handled) {\n                        throw new Error(\n                            `readable of \\`${socket.service}\\` has stalled for ${this.options.readTimeLimit} milliseconds`,\n                        );\n                    }\n                })(),\n            );\n        }\n\n        await Promise.race(promises);\n    }\n\n    async createSocket(service: string): Promise<AdbSocket> {\n        if (this.options.appendNullToServiceString) {\n            service += \"\\0\";\n        }\n\n        const [localId, initializer] =\n            this.#initializers.add<SocketOpenResult>();\n        await this.sendPacket(\n            AdbCommand.Open,\n            localId,\n            this.options.initialDelayedAckBytes,\n            service,\n        );\n\n        // Fulfilled by `handleOkay`\n        const { remoteId, availableWriteBytes } = await initializer;\n        const controller = new AdbDaemonSocketController({\n            dispatcher: this,\n            localId,\n            remoteId,\n            localCreated: true,\n            service,\n            availableWriteBytes,\n        });\n        this.#sockets.set(localId, controller);\n\n        return controller.socket;\n    }\n\n    addReverseTunnel(service: string, handler: AdbIncomingSocketHandler) {\n        this.#incomingSocketHandlers.set(service, handler);\n    }\n\n    removeReverseTunnel(address: string) {\n        this.#incomingSocketHandlers.delete(address);\n    }\n\n    clearReverseTunnels() {\n        this.#incomingSocketHandlers.clear();\n    }\n\n    async sendPacket(\n        command: AdbCommand,\n        arg0: number,\n        arg1: number,\n        // PERF: It's slightly faster to not use default parameter values\n        payload: string | Uint8Array,\n    ): Promise<void> {\n        if (typeof payload === \"string\") {\n            payload = encodeUtf8(payload);\n        }\n\n        if (payload.length > this.options.maxPayloadSize) {\n            throw new TypeError(\"payload too large\");\n        }\n\n        await Consumable.WritableStream.write(this.#writer, {\n            command,\n            arg0,\n            arg1,\n            payload,\n            checksum: this.options.calculateChecksum\n                ? calculateChecksum(payload)\n                : 0,\n            magic: command ^ 0xffffffff,\n        });\n    }\n\n    async close() {\n        // Send `CLSE` packets for all sockets\n        await Promise.all(\n            Array.from(this.#sockets.values(), (socket) => socket.close()),\n        );\n\n        // Stop receiving\n        // It's possible that we haven't received all `CLSE` confirm packets,\n        // but it doesn't matter, the next connection can cope with them.\n        this.#closed = true;\n\n        this.#readAbortController.abort();\n        if (this.options.preserveConnection) {\n            this.#writer.releaseLock();\n        } else {\n            await this.#writer.close();\n        }\n\n        // `pipe().then()` will call `dispose`\n    }\n\n    #dispose() {\n        for (const socket of this.#sockets.values()) {\n            socket.dispose();\n        }\n\n        this.#disconnected.resolve();\n    }\n}\n","import { PromiseResolver } from \"@yume-chan/async\";\nimport { MaybeConsumable, PushReadableStream } from \"@yume-chan/stream-extra\";\nimport { EMPTY_UINT8_ARRAY } from \"@yume-chan/struct\";\nimport { AdbCommand } from \"./packet.js\";\nexport class AdbDaemonSocketController {\n    #dispatcher;\n    localId;\n    remoteId;\n    localCreated;\n    service;\n    #readable;\n    #readableController;\n    get readable() {\n        return this.#readable;\n    }\n    #writableController;\n    writable;\n    #closed = false;\n    #closedPromise = new PromiseResolver();\n    get closed() {\n        return this.#closedPromise.promise;\n    }\n    #socket;\n    get socket() {\n        return this.#socket;\n    }\n    #availableWriteBytesChanged;\n    /**\n     * When delayed ack is disabled, returns `Infinity` if the socket is ready to write\n     * (exactly one packet can be written no matter how large it is), or `-1` if the socket\n     * is waiting for ack message.\n     *\n     * When delayed ack is enabled, returns a non-negative finite number indicates the number of\n     * bytes that can be written to the socket before waiting for ack message.\n     */\n    #availableWriteBytes = 0;\n    constructor(options) {\n        this.#dispatcher = options.dispatcher;\n        this.localId = options.localId;\n        this.remoteId = options.remoteId;\n        this.localCreated = options.localCreated;\n        this.service = options.service;\n        this.#readable = new PushReadableStream((controller) => {\n            this.#readableController = controller;\n        });\n        this.writable = new MaybeConsumable.WritableStream({\n            start: (controller) => {\n                this.#writableController = controller;\n                controller.signal.addEventListener(\"abort\", () => {\n                    this.#availableWriteBytesChanged?.reject(controller.signal.reason);\n                });\n            },\n            write: async (data) => {\n                const size = data.length;\n                const chunkSize = this.#dispatcher.options.maxPayloadSize;\n                for (let start = 0, end = chunkSize; start < size; start = end, end += chunkSize) {\n                    const chunk = data.subarray(start, end);\n                    await this.#writeChunk(chunk);\n                }\n            },\n        });\n        this.#socket = new AdbDaemonSocket(this);\n        this.#availableWriteBytes = options.availableWriteBytes;\n    }\n    async #writeChunk(data) {\n        const length = data.length;\n        while (this.#availableWriteBytes < length) {\n            // Only one lock is required because Web Streams API guarantees\n            // that `write` is not reentrant.\n            const resolver = new PromiseResolver();\n            this.#availableWriteBytesChanged = resolver;\n            await resolver.promise;\n        }\n        if (this.#availableWriteBytes === Infinity) {\n            this.#availableWriteBytes = -1;\n        }\n        else {\n            this.#availableWriteBytes -= length;\n        }\n        await this.#dispatcher.sendPacket(AdbCommand.Write, this.localId, this.remoteId, data);\n    }\n    async enqueue(data) {\n        // Consumers can `cancel` the `readable` if they are not interested in future data.\n        // Throw away the data if that happens.\n        if (this.#readableController.abortSignal.aborted) {\n            return;\n        }\n        try {\n            await this.#readableController.enqueue(data);\n        }\n        catch (e) {\n            if (this.#readableController.abortSignal.aborted) {\n                return;\n            }\n            throw e;\n        }\n    }\n    ack(bytes) {\n        this.#availableWriteBytes += bytes;\n        this.#availableWriteBytesChanged?.resolve();\n    }\n    async close() {\n        if (this.#closed) {\n            return;\n        }\n        this.#closed = true;\n        this.#availableWriteBytesChanged?.reject(new Error(\"Socket closed\"));\n        try {\n            this.#writableController.error(new Error(\"Socket closed\"));\n        }\n        catch {\n            // ignore\n        }\n        await this.#dispatcher.sendPacket(AdbCommand.Close, this.localId, this.remoteId, EMPTY_UINT8_ARRAY);\n    }\n    dispose() {\n        try {\n            this.#readableController.close();\n        }\n        catch {\n            // ignore\n        }\n        this.#closedPromise.resolve();\n    }\n}\n/**\n * A duplex stream representing a socket to ADB daemon.\n *\n * To close it, call either `socket.close()`,\n * `socket.readable.cancel()`, `socket.readable.getReader().cancel()`,\n * `socket.writable.abort()`, `socket.writable.getWriter().abort()`,\n * `socket.writable.close()` or `socket.writable.getWriter().close()`.\n */\nexport class AdbDaemonSocket {\n    #controller;\n    get localId() {\n        return this.#controller.localId;\n    }\n    get remoteId() {\n        return this.#controller.remoteId;\n    }\n    get localCreated() {\n        return this.#controller.localCreated;\n    }\n    get service() {\n        return this.#controller.service;\n    }\n    get readable() {\n        return this.#controller.readable;\n    }\n    get writable() {\n        return this.#controller.writable;\n    }\n    get closed() {\n        return this.#controller.closed;\n    }\n    constructor(controller) {\n        this.#controller = controller;\n    }\n    close() {\n        return this.#controller.close();\n    }\n}\n//# sourceMappingURL=socket.js.map","import { PromiseResolver } from \"@yume-chan/async\";\nimport type { Disposable } from \"@yume-chan/event\";\nimport type {\n    PushReadableStreamController,\n    ReadableStream,\n    WritableStream,\n    WritableStreamDefaultController,\n} from \"@yume-chan/stream-extra\";\nimport { MaybeConsumable, PushReadableStream } from \"@yume-chan/stream-extra\";\nimport { EMPTY_UINT8_ARRAY } from \"@yume-chan/struct\";\n\nimport type { AdbSocket } from \"../adb.js\";\n\nimport type { AdbPacketDispatcher } from \"./dispatcher.js\";\nimport { AdbCommand } from \"./packet.js\";\n\nexport interface AdbDaemonSocketInfo {\n    localId: number;\n    remoteId: number;\n\n    localCreated: boolean;\n    service: string;\n}\n\nexport interface AdbDaemonSocketInit extends AdbDaemonSocketInfo {\n    dispatcher: AdbPacketDispatcher;\n\n    highWaterMark?: number | undefined;\n\n    /**\n     * The initial delayed ack byte count, or `Infinity` if delayed ack is disabled.\n     */\n    availableWriteBytes: number;\n}\n\nexport class AdbDaemonSocketController\n    implements AdbDaemonSocketInfo, AdbSocket, Disposable\n{\n    readonly #dispatcher!: AdbPacketDispatcher;\n\n    readonly localId!: number;\n    readonly remoteId!: number;\n    readonly localCreated!: boolean;\n    readonly service!: string;\n\n    #readable: ReadableStream<Uint8Array>;\n    #readableController!: PushReadableStreamController<Uint8Array>;\n    get readable() {\n        return this.#readable;\n    }\n\n    #writableController!: WritableStreamDefaultController;\n    readonly writable: WritableStream<MaybeConsumable<Uint8Array>>;\n\n    #closed = false;\n\n    #closedPromise = new PromiseResolver<void>();\n    get closed() {\n        return this.#closedPromise.promise;\n    }\n\n    #socket: AdbDaemonSocket;\n    get socket() {\n        return this.#socket;\n    }\n\n    #availableWriteBytesChanged: PromiseResolver<void> | undefined;\n    /**\n     * When delayed ack is disabled, returns `Infinity` if the socket is ready to write\n     * (exactly one packet can be written no matter how large it is), or `-1` if the socket\n     * is waiting for ack message.\n     *\n     * When delayed ack is enabled, returns a non-negative finite number indicates the number of\n     * bytes that can be written to the socket before waiting for ack message.\n     */\n    #availableWriteBytes = 0;\n\n    constructor(options: AdbDaemonSocketInit) {\n        this.#dispatcher = options.dispatcher;\n        this.localId = options.localId;\n        this.remoteId = options.remoteId;\n        this.localCreated = options.localCreated;\n        this.service = options.service;\n\n        this.#readable = new PushReadableStream((controller) => {\n            this.#readableController = controller;\n        });\n\n        this.writable = new MaybeConsumable.WritableStream<Uint8Array>({\n            start: (controller) => {\n                this.#writableController = controller;\n                controller.signal.addEventListener(\"abort\", () => {\n                    this.#availableWriteBytesChanged?.reject(\n                        controller.signal.reason,\n                    );\n                });\n            },\n            write: async (data) => {\n                const size = data.length;\n                const chunkSize = this.#dispatcher.options.maxPayloadSize;\n                for (\n                    let start = 0, end = chunkSize;\n                    start < size;\n                    start = end, end += chunkSize\n                ) {\n                    const chunk = data.subarray(start, end);\n                    await this.#writeChunk(chunk);\n                }\n            },\n        });\n\n        this.#socket = new AdbDaemonSocket(this);\n        this.#availableWriteBytes = options.availableWriteBytes;\n    }\n\n    async #writeChunk(data: Uint8Array) {\n        const length = data.length;\n        while (this.#availableWriteBytes < length) {\n            // Only one lock is required because Web Streams API guarantees\n            // that `write` is not reentrant.\n            const resolver = new PromiseResolver<void>();\n            this.#availableWriteBytesChanged = resolver;\n            await resolver.promise;\n        }\n\n        if (this.#availableWriteBytes === Infinity) {\n            this.#availableWriteBytes = -1;\n        } else {\n            this.#availableWriteBytes -= length;\n        }\n\n        await this.#dispatcher.sendPacket(\n            AdbCommand.Write,\n            this.localId,\n            this.remoteId,\n            data,\n        );\n    }\n\n    async enqueue(data: Uint8Array) {\n        // Consumers can `cancel` the `readable` if they are not interested in future data.\n        // Throw away the data if that happens.\n        if (this.#readableController.abortSignal.aborted) {\n            return;\n        }\n\n        try {\n            await this.#readableController.enqueue(data);\n        } catch (e) {\n            if (this.#readableController.abortSignal.aborted) {\n                return;\n            }\n            throw e;\n        }\n    }\n\n    public ack(bytes: number) {\n        this.#availableWriteBytes += bytes;\n        this.#availableWriteBytesChanged?.resolve();\n    }\n\n    async close(): Promise<void> {\n        if (this.#closed) {\n            return;\n        }\n        this.#closed = true;\n\n        this.#availableWriteBytesChanged?.reject(new Error(\"Socket closed\"));\n\n        try {\n            this.#writableController.error(new Error(\"Socket closed\"));\n        } catch {\n            // ignore\n        }\n\n        await this.#dispatcher.sendPacket(\n            AdbCommand.Close,\n            this.localId,\n            this.remoteId,\n            EMPTY_UINT8_ARRAY,\n        );\n    }\n\n    dispose() {\n        try {\n            this.#readableController.close();\n        } catch {\n            // ignore\n        }\n\n        this.#closedPromise.resolve();\n    }\n}\n\n/**\n * A duplex stream representing a socket to ADB daemon.\n *\n * To close it, call either `socket.close()`,\n * `socket.readable.cancel()`, `socket.readable.getReader().cancel()`,\n * `socket.writable.abort()`, `socket.writable.getWriter().abort()`,\n * `socket.writable.close()` or `socket.writable.getWriter().close()`.\n */\nexport class AdbDaemonSocket implements AdbDaemonSocketInfo, AdbSocket {\n    #controller: AdbDaemonSocketController;\n\n    get localId(): number {\n        return this.#controller.localId;\n    }\n    get remoteId(): number {\n        return this.#controller.remoteId;\n    }\n    get localCreated(): boolean {\n        return this.#controller.localCreated;\n    }\n    get service(): string {\n        return this.#controller.service;\n    }\n\n    get readable(): ReadableStream<Uint8Array> {\n        return this.#controller.readable;\n    }\n    get writable(): WritableStream<MaybeConsumable<Uint8Array>> {\n        return this.#controller.writable;\n    }\n\n    get closed(): Promise<void> {\n        return this.#controller.closed;\n    }\n\n    constructor(controller: AdbDaemonSocketController) {\n        this.#controller = controller;\n    }\n\n    close() {\n        return this.#controller.close();\n    }\n}\n","import { PromiseResolver } from \"@yume-chan/async\";\nimport { AbortController, Consumable, WritableStream, } from \"@yume-chan/stream-extra\";\nimport { decodeUtf8, encodeUtf8 } from \"@yume-chan/struct\";\nimport { AdbBanner } from \"../banner.js\";\nimport { AdbFeature } from \"../features.js\";\nimport { ADB_DEFAULT_AUTHENTICATORS, AdbAuthenticationProcessor, } from \"./auth.js\";\nimport { AdbPacketDispatcher } from \"./dispatcher.js\";\nimport { AdbCommand, calculateChecksum } from \"./packet.js\";\nexport const ADB_DAEMON_VERSION_OMIT_CHECKSUM = 0x01000001;\n// https://android.googlesource.com/platform/packages/modules/adb/+/79010dc6d5ca7490c493df800d4421730f5466ca/transport.cpp#1252\n// There are some other feature constants, but some of them are only used by ADB server, not devices (daemons).\nexport const ADB_DAEMON_DEFAULT_FEATURES = [\n    AdbFeature.ShellV2,\n    AdbFeature.Cmd,\n    AdbFeature.StatV2,\n    AdbFeature.ListV2,\n    AdbFeature.FixedPushMkdir,\n    \"apex\",\n    AdbFeature.Abb,\n    // only tells the client the symlink timestamp issue in `adb push --sync` has been fixed.\n    // No special handling required.\n    \"fixed_push_symlink_timestamp\",\n    AdbFeature.AbbExec,\n    \"remount_shell\",\n    \"track_app\",\n    AdbFeature.SendReceiveV2,\n    \"sendrecv_v2_brotli\",\n    \"sendrecv_v2_lz4\",\n    \"sendrecv_v2_zstd\",\n    \"sendrecv_v2_dry_run_send\",\n    AdbFeature.DelayedAck,\n];\nexport const ADB_DAEMON_DEFAULT_INITIAL_PAYLOAD_SIZE = 32 * 1024 * 1024;\nexport class AdbDaemonTransport {\n    /**\n     * Authenticates the connection and creates an `AdbDaemonTransport` instance\n     * that can be used by `Adb` class.\n     *\n     * If an authentication process failed,\n     * no matter which value the `preserveConnection` option has,\n     * the `connection` is always kept open, so it can be used in another `authenticate` call.\n     */\n    static async authenticate({ serial, connection, credentialStore, authenticators = ADB_DEFAULT_AUTHENTICATORS, features = ADB_DAEMON_DEFAULT_FEATURES, initialDelayedAckBytes = ADB_DAEMON_DEFAULT_INITIAL_PAYLOAD_SIZE, ...options }) {\n        // Initially, set to highest-supported version and payload size.\n        let version = 0x01000001;\n        // Android 4: 4K, Android 7: 256K, Android 9: 1M\n        let maxPayloadSize = 1024 * 1024;\n        const resolver = new PromiseResolver();\n        const authProcessor = new AdbAuthenticationProcessor(authenticators, credentialStore);\n        // Here is similar to `AdbPacketDispatcher`,\n        // But the received packet types and send packet processing are different.\n        const abortController = new AbortController();\n        const pipe = connection.readable\n            .pipeTo(new WritableStream({\n            async write(packet) {\n                switch (packet.command) {\n                    case AdbCommand.Connect:\n                        version = Math.min(version, packet.arg0);\n                        maxPayloadSize = Math.min(maxPayloadSize, packet.arg1);\n                        resolver.resolve(decodeUtf8(packet.payload));\n                        break;\n                    case AdbCommand.Auth: {\n                        const response = await authProcessor.process(packet);\n                        await sendPacket(response);\n                        break;\n                    }\n                    default:\n                        // Maybe the previous ADB client exited without reading all packets,\n                        // so they are still waiting in OS internal buffer.\n                        // Just ignore them.\n                        // Because a `Connect` packet will reset the device,\n                        // Eventually there will be `Connect` and `Auth` response packets.\n                        break;\n                }\n            },\n        }), {\n            // Don't cancel the source ReadableStream on AbortSignal abort.\n            preventCancel: true,\n            signal: abortController.signal,\n        })\n            .then(() => {\n            // If `resolver` is already settled, call `reject` won't do anything.\n            resolver.reject(new Error(\"Connection closed unexpectedly\"));\n        }, (e) => {\n            resolver.reject(e);\n        });\n        const writer = connection.writable.getWriter();\n        async function sendPacket(init) {\n            // Always send checksum in auth steps\n            // Because we don't know if the device needs it or not.\n            init.checksum = calculateChecksum(init.payload);\n            init.magic = init.command ^ 0xffffffff;\n            await Consumable.WritableStream.write(writer, init);\n        }\n        const actualFeatures = features.slice();\n        if (initialDelayedAckBytes <= 0) {\n            const index = features.indexOf(AdbFeature.DelayedAck);\n            if (index !== -1) {\n                actualFeatures.splice(index, 1);\n            }\n        }\n        let banner;\n        try {\n            await sendPacket({\n                command: AdbCommand.Connect,\n                arg0: version,\n                arg1: maxPayloadSize,\n                // The terminating `;` is required in formal definition\n                // But ADB daemon (all versions) can still work without it\n                payload: encodeUtf8(`host::features=${actualFeatures.join(\",\")}`),\n            });\n            banner = await resolver.promise;\n        }\n        finally {\n            // When failed, release locks on `connection` so the caller can try again.\n            // When success, also release locks so `AdbPacketDispatcher` can use them.\n            abortController.abort();\n            writer.releaseLock();\n            // Wait until pipe stops (`ReadableStream` lock released)\n            await pipe;\n        }\n        return new AdbDaemonTransport({\n            serial,\n            connection,\n            version,\n            maxPayloadSize,\n            banner,\n            features: actualFeatures,\n            initialDelayedAckBytes,\n            ...options,\n        });\n    }\n    #connection;\n    get connection() {\n        return this.#connection;\n    }\n    #dispatcher;\n    #serial;\n    get serial() {\n        return this.#serial;\n    }\n    #protocolVersion;\n    get protocolVersion() {\n        return this.#protocolVersion;\n    }\n    get maxPayloadSize() {\n        return this.#dispatcher.options.maxPayloadSize;\n    }\n    #banner;\n    get banner() {\n        return this.#banner;\n    }\n    get disconnected() {\n        return this.#dispatcher.disconnected;\n    }\n    #clientFeatures;\n    get clientFeatures() {\n        return this.#clientFeatures;\n    }\n    constructor({ serial, connection, version, banner, features = ADB_DAEMON_DEFAULT_FEATURES, initialDelayedAckBytes, ...options }) {\n        this.#serial = serial;\n        this.#connection = connection;\n        this.#banner = AdbBanner.parse(banner);\n        this.#clientFeatures = features;\n        if (features.includes(AdbFeature.DelayedAck)) {\n            if (initialDelayedAckBytes <= 0) {\n                throw new TypeError(\"`initialDelayedAckBytes` must be greater than 0 when DelayedAck feature is enabled.\");\n            }\n            if (!this.#banner.features.includes(AdbFeature.DelayedAck)) {\n                initialDelayedAckBytes = 0;\n            }\n        }\n        else {\n            initialDelayedAckBytes = 0;\n        }\n        let calculateChecksum;\n        let appendNullToServiceString;\n        if (version >= ADB_DAEMON_VERSION_OMIT_CHECKSUM) {\n            calculateChecksum = false;\n            appendNullToServiceString = false;\n        }\n        else {\n            calculateChecksum = true;\n            appendNullToServiceString = true;\n        }\n        this.#dispatcher = new AdbPacketDispatcher(connection, {\n            calculateChecksum,\n            appendNullToServiceString,\n            initialDelayedAckBytes,\n            ...options,\n        });\n        this.#protocolVersion = version;\n    }\n    connect(service) {\n        return this.#dispatcher.createSocket(service);\n    }\n    addReverseTunnel(handler, address) {\n        if (!address) {\n            const id = Math.random().toString().substring(2);\n            address = `localabstract:reverse_${id}`;\n        }\n        this.#dispatcher.addReverseTunnel(address, handler);\n        return address;\n    }\n    removeReverseTunnel(address) {\n        this.#dispatcher.removeReverseTunnel(address);\n    }\n    clearReverseTunnels() {\n        this.#dispatcher.clearReverseTunnels();\n    }\n    close() {\n        return this.#dispatcher.close();\n    }\n}\n//# sourceMappingURL=transport.js.map","import { PromiseResolver } from \"@yume-chan/async\";\nimport type { ReadableWritablePair } from \"@yume-chan/stream-extra\";\nimport {\n    AbortController,\n    Consumable,\n    WritableStream,\n} from \"@yume-chan/stream-extra\";\nimport type { ValueOrPromise } from \"@yume-chan/struct\";\nimport { decodeUtf8, encodeUtf8 } from \"@yume-chan/struct\";\n\nimport type {\n    AdbIncomingSocketHandler,\n    AdbSocket,\n    AdbTransport,\n} from \"../adb.js\";\nimport { AdbBanner } from \"../banner.js\";\nimport { AdbFeature } from \"../features.js\";\n\nimport type { AdbAuthenticator, AdbCredentialStore } from \"./auth.js\";\nimport {\n    ADB_DEFAULT_AUTHENTICATORS,\n    AdbAuthenticationProcessor,\n} from \"./auth.js\";\nimport { AdbPacketDispatcher } from \"./dispatcher.js\";\nimport type { AdbPacketData, AdbPacketInit } from \"./packet.js\";\nimport { AdbCommand, calculateChecksum } from \"./packet.js\";\n\nexport const ADB_DAEMON_VERSION_OMIT_CHECKSUM = 0x01000001;\n// https://android.googlesource.com/platform/packages/modules/adb/+/79010dc6d5ca7490c493df800d4421730f5466ca/transport.cpp#1252\n// There are some other feature constants, but some of them are only used by ADB server, not devices (daemons).\nexport const ADB_DAEMON_DEFAULT_FEATURES = [\n    AdbFeature.ShellV2,\n    AdbFeature.Cmd,\n    AdbFeature.StatV2,\n    AdbFeature.ListV2,\n    AdbFeature.FixedPushMkdir,\n    \"apex\",\n    AdbFeature.Abb,\n    // only tells the client the symlink timestamp issue in `adb push --sync` has been fixed.\n    // No special handling required.\n    \"fixed_push_symlink_timestamp\",\n    AdbFeature.AbbExec,\n    \"remount_shell\",\n    \"track_app\",\n    AdbFeature.SendReceiveV2,\n    \"sendrecv_v2_brotli\",\n    \"sendrecv_v2_lz4\",\n    \"sendrecv_v2_zstd\",\n    \"sendrecv_v2_dry_run_send\",\n    AdbFeature.DelayedAck,\n] as AdbFeature[];\nexport const ADB_DAEMON_DEFAULT_INITIAL_PAYLOAD_SIZE = 32 * 1024 * 1024;\n\nexport type AdbDaemonConnection = ReadableWritablePair<\n    AdbPacketData,\n    Consumable<AdbPacketInit>\n>;\n\nexport interface AdbDaemonAuthenticationOptions {\n    serial: string;\n    connection: AdbDaemonConnection;\n    credentialStore: AdbCredentialStore;\n    authenticators?: AdbAuthenticator[];\n    features?: readonly AdbFeature[];\n\n    /**\n     * The number of bytes the device can send before receiving an ack packet.\n     * Using delayed ack can improve the throughput,\n     * especially when the device is connected over Wi-Fi (so the latency is higher).\n     *\n     * Set to 0 or any negative value to disable delayed ack in handshake.\n     * Otherwise the value must be in the range of unsigned 32-bit integer.\n     *\n     * Delayed ack was added in Android 14,\n     * this option will be ignored when the device doesn't support it.\n     *\n     * @default ADB_DAEMON_DEFAULT_INITIAL_PAYLOAD_SIZE\n     */\n    initialDelayedAckBytes?: number;\n\n    /**\n     * Whether to keep the `connection` open (don't call `writable.close` and `readable.cancel`)\n     * when `AdbDaemonTransport.close` is called.\n     *\n     * Note that when `authenticate` fails,\n     * no matter which value this option has,\n     * the `connection` is always kept open, so it can be used in another `authenticate` call.\n     *\n     * @default false\n     */\n    preserveConnection?: boolean | undefined;\n\n    /**\n     * When set, the transport will throw an error when\n     * one of the socket readable stalls for this amount of milliseconds.\n     *\n     * Because ADB is a multiplexed protocol, blocking one socket will also block all other sockets.\n     * It's important to always read from all sockets to prevent stalling.\n     *\n     * This option is helpful to detect bugs in the client code.\n     *\n     * @default undefined\n     */\n    readTimeLimit?: number | undefined;\n}\n\ninterface AdbDaemonSocketConnectorConstructionOptions {\n    serial: string;\n    connection: AdbDaemonConnection;\n    version: number;\n    maxPayloadSize: number;\n    banner: string;\n    features?: readonly AdbFeature[];\n\n    /**\n     * The number of bytes the device can send before receiving an ack packet.\n     * Using delayed ack can improve the throughput,\n     * especially when the device is connected over Wi-Fi (so the latency is higher).\n     *\n     * When `features` doesn't include `AdbFeature.DelayedAck`, it must be set to 0. Otherwise,\n     * the value must be in the range of unsigned 32-bit integer. If the device enabled\n     * delayed ack but the client didn't, the device will throw an error when the client sends\n     * the first data packet. And vice versa.\n     */\n    initialDelayedAckBytes: number;\n\n    /**\n     * Whether to keep the `connection` open (don't call `writable.close` and `readable.cancel`)\n     * when `AdbDaemonTransport.close` is called.\n     *\n     * @default false\n     */\n    preserveConnection?: boolean | undefined;\n\n    /**\n     * When set, the transport will throw an error when\n     * one of the socket readable stalls for this amount of milliseconds.\n     *\n     * Because ADB is a multiplexed protocol, blocking one socket will also block all other sockets.\n     * It's important to always read from all sockets to prevent stalling.\n     *\n     * This option is helpful to detect bugs in the client code.\n     *\n     * @default undefined\n     */\n    readTimeLimit?: number | undefined;\n}\n\nexport class AdbDaemonTransport implements AdbTransport {\n    /**\n     * Authenticates the connection and creates an `AdbDaemonTransport` instance\n     * that can be used by `Adb` class.\n     *\n     * If an authentication process failed,\n     * no matter which value the `preserveConnection` option has,\n     * the `connection` is always kept open, so it can be used in another `authenticate` call.\n     */\n    static async authenticate({\n        serial,\n        connection,\n        credentialStore,\n        authenticators = ADB_DEFAULT_AUTHENTICATORS,\n        features = ADB_DAEMON_DEFAULT_FEATURES,\n        initialDelayedAckBytes = ADB_DAEMON_DEFAULT_INITIAL_PAYLOAD_SIZE,\n        ...options\n    }: AdbDaemonAuthenticationOptions): Promise<AdbDaemonTransport> {\n        // Initially, set to highest-supported version and payload size.\n        let version = 0x01000001;\n        // Android 4: 4K, Android 7: 256K, Android 9: 1M\n        let maxPayloadSize = 1024 * 1024;\n\n        const resolver = new PromiseResolver<string>();\n        const authProcessor = new AdbAuthenticationProcessor(\n            authenticators,\n            credentialStore,\n        );\n\n        // Here is similar to `AdbPacketDispatcher`,\n        // But the received packet types and send packet processing are different.\n        const abortController = new AbortController();\n        const pipe = connection.readable\n            .pipeTo(\n                new WritableStream({\n                    async write(packet) {\n                        switch (packet.command) {\n                            case AdbCommand.Connect:\n                                version = Math.min(version, packet.arg0);\n                                maxPayloadSize = Math.min(\n                                    maxPayloadSize,\n                                    packet.arg1,\n                                );\n                                resolver.resolve(decodeUtf8(packet.payload));\n                                break;\n                            case AdbCommand.Auth: {\n                                const response =\n                                    await authProcessor.process(packet);\n                                await sendPacket(response);\n                                break;\n                            }\n                            default:\n                                // Maybe the previous ADB client exited without reading all packets,\n                                // so they are still waiting in OS internal buffer.\n                                // Just ignore them.\n                                // Because a `Connect` packet will reset the device,\n                                // Eventually there will be `Connect` and `Auth` response packets.\n                                break;\n                        }\n                    },\n                }),\n                {\n                    // Don't cancel the source ReadableStream on AbortSignal abort.\n                    preventCancel: true,\n                    signal: abortController.signal,\n                },\n            )\n            .then(\n                () => {\n                    // If `resolver` is already settled, call `reject` won't do anything.\n                    resolver.reject(\n                        new Error(\"Connection closed unexpectedly\"),\n                    );\n                },\n                (e) => {\n                    resolver.reject(e);\n                },\n            );\n\n        const writer = connection.writable.getWriter();\n        async function sendPacket(init: AdbPacketData) {\n            // Always send checksum in auth steps\n            // Because we don't know if the device needs it or not.\n            (init as AdbPacketInit).checksum = calculateChecksum(init.payload);\n            (init as AdbPacketInit).magic = init.command ^ 0xffffffff;\n            await Consumable.WritableStream.write(\n                writer,\n                init as AdbPacketInit,\n            );\n        }\n\n        const actualFeatures = features.slice();\n        if (initialDelayedAckBytes <= 0) {\n            const index = features.indexOf(AdbFeature.DelayedAck);\n            if (index !== -1) {\n                actualFeatures.splice(index, 1);\n            }\n        }\n\n        let banner: string;\n        try {\n            await sendPacket({\n                command: AdbCommand.Connect,\n                arg0: version,\n                arg1: maxPayloadSize,\n                // The terminating `;` is required in formal definition\n                // But ADB daemon (all versions) can still work without it\n                payload: encodeUtf8(\n                    `host::features=${actualFeatures.join(\",\")}`,\n                ),\n            });\n\n            banner = await resolver.promise;\n        } finally {\n            // When failed, release locks on `connection` so the caller can try again.\n            // When success, also release locks so `AdbPacketDispatcher` can use them.\n            abortController.abort();\n            writer.releaseLock();\n\n            // Wait until pipe stops (`ReadableStream` lock released)\n            await pipe;\n        }\n\n        return new AdbDaemonTransport({\n            serial,\n            connection,\n            version,\n            maxPayloadSize,\n            banner,\n            features: actualFeatures,\n            initialDelayedAckBytes,\n            ...options,\n        });\n    }\n\n    #connection: AdbDaemonConnection;\n    get connection() {\n        return this.#connection;\n    }\n\n    readonly #dispatcher: AdbPacketDispatcher;\n\n    #serial: string;\n    get serial() {\n        return this.#serial;\n    }\n\n    #protocolVersion: number;\n    get protocolVersion() {\n        return this.#protocolVersion;\n    }\n\n    get maxPayloadSize() {\n        return this.#dispatcher.options.maxPayloadSize;\n    }\n\n    #banner: AdbBanner;\n    get banner() {\n        return this.#banner;\n    }\n\n    get disconnected() {\n        return this.#dispatcher.disconnected;\n    }\n\n    #clientFeatures: readonly AdbFeature[];\n    get clientFeatures() {\n        return this.#clientFeatures;\n    }\n\n    constructor({\n        serial,\n        connection,\n        version,\n        banner,\n        features = ADB_DAEMON_DEFAULT_FEATURES,\n        initialDelayedAckBytes,\n        ...options\n    }: AdbDaemonSocketConnectorConstructionOptions) {\n        this.#serial = serial;\n        this.#connection = connection;\n        this.#banner = AdbBanner.parse(banner);\n        this.#clientFeatures = features;\n\n        if (features.includes(AdbFeature.DelayedAck)) {\n            if (initialDelayedAckBytes <= 0) {\n                throw new TypeError(\n                    \"`initialDelayedAckBytes` must be greater than 0 when DelayedAck feature is enabled.\",\n                );\n            }\n\n            if (!this.#banner.features.includes(AdbFeature.DelayedAck)) {\n                initialDelayedAckBytes = 0;\n            }\n        } else {\n            initialDelayedAckBytes = 0;\n        }\n\n        let calculateChecksum: boolean;\n        let appendNullToServiceString: boolean;\n        if (version >= ADB_DAEMON_VERSION_OMIT_CHECKSUM) {\n            calculateChecksum = false;\n            appendNullToServiceString = false;\n        } else {\n            calculateChecksum = true;\n            appendNullToServiceString = true;\n        }\n\n        this.#dispatcher = new AdbPacketDispatcher(connection, {\n            calculateChecksum,\n            appendNullToServiceString,\n            initialDelayedAckBytes,\n            ...options,\n        });\n\n        this.#protocolVersion = version;\n    }\n\n    connect(service: string): ValueOrPromise<AdbSocket> {\n        return this.#dispatcher.createSocket(service);\n    }\n\n    addReverseTunnel(\n        handler: AdbIncomingSocketHandler,\n        address?: string,\n    ): string {\n        if (!address) {\n            const id = Math.random().toString().substring(2);\n            address = `localabstract:reverse_${id}`;\n        }\n        this.#dispatcher.addReverseTunnel(address, handler);\n        return address;\n    }\n\n    removeReverseTunnel(address: string): void {\n        this.#dispatcher.removeReverseTunnel(address);\n    }\n\n    clearReverseTunnels(): void {\n        this.#dispatcher.clearReverseTunnels();\n    }\n\n    close(): ValueOrPromise<void> {\n        return this.#dispatcher.close();\n    }\n}\n","export * from \"./client.js\";\nexport * from \"./transport.js\";\n","// cspell:ignore tport\nimport { PromiseResolver } from \"@yume-chan/async\";\nimport { getUint64LittleEndian } from \"@yume-chan/no-data-view\";\nimport { BufferedReadableStream, MaybeConsumable, WrapWritableStream, } from \"@yume-chan/stream-extra\";\nimport { EMPTY_UINT8_ARRAY, SyncPromise, decodeUtf8, encodeUtf8, } from \"@yume-chan/struct\";\nimport { AdbBanner } from \"../banner.js\";\nimport { NOOP, hexToNumber, sequenceEqual, write4HexDigits, } from \"../utils/index.js\";\nimport { AdbServerTransport } from \"./transport.js\";\nconst OKAY = encodeUtf8(\"OKAY\");\nconst FAIL = encodeUtf8(\"FAIL\");\nclass AdbServerStream {\n    #connection;\n    #buffered;\n    #writer;\n    constructor(connection) {\n        this.#connection = connection;\n        this.#buffered = new BufferedReadableStream(connection.readable);\n        this.#writer = connection.writable.getWriter();\n    }\n    readExactly(length) {\n        return this.#buffered.readExactly(length);\n    }\n    readString() {\n        return SyncPromise.try(() => this.readExactly(4))\n            .then((buffer) => {\n            const length = hexToNumber(buffer);\n            if (length === 0) {\n                return EMPTY_UINT8_ARRAY;\n            }\n            else {\n                return this.readExactly(length);\n            }\n        })\n            .then((buffer) => {\n            // TODO: Investigate using stream mode `TextDecoder` for long strings.\n            // Because concatenating strings uses rope data structure,\n            // which only points to the original strings and doesn't copy the data,\n            // it's more efficient than concatenating `Uint8Array`s.\n            //\n            // ```\n            // const decoder = new TextDecoder();\n            // let result = '';\n            // for await (const chunk of stream.iterateExactly(length)) {\n            //     result += decoder.decode(chunk, { stream: true });\n            // }\n            // result += decoder.decode();\n            // return result;\n            // ```\n            //\n            // Although, it will be super complex to use `SyncPromise` with async iterator,\n            // `stream.iterateExactly` need to return an\n            // `Iterator<Uint8Array | Promise<Uint8Array>>` instead of a true async iterator.\n            // Maybe `SyncPromise` should support async iterators directly.\n            return decodeUtf8(buffer);\n        })\n            .valueOrPromise();\n    }\n    async writeString(value) {\n        // TODO: investigate using `encodeUtf8(\"0000\" + value)` then modifying the length\n        // That way allocates a new string (hopefully only a rope) instead of a new buffer\n        const encoded = encodeUtf8(value);\n        const buffer = new Uint8Array(4 + encoded.length);\n        write4HexDigits(buffer, 0, encoded.length);\n        buffer.set(encoded, 4);\n        await this.#writer.write(buffer);\n    }\n    async readOkay() {\n        const response = await this.readExactly(4);\n        if (sequenceEqual(response, OKAY)) {\n            // `OKAY` is followed by data length and data\n            // But different services want to parse the data differently\n            // So don't read the data here\n            return;\n        }\n        if (sequenceEqual(response, FAIL)) {\n            const reason = await this.readString();\n            throw new Error(reason);\n        }\n        throw new Error(`Unexpected response: ${decodeUtf8(response)}`);\n    }\n    release() {\n        this.#writer.releaseLock();\n        return {\n            readable: this.#buffered.release(),\n            writable: this.#connection.writable,\n            closed: this.#connection.closed,\n            close: () => this.#connection.close(),\n        };\n    }\n    async dispose() {\n        await this.#buffered.cancel().catch(NOOP);\n        await this.#writer.close().catch(NOOP);\n        try {\n            await this.#connection.close();\n        }\n        catch {\n            // ignore\n        }\n    }\n}\nexport class AdbServerClient {\n    static VERSION = 41;\n    connector;\n    wireless = new AdbServerClient.WirelessCommands(this);\n    mDns = new AdbServerClient.MDnsCommands(this);\n    constructor(connection) {\n        this.connector = connection;\n    }\n    async createConnection(request, options) {\n        const connection = await this.connector.connect(options);\n        const stream = new AdbServerStream(connection);\n        try {\n            await stream.writeString(request);\n        }\n        catch (e) {\n            await stream.dispose();\n            throw e;\n        }\n        try {\n            // `raceSignal` throws when the signal is aborted,\n            // so the `catch` block can close the connection.\n            await raceSignal(() => stream.readOkay(), options?.signal);\n            return stream;\n        }\n        catch (e) {\n            await stream.dispose();\n            throw e;\n        }\n    }\n    /**\n     * `adb version`\n     */\n    async getVersion() {\n        const connection = await this.createConnection(\"host:version\");\n        try {\n            const length = hexToNumber(await connection.readExactly(4));\n            const version = hexToNumber(await connection.readExactly(length));\n            return version;\n        }\n        finally {\n            await connection.dispose();\n        }\n    }\n    async validateVersion() {\n        const version = await this.getVersion();\n        if (version !== AdbServerClient.VERSION) {\n            throw new Error(`adb server version (${version}) doesn't match this client (${AdbServerClient.VERSION})`);\n        }\n    }\n    /**\n     * `adb kill-server`\n     */\n    async killServer() {\n        const connection = await this.createConnection(\"host:kill\");\n        await connection.dispose();\n    }\n    /**\n     * `adb host-features`\n     */\n    async getServerFeatures() {\n        const connection = await this.createConnection(\"host:host-features\");\n        try {\n            const response = await connection.readString();\n            return response.split(\",\");\n        }\n        finally {\n            await connection.dispose();\n        }\n    }\n    parseDeviceList(value) {\n        const devices = [];\n        for (const line of value.split(\"\\n\")) {\n            if (!line) {\n                continue;\n            }\n            const parts = line.split(\" \").filter(Boolean);\n            const serial = parts[0];\n            const status = parts[1];\n            if (status !== \"device\" && status !== \"unauthorized\") {\n                continue;\n            }\n            let product;\n            let model;\n            let device;\n            let transportId;\n            for (let i = 2; i < parts.length; i += 1) {\n                const [key, value] = parts[i].split(\":\");\n                switch (key) {\n                    case \"product\":\n                        product = value;\n                        break;\n                    case \"model\":\n                        model = value;\n                        break;\n                    case \"device\":\n                        device = value;\n                        break;\n                    case \"transport_id\":\n                        transportId = BigInt(value);\n                        break;\n                }\n            }\n            if (!transportId) {\n                throw new Error(`No transport id for device ${serial}`);\n            }\n            devices.push({\n                serial,\n                authenticating: status === \"unauthorized\",\n                product,\n                model,\n                device,\n                transportId,\n            });\n        }\n        return devices;\n    }\n    /**\n     * `adb devices -l`\n     */\n    async getDevices() {\n        const connection = await this.createConnection(\"host:devices-l\");\n        try {\n            const response = await connection.readString();\n            return this.parseDeviceList(response);\n        }\n        finally {\n            await connection.dispose();\n        }\n    }\n    /**\n     * Track the device list.\n     *\n     * @param signal An optional `AbortSignal` to stop tracking\n     *\n     * When `signal` is aborted, `trackDevices` will return normally, instead of throwing `signal.reason`.\n     */\n    async *trackDevices(signal) {\n        const connection = await this.createConnection(\"host:track-devices-l\");\n        try {\n            while (true) {\n                const response = await raceSignal(async () => await connection.readString(), signal);\n                const devices = this.parseDeviceList(response);\n                yield devices;\n            }\n        }\n        catch (e) {\n            if (e === signal?.reason) {\n                return;\n            }\n        }\n        finally {\n            await connection.dispose();\n        }\n    }\n    formatDeviceService(device, command) {\n        if (!device) {\n            return `host:${command}`;\n        }\n        if (\"transportId\" in device) {\n            return `host-transport-id:${device.transportId}:${command}`;\n        }\n        if (\"serial\" in device) {\n            return `host-serial:${device.serial}:${command}`;\n        }\n        if (\"usb\" in device) {\n            return `host-usb:${command}`;\n        }\n        if (\"tcp\" in device) {\n            return `host-local:${command}`;\n        }\n        throw new TypeError(\"Invalid device selector\");\n    }\n    /**\n     * `adb -s <device> reconnect` or `adb reconnect offline`\n     */\n    async reconnectDevice(device) {\n        const connection = await this.createConnection(device === \"offline\"\n            ? \"host:reconnect-offline\"\n            : this.formatDeviceService(device, \"reconnect\"));\n        try {\n            await connection.readString();\n        }\n        finally {\n            await connection.dispose();\n        }\n    }\n    /**\n     * Gets the features supported by the device.\n     * The transport ID of the selected device is also returned,\n     * so the caller can execute other commands against the same device.\n     * @param device The device selector\n     * @returns The transport ID of the selected device, and the features supported by the device.\n     */\n    async getDeviceFeatures(device) {\n        // On paper, `host:features` is a host service (device features are cached in host),\n        // so it shouldn't use `createDeviceConnection`,\n        // which is used to forward the service to the device.\n        //\n        // However, `createDeviceConnection` is a two step process:\n        //\n        //    1. Send a switch device service to host, to switch the connection to the device.\n        //    2. Send the actual service to host, let it forward the service to the device.\n        //\n        // In step 2, the host only forward the service to device if the service is unknown to host.\n        // If the service is a host service, it's still handled by host.\n        //\n        // Even better, if the service needs a device selector, but the selector is not provided,\n        // the service will be executed against the device selected by the switch device service.\n        // So we can use all device selector formats for the host service,\n        // and get the transport ID in the same time.\n        const connection = await this.createDeviceConnection(device, \"host:features\");\n        // Luckily `AdbServerClient.Socket` is compatible with `AdbServerClient.ServerConnection`\n        const stream = new AdbServerStream(connection);\n        try {\n            const featuresString = await stream.readString();\n            const features = featuresString.split(\",\");\n            return { transportId: connection.transportId, features };\n        }\n        finally {\n            await stream.dispose();\n        }\n    }\n    /**\n     * Creates a connection that will forward the service to device.\n     * @param device The device selector\n     * @param service The service to forward\n     * @returns An `AdbServerClient.Socket` that can be used to communicate with the service\n     */\n    async createDeviceConnection(device, service) {\n        await this.validateVersion();\n        let switchService;\n        let transportId;\n        if (!device) {\n            switchService = `host:tport:any`;\n        }\n        else if (\"transportId\" in device) {\n            switchService = `host:transport-id:${device.transportId}`;\n            transportId = device.transportId;\n        }\n        else if (\"serial\" in device) {\n            switchService = `host:tport:serial:${device.serial}`;\n        }\n        else if (\"usb\" in device) {\n            switchService = `host:tport:usb`;\n        }\n        else if (\"tcp\" in device) {\n            switchService = `host:tport:local`;\n        }\n        else {\n            throw new TypeError(\"Invalid device selector\");\n        }\n        const connection = await this.createConnection(switchService);\n        try {\n            await connection.writeString(service);\n        }\n        catch (e) {\n            await connection.dispose();\n            throw e;\n        }\n        try {\n            if (transportId === undefined) {\n                const array = await connection.readExactly(8);\n                transportId = getUint64LittleEndian(array, 0);\n            }\n            await connection.readOkay();\n            const socket = connection.release();\n            return {\n                transportId,\n                service,\n                readable: socket.readable,\n                writable: new WrapWritableStream(socket.writable).bePipedThroughFrom(new MaybeConsumable.UnwrapStream()),\n                get closed() {\n                    return socket.closed;\n                },\n                async close() {\n                    await socket.close();\n                },\n            };\n        }\n        catch (e) {\n            await connection.dispose();\n            throw e;\n        }\n    }\n    /**\n     * Wait for a device to be connected or disconnected.\n     *\n     * `adb wait-for-<state>`\n     *\n     * @param device The device selector\n     * @param state The state to wait for\n     * @param options The options\n     * @returns A promise that resolves when the condition is met.\n     */\n    async waitFor(device, state, options) {\n        let type;\n        if (!device) {\n            type = \"any\";\n        }\n        else if (\"transportId\" in device) {\n            type = \"any\";\n        }\n        else if (\"serial\" in device) {\n            type = \"any\";\n        }\n        else if (\"usb\" in device) {\n            type = \"usb\";\n        }\n        else if (\"tcp\" in device) {\n            type = \"local\";\n        }\n        else {\n            throw new TypeError(\"Invalid device selector\");\n        }\n        // `waitFor` can't use `connectDevice`, because the device\n        // might not be available yet.\n        const service = this.formatDeviceService(device, `wait-for-${type}-${state}`);\n        const connection = await this.createConnection(service, options);\n        try {\n            await connection.readOkay();\n        }\n        finally {\n            await connection.dispose();\n        }\n    }\n    async createTransport(device) {\n        const { transportId, features } = await this.getDeviceFeatures(device);\n        const devices = await this.getDevices();\n        const info = devices.find((device) => device.transportId === transportId);\n        const banner = new AdbBanner(info?.product, info?.model, info?.device, features);\n        return new AdbServerTransport(this, info?.serial ?? \"\", banner, transportId);\n    }\n}\nexport async function raceSignal(callback, ...signals) {\n    const abortPromise = new PromiseResolver();\n    function abort() {\n        abortPromise.reject(this.reason);\n    }\n    try {\n        for (const signal of signals) {\n            if (!signal) {\n                continue;\n            }\n            if (signal.aborted) {\n                throw signal.reason;\n            }\n            signal.addEventListener(\"abort\", abort);\n        }\n        return await Promise.race([callback(), abortPromise.promise]);\n    }\n    finally {\n        for (const signal of signals) {\n            if (!signal) {\n                continue;\n            }\n            signal.removeEventListener(\"abort\", abort);\n        }\n    }\n}\n(function (AdbServerClient) {\n    class NetworkError extends Error {\n        constructor(message) {\n            super(message);\n            this.name = \"NetworkError\";\n        }\n    }\n    AdbServerClient.NetworkError = NetworkError;\n    class UnauthorizedError extends Error {\n        constructor(message) {\n            super(message);\n            this.name = \"UnauthorizedError\";\n        }\n    }\n    AdbServerClient.UnauthorizedError = UnauthorizedError;\n    class AlreadyConnectedError extends Error {\n        constructor(message) {\n            super(message);\n            this.name = \"AlreadyConnectedError\";\n        }\n    }\n    AdbServerClient.AlreadyConnectedError = AlreadyConnectedError;\n    class WirelessCommands {\n        #client;\n        constructor(client) {\n            this.#client = client;\n        }\n        /**\n         * `adb pair <password> <address>`\n         */\n        async pair(address, password) {\n            const connection = await this.#client.createConnection(`host:pair:${password}:${address}`);\n            try {\n                const response = await connection.readExactly(4);\n                // `response` is either `FAIL`, or 4 hex digits for length of the string\n                if (sequenceEqual(response, FAIL)) {\n                    throw new Error(await connection.readString());\n                }\n                const length = hexToNumber(response);\n                // Ignore the string as it's always `Successful ...`\n                await connection.readExactly(length);\n            }\n            finally {\n                await connection.dispose();\n            }\n        }\n        /**\n         * `adb connect <address>`\n         */\n        async connect(address) {\n            const connection = await this.#client.createConnection(`host:connect:${address}`);\n            try {\n                const response = await connection.readString();\n                switch (response) {\n                    case `already connected to ${address}`:\n                        throw new AdbServerClient.AlreadyConnectedError(response);\n                    case `failed to connect to ${address}`: // `adb pair` mode not authorized\n                    case `failed to authenticate to ${address}`: // `adb tcpip` mode not authorized\n                        throw new AdbServerClient.UnauthorizedError(response);\n                    case `connected to ${address}`:\n                        return;\n                    default:\n                        throw new AdbServerClient.NetworkError(response);\n                }\n            }\n            finally {\n                await connection.dispose();\n            }\n        }\n        /**\n         * `adb disconnect <address>`\n         */\n        async disconnect(address) {\n            const connection = await this.#client.createConnection(`host:disconnect:${address}`);\n            try {\n                await connection.readString();\n            }\n            finally {\n                await connection.dispose();\n            }\n        }\n    }\n    AdbServerClient.WirelessCommands = WirelessCommands;\n    class MDnsCommands {\n        #client;\n        constructor(client) {\n            this.#client = client;\n        }\n        async check() {\n            const connection = await this.#client.createConnection(\"host:mdns:check\");\n            try {\n                const response = await connection.readString();\n                return !response.startsWith(\"ERROR:\");\n            }\n            finally {\n                await connection.dispose();\n            }\n        }\n        async getServices() {\n            const connection = await this.#client.createConnection(\"host:mdns:services\");\n            try {\n                const response = await connection.readString();\n                return response\n                    .split(\"\\n\")\n                    .filter(Boolean)\n                    .map((line) => {\n                    const parts = line.split(\"\\t\");\n                    return {\n                        name: parts[0],\n                        service: parts[1],\n                        address: parts[2],\n                    };\n                });\n            }\n            finally {\n                await connection.dispose();\n            }\n        }\n    }\n    AdbServerClient.MDnsCommands = MDnsCommands;\n})(AdbServerClient || (AdbServerClient = {}));\n//# sourceMappingURL=client.js.map","// cspell:ignore tport\n\nimport { PromiseResolver } from \"@yume-chan/async\";\nimport { getUint64LittleEndian } from \"@yume-chan/no-data-view\";\nimport type {\n    AbortSignal,\n    ReadableWritablePair,\n    WritableStreamDefaultWriter,\n} from \"@yume-chan/stream-extra\";\nimport {\n    BufferedReadableStream,\n    MaybeConsumable,\n    WrapWritableStream,\n} from \"@yume-chan/stream-extra\";\nimport type { ValueOrPromise } from \"@yume-chan/struct\";\nimport {\n    EMPTY_UINT8_ARRAY,\n    SyncPromise,\n    decodeUtf8,\n    encodeUtf8,\n} from \"@yume-chan/struct\";\n\nimport type { AdbIncomingSocketHandler, AdbSocket, Closeable } from \"../adb.js\";\nimport { AdbBanner } from \"../banner.js\";\nimport type { AdbFeature } from \"../features.js\";\nimport {\n    NOOP,\n    hexToNumber,\n    sequenceEqual,\n    write4HexDigits,\n} from \"../utils/index.js\";\n\nimport { AdbServerTransport } from \"./transport.js\";\n\nconst OKAY = encodeUtf8(\"OKAY\");\nconst FAIL = encodeUtf8(\"FAIL\");\n\nclass AdbServerStream {\n    #connection: AdbServerClient.ServerConnection;\n    #buffered: BufferedReadableStream;\n    #writer: WritableStreamDefaultWriter<Uint8Array>;\n\n    constructor(connection: AdbServerClient.ServerConnection) {\n        this.#connection = connection;\n        this.#buffered = new BufferedReadableStream(connection.readable);\n        this.#writer = connection.writable.getWriter();\n    }\n\n    readExactly(length: number): ValueOrPromise<Uint8Array> {\n        return this.#buffered.readExactly(length);\n    }\n\n    readString() {\n        return SyncPromise.try(() => this.readExactly(4))\n            .then((buffer) => {\n                const length = hexToNumber(buffer);\n                if (length === 0) {\n                    return EMPTY_UINT8_ARRAY;\n                } else {\n                    return this.readExactly(length);\n                }\n            })\n            .then((buffer) => {\n                // TODO: Investigate using stream mode `TextDecoder` for long strings.\n                // Because concatenating strings uses rope data structure,\n                // which only points to the original strings and doesn't copy the data,\n                // it's more efficient than concatenating `Uint8Array`s.\n                //\n                // ```\n                // const decoder = new TextDecoder();\n                // let result = '';\n                // for await (const chunk of stream.iterateExactly(length)) {\n                //     result += decoder.decode(chunk, { stream: true });\n                // }\n                // result += decoder.decode();\n                // return result;\n                // ```\n                //\n                // Although, it will be super complex to use `SyncPromise` with async iterator,\n                // `stream.iterateExactly` need to return an\n                // `Iterator<Uint8Array | Promise<Uint8Array>>` instead of a true async iterator.\n                // Maybe `SyncPromise` should support async iterators directly.\n                return decodeUtf8(buffer);\n            })\n            .valueOrPromise();\n    }\n\n    async writeString(value: string): Promise<void> {\n        // TODO: investigate using `encodeUtf8(\"0000\" + value)` then modifying the length\n        // That way allocates a new string (hopefully only a rope) instead of a new buffer\n        const encoded = encodeUtf8(value);\n        const buffer = new Uint8Array(4 + encoded.length);\n        write4HexDigits(buffer, 0, encoded.length);\n        buffer.set(encoded, 4);\n        await this.#writer.write(buffer);\n    }\n\n    async readOkay(): Promise<void> {\n        const response = await this.readExactly(4);\n        if (sequenceEqual(response, OKAY)) {\n            // `OKAY` is followed by data length and data\n            // But different services want to parse the data differently\n            // So don't read the data here\n            return;\n        }\n\n        if (sequenceEqual(response, FAIL)) {\n            const reason = await this.readString();\n            throw new Error(reason);\n        }\n\n        throw new Error(`Unexpected response: ${decodeUtf8(response)}`);\n    }\n\n    release() {\n        this.#writer.releaseLock();\n        return {\n            readable: this.#buffered.release(),\n            writable: this.#connection.writable,\n            closed: this.#connection.closed,\n            close: () => this.#connection.close(),\n        };\n    }\n\n    async dispose() {\n        await this.#buffered.cancel().catch(NOOP);\n        await this.#writer.close().catch(NOOP);\n        try {\n            await this.#connection.close();\n        } catch {\n            // ignore\n        }\n    }\n}\n\nexport class AdbServerClient {\n    static readonly VERSION = 41;\n\n    readonly connector: AdbServerClient.ServerConnector;\n\n    readonly wireless = new AdbServerClient.WirelessCommands(this);\n    readonly mDns = new AdbServerClient.MDnsCommands(this);\n\n    constructor(connection: AdbServerClient.ServerConnector) {\n        this.connector = connection;\n    }\n\n    async createConnection(\n        request: string,\n        options?: AdbServerClient.ServerConnectionOptions,\n    ): Promise<AdbServerStream> {\n        const connection = await this.connector.connect(options);\n        const stream = new AdbServerStream(connection);\n\n        try {\n            await stream.writeString(request);\n        } catch (e) {\n            await stream.dispose();\n            throw e;\n        }\n\n        try {\n            // `raceSignal` throws when the signal is aborted,\n            // so the `catch` block can close the connection.\n            await raceSignal(() => stream.readOkay(), options?.signal);\n            return stream;\n        } catch (e) {\n            await stream.dispose();\n            throw e;\n        }\n    }\n\n    /**\n     * `adb version`\n     */\n    async getVersion(): Promise<number> {\n        const connection = await this.createConnection(\"host:version\");\n        try {\n            const length = hexToNumber(await connection.readExactly(4));\n            const version = hexToNumber(await connection.readExactly(length));\n            return version;\n        } finally {\n            await connection.dispose();\n        }\n    }\n\n    async validateVersion() {\n        const version = await this.getVersion();\n        if (version !== AdbServerClient.VERSION) {\n            throw new Error(\n                `adb server version (${version}) doesn't match this client (${AdbServerClient.VERSION})`,\n            );\n        }\n    }\n\n    /**\n     * `adb kill-server`\n     */\n    async killServer(): Promise<void> {\n        const connection = await this.createConnection(\"host:kill\");\n        await connection.dispose();\n    }\n\n    /**\n     * `adb host-features`\n     */\n    async getServerFeatures(): Promise<AdbFeature[]> {\n        const connection = await this.createConnection(\"host:host-features\");\n        try {\n            const response = await connection.readString();\n            return response.split(\",\") as AdbFeature[];\n        } finally {\n            await connection.dispose();\n        }\n    }\n\n    parseDeviceList(value: string): AdbServerClient.Device[] {\n        const devices: AdbServerClient.Device[] = [];\n        for (const line of value.split(\"\\n\")) {\n            if (!line) {\n                continue;\n            }\n\n            const parts = line.split(\" \").filter(Boolean);\n            const serial = parts[0]!;\n            const status = parts[1]!;\n            if (status !== \"device\" && status !== \"unauthorized\") {\n                continue;\n            }\n\n            let product: string | undefined;\n            let model: string | undefined;\n            let device: string | undefined;\n            let transportId: bigint | undefined;\n            for (let i = 2; i < parts.length; i += 1) {\n                const [key, value] = parts[i]!.split(\":\");\n                switch (key) {\n                    case \"product\":\n                        product = value;\n                        break;\n                    case \"model\":\n                        model = value;\n                        break;\n                    case \"device\":\n                        device = value;\n                        break;\n                    case \"transport_id\":\n                        transportId = BigInt(value!);\n                        break;\n                }\n            }\n            if (!transportId) {\n                throw new Error(`No transport id for device ${serial}`);\n            }\n            devices.push({\n                serial,\n                authenticating: status === \"unauthorized\",\n                product,\n                model,\n                device,\n                transportId,\n            });\n        }\n        return devices;\n    }\n\n    /**\n     * `adb devices -l`\n     */\n    async getDevices(): Promise<AdbServerClient.Device[]> {\n        const connection = await this.createConnection(\"host:devices-l\");\n        try {\n            const response = await connection.readString();\n            return this.parseDeviceList(response);\n        } finally {\n            await connection.dispose();\n        }\n    }\n\n    /**\n     * Track the device list.\n     *\n     * @param signal An optional `AbortSignal` to stop tracking\n     *\n     * When `signal` is aborted, `trackDevices` will return normally, instead of throwing `signal.reason`.\n     */\n    async *trackDevices(\n        signal?: AbortSignal,\n    ): AsyncGenerator<AdbServerClient.Device[], void, void> {\n        const connection = await this.createConnection(\"host:track-devices-l\");\n        try {\n            while (true) {\n                const response = await raceSignal(\n                    async () => await connection.readString(),\n                    signal,\n                );\n                const devices = this.parseDeviceList(response);\n                yield devices;\n            }\n        } catch (e) {\n            if (e === signal?.reason) {\n                return;\n            }\n        } finally {\n            await connection.dispose();\n        }\n    }\n\n    formatDeviceService(\n        device: AdbServerClient.DeviceSelector,\n        command: string,\n    ) {\n        if (!device) {\n            return `host:${command}`;\n        }\n        if (\"transportId\" in device) {\n            return `host-transport-id:${device.transportId}:${command}`;\n        }\n        if (\"serial\" in device) {\n            return `host-serial:${device.serial}:${command}`;\n        }\n        if (\"usb\" in device) {\n            return `host-usb:${command}`;\n        }\n        if (\"tcp\" in device) {\n            return `host-local:${command}`;\n        }\n        throw new TypeError(\"Invalid device selector\");\n    }\n\n    /**\n     * `adb -s <device> reconnect` or `adb reconnect offline`\n     */\n    async reconnectDevice(device: AdbServerClient.DeviceSelector | \"offline\") {\n        const connection = await this.createConnection(\n            device === \"offline\"\n                ? \"host:reconnect-offline\"\n                : this.formatDeviceService(device, \"reconnect\"),\n        );\n        try {\n            await connection.readString();\n        } finally {\n            await connection.dispose();\n        }\n    }\n\n    /**\n     * Gets the features supported by the device.\n     * The transport ID of the selected device is also returned,\n     * so the caller can execute other commands against the same device.\n     * @param device The device selector\n     * @returns The transport ID of the selected device, and the features supported by the device.\n     */\n    async getDeviceFeatures(\n        device: AdbServerClient.DeviceSelector,\n    ): Promise<{ transportId: bigint; features: AdbFeature[] }> {\n        // On paper, `host:features` is a host service (device features are cached in host),\n        // so it shouldn't use `createDeviceConnection`,\n        // which is used to forward the service to the device.\n        //\n        // However, `createDeviceConnection` is a two step process:\n        //\n        //    1. Send a switch device service to host, to switch the connection to the device.\n        //    2. Send the actual service to host, let it forward the service to the device.\n        //\n        // In step 2, the host only forward the service to device if the service is unknown to host.\n        // If the service is a host service, it's still handled by host.\n        //\n        // Even better, if the service needs a device selector, but the selector is not provided,\n        // the service will be executed against the device selected by the switch device service.\n        // So we can use all device selector formats for the host service,\n        // and get the transport ID in the same time.\n        const connection = await this.createDeviceConnection(\n            device,\n            \"host:features\",\n        );\n        // Luckily `AdbServerClient.Socket` is compatible with `AdbServerClient.ServerConnection`\n        const stream = new AdbServerStream(connection);\n        try {\n            const featuresString = await stream.readString();\n            const features = featuresString.split(\",\") as AdbFeature[];\n            return { transportId: connection.transportId, features };\n        } finally {\n            await stream.dispose();\n        }\n    }\n\n    /**\n     * Creates a connection that will forward the service to device.\n     * @param device The device selector\n     * @param service The service to forward\n     * @returns An `AdbServerClient.Socket` that can be used to communicate with the service\n     */\n    async createDeviceConnection(\n        device: AdbServerClient.DeviceSelector,\n        service: string,\n    ): Promise<AdbServerClient.Socket> {\n        await this.validateVersion();\n\n        let switchService: string;\n        let transportId: bigint | undefined;\n        if (!device) {\n            switchService = `host:tport:any`;\n        } else if (\"transportId\" in device) {\n            switchService = `host:transport-id:${device.transportId}`;\n            transportId = device.transportId;\n        } else if (\"serial\" in device) {\n            switchService = `host:tport:serial:${device.serial}`;\n        } else if (\"usb\" in device) {\n            switchService = `host:tport:usb`;\n        } else if (\"tcp\" in device) {\n            switchService = `host:tport:local`;\n        } else {\n            throw new TypeError(\"Invalid device selector\");\n        }\n\n        const connection = await this.createConnection(switchService);\n\n        try {\n            await connection.writeString(service);\n        } catch (e) {\n            await connection.dispose();\n            throw e;\n        }\n\n        try {\n            if (transportId === undefined) {\n                const array = await connection.readExactly(8);\n                transportId = getUint64LittleEndian(array, 0);\n            }\n\n            await connection.readOkay();\n\n            const socket = connection.release();\n\n            return {\n                transportId,\n                service,\n                readable: socket.readable,\n                writable: new WrapWritableStream(\n                    socket.writable,\n                ).bePipedThroughFrom(new MaybeConsumable.UnwrapStream()),\n                get closed() {\n                    return socket.closed;\n                },\n                async close() {\n                    await socket.close();\n                },\n            };\n        } catch (e) {\n            await connection.dispose();\n            throw e;\n        }\n    }\n\n    /**\n     * Wait for a device to be connected or disconnected.\n     *\n     * `adb wait-for-<state>`\n     *\n     * @param device The device selector\n     * @param state The state to wait for\n     * @param options The options\n     * @returns A promise that resolves when the condition is met.\n     */\n    async waitFor(\n        device: AdbServerClient.DeviceSelector,\n        state: \"device\" | \"disconnect\",\n        options?: AdbServerClient.ServerConnectionOptions,\n    ): Promise<void> {\n        let type: string;\n        if (!device) {\n            type = \"any\";\n        } else if (\"transportId\" in device) {\n            type = \"any\";\n        } else if (\"serial\" in device) {\n            type = \"any\";\n        } else if (\"usb\" in device) {\n            type = \"usb\";\n        } else if (\"tcp\" in device) {\n            type = \"local\";\n        } else {\n            throw new TypeError(\"Invalid device selector\");\n        }\n\n        // `waitFor` can't use `connectDevice`, because the device\n        // might not be available yet.\n        const service = this.formatDeviceService(\n            device,\n            `wait-for-${type}-${state}`,\n        );\n\n        const connection = await this.createConnection(service, options);\n        try {\n            await connection.readOkay();\n        } finally {\n            await connection.dispose();\n        }\n    }\n\n    async createTransport(\n        device: AdbServerClient.DeviceSelector,\n    ): Promise<AdbServerTransport> {\n        const { transportId, features } = await this.getDeviceFeatures(device);\n\n        const devices = await this.getDevices();\n        const info = devices.find(\n            (device) => device.transportId === transportId,\n        );\n\n        const banner = new AdbBanner(\n            info?.product,\n            info?.model,\n            info?.device,\n            features,\n        );\n\n        return new AdbServerTransport(\n            this,\n            info?.serial ?? \"\",\n            banner,\n            transportId,\n        );\n    }\n}\n\nexport async function raceSignal<T>(\n    callback: () => PromiseLike<T>,\n    ...signals: (AbortSignal | undefined)[]\n): Promise<T> {\n    const abortPromise = new PromiseResolver<never>();\n    function abort(this: AbortSignal) {\n        abortPromise.reject(this.reason);\n    }\n\n    try {\n        for (const signal of signals) {\n            if (!signal) {\n                continue;\n            }\n            if (signal.aborted) {\n                throw signal.reason;\n            }\n            signal.addEventListener(\"abort\", abort);\n        }\n\n        return await Promise.race([callback(), abortPromise.promise]);\n    } finally {\n        for (const signal of signals) {\n            if (!signal) {\n                continue;\n            }\n            signal.removeEventListener(\"abort\", abort);\n        }\n    }\n}\n\nexport namespace AdbServerClient {\n    export interface ServerConnectionOptions {\n        unref?: boolean | undefined;\n        signal?: AbortSignal | undefined;\n    }\n\n    export interface ServerConnection\n        extends ReadableWritablePair<Uint8Array, Uint8Array>,\n            Closeable {\n        get closed(): Promise<void>;\n    }\n\n    export interface ServerConnector {\n        connect(\n            options?: ServerConnectionOptions,\n        ): ValueOrPromise<ServerConnection>;\n\n        addReverseTunnel(\n            handler: AdbIncomingSocketHandler,\n            address?: string,\n        ): ValueOrPromise<string>;\n\n        removeReverseTunnel(address: string): ValueOrPromise<void>;\n\n        clearReverseTunnels(): ValueOrPromise<void>;\n    }\n\n    export interface Socket extends AdbSocket {\n        transportId: bigint;\n    }\n\n    export type DeviceSelector =\n        | { transportId: bigint }\n        | { serial: string }\n        | { usb: true }\n        | { tcp: true }\n        | undefined;\n\n    export interface Device {\n        serial: string;\n        authenticating: boolean;\n        product?: string | undefined;\n        model?: string | undefined;\n        device?: string | undefined;\n        transportId: bigint;\n    }\n\n    export class NetworkError extends Error {\n        constructor(message: string) {\n            super(message);\n            this.name = \"NetworkError\";\n        }\n    }\n\n    export class UnauthorizedError extends Error {\n        constructor(message: string) {\n            super(message);\n            this.name = \"UnauthorizedError\";\n        }\n    }\n\n    export class AlreadyConnectedError extends Error {\n        constructor(message: string) {\n            super(message);\n            this.name = \"AlreadyConnectedError\";\n        }\n    }\n\n    export class WirelessCommands {\n        #client: AdbServerClient;\n\n        constructor(client: AdbServerClient) {\n            this.#client = client;\n        }\n\n        /**\n         * `adb pair <password> <address>`\n         */\n        async pair(address: string, password: string): Promise<void> {\n            const connection = await this.#client.createConnection(\n                `host:pair:${password}:${address}`,\n            );\n            try {\n                const response = await connection.readExactly(4);\n                // `response` is either `FAIL`, or 4 hex digits for length of the string\n                if (sequenceEqual(response, FAIL)) {\n                    throw new Error(await connection.readString());\n                }\n                const length = hexToNumber(response);\n                // Ignore the string as it's always `Successful ...`\n                await connection.readExactly(length);\n            } finally {\n                await connection.dispose();\n            }\n        }\n\n        /**\n         * `adb connect <address>`\n         */\n        async connect(address: string): Promise<void> {\n            const connection = await this.#client.createConnection(\n                `host:connect:${address}`,\n            );\n            try {\n                const response = await connection.readString();\n                switch (response) {\n                    case `already connected to ${address}`:\n                        throw new AdbServerClient.AlreadyConnectedError(\n                            response,\n                        );\n                    case `failed to connect to ${address}`: // `adb pair` mode not authorized\n                    case `failed to authenticate to ${address}`: // `adb tcpip` mode not authorized\n                        throw new AdbServerClient.UnauthorizedError(response);\n                    case `connected to ${address}`:\n                        return;\n                    default:\n                        throw new AdbServerClient.NetworkError(response);\n                }\n            } finally {\n                await connection.dispose();\n            }\n        }\n\n        /**\n         * `adb disconnect <address>`\n         */\n        async disconnect(address: string): Promise<void> {\n            const connection = await this.#client.createConnection(\n                `host:disconnect:${address}`,\n            );\n            try {\n                await connection.readString();\n            } finally {\n                await connection.dispose();\n            }\n        }\n    }\n\n    export class MDnsCommands {\n        #client: AdbServerClient;\n\n        constructor(client: AdbServerClient) {\n            this.#client = client;\n        }\n\n        async check() {\n            const connection =\n                await this.#client.createConnection(\"host:mdns:check\");\n            try {\n                const response = await connection.readString();\n                return !response.startsWith(\"ERROR:\");\n            } finally {\n                await connection.dispose();\n            }\n        }\n\n        async getServices() {\n            const connection =\n                await this.#client.createConnection(\"host:mdns:services\");\n            try {\n                const response = await connection.readString();\n                return response\n                    .split(\"\\n\")\n                    .filter(Boolean)\n                    .map((line) => {\n                        const parts = line.split(\"\\t\");\n                        return {\n                            name: parts[0]!,\n                            service: parts[1]!,\n                            address: parts[2]!,\n                        };\n                    });\n            } finally {\n                await connection.dispose();\n            }\n        }\n    }\n}\n","import { PromiseResolver } from \"@yume-chan/async\";\nimport { AbortController } from \"@yume-chan/stream-extra\";\nimport { AdbFeature } from \"../features.js\";\nexport const ADB_SERVER_DEFAULT_FEATURES = [\n    AdbFeature.ShellV2,\n    AdbFeature.Cmd,\n    AdbFeature.StatV2,\n    AdbFeature.ListV2,\n    AdbFeature.FixedPushMkdir,\n    \"apex\",\n    AdbFeature.Abb,\n    // only tells the client the symlink timestamp issue in `adb push --sync` has been fixed.\n    // No special handling required.\n    \"fixed_push_symlink_timestamp\",\n    AdbFeature.AbbExec,\n    \"remount_shell\",\n    \"track_app\",\n    AdbFeature.SendReceiveV2,\n    \"sendrecv_v2_brotli\",\n    \"sendrecv_v2_lz4\",\n    \"sendrecv_v2_zstd\",\n    \"sendrecv_v2_dry_run_send\",\n];\nexport class AdbServerTransport {\n    #client;\n    serial;\n    transportId;\n    maxPayloadSize = 1 * 1024 * 1024;\n    banner;\n    #closed = new PromiseResolver();\n    #waitAbortController = new AbortController();\n    disconnected;\n    get clientFeatures() {\n        // No need to get host features (features supported by ADB server)\n        // Because we create all ADB packets ourselves\n        return ADB_SERVER_DEFAULT_FEATURES;\n    }\n    constructor(client, serial, banner, transportId) {\n        this.#client = client;\n        this.serial = serial;\n        this.banner = banner;\n        this.transportId = transportId;\n        this.disconnected = Promise.race([\n            this.#closed.promise,\n            client.waitFor({ transportId }, \"disconnect\", {\n                signal: this.#waitAbortController.signal,\n                unref: true,\n            }),\n        ]);\n    }\n    async connect(service) {\n        return await this.#client.createDeviceConnection({\n            transportId: this.transportId,\n        }, service);\n    }\n    async addReverseTunnel(handler, address) {\n        return await this.#client.connector.addReverseTunnel(handler, address);\n    }\n    async removeReverseTunnel(address) {\n        await this.#client.connector.removeReverseTunnel(address);\n    }\n    async clearReverseTunnels() {\n        await this.#client.connector.clearReverseTunnels();\n    }\n    close() {\n        this.#closed.resolve();\n        this.#waitAbortController.abort();\n    }\n}\n//# sourceMappingURL=transport.js.map","import { PromiseResolver } from \"@yume-chan/async\";\nimport { AbortController } from \"@yume-chan/stream-extra\";\nimport type { ValueOrPromise } from \"@yume-chan/struct\";\n\nimport type {\n    AdbIncomingSocketHandler,\n    AdbSocket,\n    AdbTransport,\n} from \"../adb.js\";\nimport type { AdbBanner } from \"../banner.js\";\nimport { AdbFeature } from \"../features.js\";\n\nimport type { AdbServerClient } from \"./client.js\";\n\nexport const ADB_SERVER_DEFAULT_FEATURES = [\n    AdbFeature.ShellV2,\n    AdbFeature.Cmd,\n    AdbFeature.StatV2,\n    AdbFeature.ListV2,\n    AdbFeature.FixedPushMkdir,\n    \"apex\",\n    AdbFeature.Abb,\n    // only tells the client the symlink timestamp issue in `adb push --sync` has been fixed.\n    // No special handling required.\n    \"fixed_push_symlink_timestamp\",\n    AdbFeature.AbbExec,\n    \"remount_shell\",\n    \"track_app\",\n    AdbFeature.SendReceiveV2,\n    \"sendrecv_v2_brotli\",\n    \"sendrecv_v2_lz4\",\n    \"sendrecv_v2_zstd\",\n    \"sendrecv_v2_dry_run_send\",\n] as AdbFeature[];\n\nexport class AdbServerTransport implements AdbTransport {\n    #client: AdbServerClient;\n\n    readonly serial: string;\n\n    readonly transportId: bigint;\n\n    readonly maxPayloadSize: number = 1 * 1024 * 1024;\n\n    readonly banner: AdbBanner;\n\n    #closed = new PromiseResolver<void>();\n    #waitAbortController = new AbortController();\n    readonly disconnected: Promise<void>;\n\n    get clientFeatures() {\n        // No need to get host features (features supported by ADB server)\n        // Because we create all ADB packets ourselves\n        return ADB_SERVER_DEFAULT_FEATURES;\n    }\n\n    constructor(\n        client: AdbServerClient,\n        serial: string,\n        banner: AdbBanner,\n        transportId: bigint,\n    ) {\n        this.#client = client;\n        this.serial = serial;\n        this.banner = banner;\n        this.transportId = transportId;\n\n        this.disconnected = Promise.race([\n            this.#closed.promise,\n            client.waitFor({ transportId }, \"disconnect\", {\n                signal: this.#waitAbortController.signal,\n                unref: true,\n            }),\n        ]);\n    }\n\n    async connect(service: string): Promise<AdbSocket> {\n        return await this.#client.createDeviceConnection(\n            {\n                transportId: this.transportId,\n            },\n            service,\n        );\n    }\n\n    async addReverseTunnel(\n        handler: AdbIncomingSocketHandler,\n        address?: string,\n    ): Promise<string> {\n        return await this.#client.connector.addReverseTunnel(handler, address);\n    }\n\n    async removeReverseTunnel(address: string): Promise<void> {\n        await this.#client.connector.removeReverseTunnel(address);\n    }\n\n    async clearReverseTunnels(): Promise<void> {\n        await this.#client.connector.clearReverseTunnels();\n    }\n\n    close(): ValueOrPromise<void> {\n        this.#closed.resolve();\n        this.#waitAbortController.abort();\n    }\n}\n","export function isErrorName(e, name) {\n    // node-usb package doesn't use `DOMException`,\n    // so use a looser check\n    // https://github.com/node-usb/node-usb/issues/573\n    return (typeof e === \"object\" && e !== null && \"name\" in e && e.name === name);\n}\nfunction alternateMatchesFilter(alternate, filters) {\n    return filters.some((filter) => alternate.interfaceClass === filter.classCode &&\n        alternate.interfaceSubclass === filter.subclassCode &&\n        alternate.interfaceProtocol === filter.protocolCode);\n}\nexport function findUsbAlternateInterface(device, filters) {\n    for (const configuration of device.configurations) {\n        for (const interface_ of configuration.interfaces) {\n            for (const alternate of interface_.alternates) {\n                if (alternateMatchesFilter(alternate, filters)) {\n                    return { configuration, interface_, alternate };\n                }\n            }\n        }\n    }\n    throw new TypeError(\"No matched alternate interface found\");\n}\nfunction padNumber(value) {\n    return value.toString(16).padStart(4, \"0\");\n}\nexport function getSerialNumber(device) {\n    if (device.serialNumber) {\n        return device.serialNumber;\n    }\n    return padNumber(device.vendorId) + \"x\" + padNumber(device.productId);\n}\n//# sourceMappingURL=utils.js.map","export function isErrorName(e: unknown, name: string): boolean {\n    // node-usb package doesn't use `DOMException`,\n    // so use a looser check\n    // https://github.com/node-usb/node-usb/issues/573\n    return (\n        typeof e === \"object\" && e !== null && \"name\" in e && e.name === name\n    );\n}\n\n/**\n * `classCode`, `subclassCode` and `protocolCode` are required\n * for selecting correct USB configuration and interface.\n */\nexport type AdbDeviceFilter = USBDeviceFilter &\n    Required<\n        Pick<USBDeviceFilter, \"classCode\" | \"subclassCode\" | \"protocolCode\">\n    >;\n\nfunction alternateMatchesFilter(\n    alternate: USBAlternateInterface,\n    filters: AdbDeviceFilter[],\n) {\n    return filters.some(\n        (filter) =>\n            alternate.interfaceClass === filter.classCode &&\n            alternate.interfaceSubclass === filter.subclassCode &&\n            alternate.interfaceProtocol === filter.protocolCode,\n    );\n}\n\nexport function findUsbAlternateInterface(\n    device: USBDevice,\n    filters: AdbDeviceFilter[],\n) {\n    for (const configuration of device.configurations) {\n        for (const interface_ of configuration.interfaces) {\n            for (const alternate of interface_.alternates) {\n                if (alternateMatchesFilter(alternate, filters)) {\n                    return { configuration, interface_, alternate };\n                }\n            }\n        }\n    }\n\n    throw new TypeError(\"No matched alternate interface found\");\n}\n\nfunction padNumber(value: number) {\n    return value.toString(16).padStart(4, \"0\");\n}\n\nexport function getSerialNumber(device: USBDevice) {\n    if (device.serialNumber) {\n        return device.serialNumber;\n    }\n\n    return padNumber(device.vendorId) + \"x\" + padNumber(device.productId);\n}\n","import { ADB_DEFAULT_DEVICE_FILTER, AdbDaemonWebUsbDevice } from \"./device.js\";\nimport { findUsbAlternateInterface, getSerialNumber, isErrorName, } from \"./utils.js\";\nexport class AdbDaemonWebUsbDeviceManager {\n    /**\n     * Gets the instance of {@link AdbDaemonWebUsbDeviceManager} using browser WebUSB implementation.\n     *\n     * May be `undefined` if current runtime does not support WebUSB.\n     */\n    static BROWSER = typeof globalThis.navigator !== \"undefined\" &&\n        !!globalThis.navigator.usb\n        ? new AdbDaemonWebUsbDeviceManager(globalThis.navigator.usb)\n        : undefined;\n    #usbManager;\n    /**\n     * Create a new instance of {@link AdbDaemonWebUsbDeviceManager} using the specified WebUSB implementation.\n     * @param usbManager A WebUSB compatible interface.\n     */\n    constructor(usbManager) {\n        this.#usbManager = usbManager;\n    }\n    /**\n     * Request access to a connected device.\n     * This is a convince method for `usb.requestDevice()`.\n     * @param filters\n     * The filters to apply to the device list.\n     *\n     * It must have `classCode`, `subclassCode` and `protocolCode` fields for selecting the ADB interface,\n     * but might also have `vendorId`, `productId` or `serialNumber` fields to limit the displayed device list.\n     *\n     * Defaults to {@link ADB_DEFAULT_DEVICE_FILTER}.\n     * @returns An {@link AdbDaemonWebUsbDevice} instance if the user selected a device,\n     * or `undefined` if the user cancelled the device picker.\n     */\n    async requestDevice(options = {}) {\n        if (!options.filters) {\n            options.filters = [ADB_DEFAULT_DEVICE_FILTER];\n        }\n        else if (options.filters.length === 0) {\n            throw new TypeError(\"filters must not be empty\");\n        }\n        try {\n            const device = await this.#usbManager.requestDevice(options);\n            return new AdbDaemonWebUsbDevice(device, options.filters, this.#usbManager);\n        }\n        catch (e) {\n            // No device selected\n            if (isErrorName(e, \"NotFoundError\")) {\n                return undefined;\n            }\n            throw e;\n        }\n    }\n    /**\n     * Get all connected and authenticated devices.\n     * This is a convince method for `usb.getDevices()`.\n     * @param filters\n     * The filters to apply to the device list.\n     *\n     * It must have `classCode`, `subclassCode` and `protocolCode` fields for selecting the ADB interface,\n     * but might also have `vendorId`, `productId` or `serialNumber` fields to limit the device list.\n     *\n     * Defaults to {@link ADB_DEFAULT_DEVICE_FILTER}.\n     * @returns An array of {@link AdbDaemonWebUsbDevice} instances for all connected and authenticated devices.\n     */\n    async getDevices(filters = [ADB_DEFAULT_DEVICE_FILTER]) {\n        if (filters.length === 0) {\n            throw new TypeError(\"filters must not be empty\");\n        }\n        const devices = await this.#usbManager.getDevices();\n        return devices\n            .filter((device) => {\n            for (const filter of filters) {\n                if (\"vendorId\" in filter &&\n                    device.vendorId !== filter.vendorId) {\n                    continue;\n                }\n                if (\"productId\" in filter &&\n                    device.productId !== filter.productId) {\n                    continue;\n                }\n                if (\"serialNumber\" in filter &&\n                    getSerialNumber(device) !== filter.serialNumber) {\n                    continue;\n                }\n                try {\n                    findUsbAlternateInterface(device, filters);\n                    return true;\n                }\n                catch {\n                    continue;\n                }\n            }\n            return false;\n        })\n            .map((device) => new AdbDaemonWebUsbDevice(device, filters, this.#usbManager));\n    }\n}\n//# sourceMappingURL=manager.js.map","import { ADB_DEFAULT_DEVICE_FILTER, AdbDaemonWebUsbDevice } from \"./device.js\";\nimport type { AdbDeviceFilter } from \"./utils.js\";\nimport {\n    findUsbAlternateInterface,\n    getSerialNumber,\n    isErrorName,\n} from \"./utils.js\";\n\nexport namespace AdbDaemonWebUsbDeviceManager {\n    export interface RequestDeviceOptions {\n        filters?: AdbDeviceFilter[] | undefined;\n        exclusionFilters?: USBDeviceFilter[] | undefined;\n    }\n}\n\nexport class AdbDaemonWebUsbDeviceManager {\n    /**\n     * Gets the instance of {@link AdbDaemonWebUsbDeviceManager} using browser WebUSB implementation.\n     *\n     * May be `undefined` if current runtime does not support WebUSB.\n     */\n    static readonly BROWSER =\n        typeof globalThis.navigator !== \"undefined\" &&\n        !!globalThis.navigator.usb\n            ? new AdbDaemonWebUsbDeviceManager(globalThis.navigator.usb)\n            : undefined;\n\n    #usbManager: USB;\n\n    /**\n     * Create a new instance of {@link AdbDaemonWebUsbDeviceManager} using the specified WebUSB implementation.\n     * @param usbManager A WebUSB compatible interface.\n     */\n    constructor(usbManager: USB) {\n        this.#usbManager = usbManager;\n    }\n\n    /**\n     * Request access to a connected device.\n     * This is a convince method for `usb.requestDevice()`.\n     * @param filters\n     * The filters to apply to the device list.\n     *\n     * It must have `classCode`, `subclassCode` and `protocolCode` fields for selecting the ADB interface,\n     * but might also have `vendorId`, `productId` or `serialNumber` fields to limit the displayed device list.\n     *\n     * Defaults to {@link ADB_DEFAULT_DEVICE_FILTER}.\n     * @returns An {@link AdbDaemonWebUsbDevice} instance if the user selected a device,\n     * or `undefined` if the user cancelled the device picker.\n     */\n    async requestDevice(\n        options: AdbDaemonWebUsbDeviceManager.RequestDeviceOptions = {},\n    ): Promise<AdbDaemonWebUsbDevice | undefined> {\n        if (!options.filters) {\n            options.filters = [ADB_DEFAULT_DEVICE_FILTER];\n        } else if (options.filters.length === 0) {\n            throw new TypeError(\"filters must not be empty\");\n        }\n\n        try {\n            const device = await this.#usbManager.requestDevice(\n                options as USBDeviceRequestOptions,\n            );\n            return new AdbDaemonWebUsbDevice(\n                device,\n                options.filters,\n                this.#usbManager,\n            );\n        } catch (e) {\n            // No device selected\n            if (isErrorName(e, \"NotFoundError\")) {\n                return undefined;\n            }\n\n            throw e;\n        }\n    }\n\n    /**\n     * Get all connected and authenticated devices.\n     * This is a convince method for `usb.getDevices()`.\n     * @param filters\n     * The filters to apply to the device list.\n     *\n     * It must have `classCode`, `subclassCode` and `protocolCode` fields for selecting the ADB interface,\n     * but might also have `vendorId`, `productId` or `serialNumber` fields to limit the device list.\n     *\n     * Defaults to {@link ADB_DEFAULT_DEVICE_FILTER}.\n     * @returns An array of {@link AdbDaemonWebUsbDevice} instances for all connected and authenticated devices.\n     */\n    async getDevices(\n        filters: AdbDeviceFilter[] = [ADB_DEFAULT_DEVICE_FILTER],\n    ): Promise<AdbDaemonWebUsbDevice[]> {\n        if (filters.length === 0) {\n            throw new TypeError(\"filters must not be empty\");\n        }\n\n        const devices = await this.#usbManager.getDevices();\n        return devices\n            .filter((device) => {\n                for (const filter of filters) {\n                    if (\n                        \"vendorId\" in filter &&\n                        device.vendorId !== filter.vendorId\n                    ) {\n                        continue;\n                    }\n                    if (\n                        \"productId\" in filter &&\n                        device.productId !== filter.productId\n                    ) {\n                        continue;\n                    }\n                    if (\n                        \"serialNumber\" in filter &&\n                        getSerialNumber(device) !== filter.serialNumber\n                    ) {\n                        continue;\n                    }\n\n                    try {\n                        findUsbAlternateInterface(device, filters);\n                        return true;\n                    } catch {\n                        continue;\n                    }\n                }\n                return false;\n            })\n            .map(\n                (device) =>\n                    new AdbDaemonWebUsbDevice(\n                        device,\n                        filters,\n                        this.#usbManager,\n                    ),\n            );\n    }\n}\n","export class AdbDaemonWebUsbDeviceWatcher {\n    #callback;\n    #usbManager;\n    constructor(callback, usb) {\n        this.#callback = callback;\n        this.#usbManager = usb;\n        this.#usbManager.addEventListener(\"connect\", this.#handleConnect);\n        this.#usbManager.addEventListener(\"disconnect\", this.#handleDisconnect);\n    }\n    dispose() {\n        this.#usbManager.removeEventListener(\"connect\", this.#handleConnect);\n        this.#usbManager.removeEventListener(\"disconnect\", this.#handleDisconnect);\n    }\n    #handleConnect = (e) => {\n        this.#callback(e.device.serialNumber);\n    };\n    #handleDisconnect = () => {\n        this.#callback();\n    };\n}\n//# sourceMappingURL=watcher.js.map","export class AdbDaemonWebUsbDeviceWatcher {\n    #callback: (newDeviceSerial?: string) => void;\n    #usbManager: USB;\n\n    constructor(callback: (newDeviceSerial?: string) => void, usb: USB) {\n        this.#callback = callback;\n        this.#usbManager = usb;\n\n        this.#usbManager.addEventListener(\"connect\", this.#handleConnect);\n        this.#usbManager.addEventListener(\"disconnect\", this.#handleDisconnect);\n    }\n\n    dispose(): void {\n        this.#usbManager.removeEventListener(\"connect\", this.#handleConnect);\n        this.#usbManager.removeEventListener(\n            \"disconnect\",\n            this.#handleDisconnect,\n        );\n    }\n\n    #handleConnect = (e: USBConnectionEvent) => {\n        this.#callback(e.device.serialNumber);\n    };\n\n    #handleDisconnect = () => {\n        this.#callback();\n    };\n}\n","// cspell: ignore RSASSA\nfunction openDatabase() {\n    return new Promise((resolve, reject) => {\n        const request = indexedDB.open(\"Tango\", 1);\n        request.onerror = () => {\n            reject(request.error);\n        };\n        request.onupgradeneeded = () => {\n            const db = request.result;\n            db.createObjectStore(\"Authentication\", { autoIncrement: true });\n        };\n        request.onsuccess = () => {\n            const db = request.result;\n            resolve(db);\n        };\n    });\n}\nasync function saveKey(key) {\n    const db = await openDatabase();\n    return new Promise((resolve, reject) => {\n        const transaction = db.transaction(\"Authentication\", \"readwrite\");\n        const store = transaction.objectStore(\"Authentication\");\n        const putRequest = store.add(key);\n        putRequest.onerror = () => {\n            reject(putRequest.error);\n        };\n        putRequest.onsuccess = () => {\n            resolve();\n        };\n        transaction.onerror = () => {\n            reject(transaction.error);\n        };\n        transaction.oncomplete = () => {\n            db.close();\n        };\n    });\n}\nasync function getAllKeys() {\n    const db = await openDatabase();\n    return new Promise((resolve, reject) => {\n        const transaction = db.transaction(\"Authentication\", \"readonly\");\n        const store = transaction.objectStore(\"Authentication\");\n        const getRequest = store.getAll();\n        getRequest.onerror = () => {\n            reject(getRequest.error);\n        };\n        getRequest.onsuccess = () => {\n            resolve(getRequest.result);\n        };\n        transaction.onerror = () => {\n            reject(transaction.error);\n        };\n        transaction.oncomplete = () => {\n            db.close();\n        };\n    });\n}\nexport default class AdbWebCredentialStore {\n    #appName;\n    constructor(appName = \"Tango\") {\n        this.#appName = appName;\n    }\n    /**\n     * Generates a RSA private key and store it into LocalStorage.\n     *\n     * Calling this method multiple times will overwrite the previous key.\n     *\n     * @returns The private key in PKCS #8 format.\n     */\n    async generateKey() {\n        const { privateKey: cryptoKey } = await crypto.subtle.generateKey({\n            name: \"RSASSA-PKCS1-v1_5\",\n            modulusLength: 2048,\n            // 65537\n            publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n            hash: \"SHA-1\",\n        }, true, [\"sign\", \"verify\"]);\n        const privateKey = new Uint8Array(await crypto.subtle.exportKey(\"pkcs8\", cryptoKey));\n        await saveKey(privateKey);\n        return {\n            buffer: privateKey,\n            name: `${this.#appName}@${globalThis.location.hostname}`,\n        };\n    }\n    /**\n     * Yields the stored RSA private key.\n     *\n     * This method returns a generator, so `for await...of...` loop should be used to read the key.\n     */\n    async *iterateKeys() {\n        for (const key of await getAllKeys()) {\n            yield {\n                buffer: key,\n                name: `${this.#appName}@${globalThis.location.hostname}`,\n            };\n        }\n    }\n}\n//# sourceMappingURL=index.js.map","// cspell: ignore RSASSA\n\nimport type { AdbCredentialStore, AdbPrivateKey } from \"@yume-chan/adb\";\n\nfunction openDatabase() {\n    return new Promise<IDBDatabase>((resolve, reject) => {\n        const request = indexedDB.open(\"Tango\", 1);\n        request.onerror = () => {\n            reject(request.error);\n        };\n        request.onupgradeneeded = () => {\n            const db = request.result;\n            db.createObjectStore(\"Authentication\", { autoIncrement: true });\n        };\n        request.onsuccess = () => {\n            const db = request.result;\n            resolve(db);\n        };\n    });\n}\n\nasync function saveKey(key: Uint8Array): Promise<void> {\n    const db = await openDatabase();\n\n    return new Promise((resolve, reject) => {\n        const transaction = db.transaction(\"Authentication\", \"readwrite\");\n        const store = transaction.objectStore(\"Authentication\");\n        const putRequest = store.add(key);\n        putRequest.onerror = () => {\n            reject(putRequest.error);\n        };\n        putRequest.onsuccess = () => {\n            resolve();\n        };\n        transaction.onerror = () => {\n            reject(transaction.error);\n        };\n        transaction.oncomplete = () => {\n            db.close();\n        };\n    });\n}\n\nasync function getAllKeys() {\n    const db = await openDatabase();\n\n    return new Promise<Uint8Array[]>((resolve, reject) => {\n        const transaction = db.transaction(\"Authentication\", \"readonly\");\n        const store = transaction.objectStore(\"Authentication\");\n        const getRequest = store.getAll();\n        getRequest.onerror = () => {\n            reject(getRequest.error);\n        };\n        getRequest.onsuccess = () => {\n            resolve(getRequest.result as Uint8Array[]);\n        };\n        transaction.onerror = () => {\n            reject(transaction.error);\n        };\n        transaction.oncomplete = () => {\n            db.close();\n        };\n    });\n}\n\nexport default class AdbWebCredentialStore implements AdbCredentialStore {\n    #appName: string;\n\n    constructor(appName = \"Tango\") {\n        this.#appName = appName;\n    }\n\n    /**\n     * Generates a RSA private key and store it into LocalStorage.\n     *\n     * Calling this method multiple times will overwrite the previous key.\n     *\n     * @returns The private key in PKCS #8 format.\n     */\n    async generateKey(): Promise<AdbPrivateKey> {\n        const { privateKey: cryptoKey } = await crypto.subtle.generateKey(\n            {\n                name: \"RSASSA-PKCS1-v1_5\",\n                modulusLength: 2048,\n                // 65537\n                publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n                hash: \"SHA-1\",\n            },\n            true,\n            [\"sign\", \"verify\"],\n        );\n\n        const privateKey = new Uint8Array(\n            await crypto.subtle.exportKey(\"pkcs8\", cryptoKey),\n        );\n        await saveKey(privateKey);\n\n        return {\n            buffer: privateKey,\n            name: `${this.#appName}@${globalThis.location.hostname}`,\n        };\n    }\n\n    /**\n     * Yields the stored RSA private key.\n     *\n     * This method returns a generator, so `for await...of...` loop should be used to read the key.\n     */\n    async *iterateKeys(): AsyncGenerator<AdbPrivateKey, void, void> {\n        for (const key of await getAllKeys()) {\n            yield {\n                buffer: key,\n                name: `${this.#appName}@${globalThis.location.hostname}`,\n            };\n        }\n    }\n}\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","pair_device","select_existing","get_autoconnect","connect_device","disconnect","set_autoconnect","monitor_usb","exploit_gabb","godo","install_app","send_to_device","$dGdCH","$aI8PJ","$jhyqS","$4uv4T","$aIHw7","$23OH0","konsole","document","querySelector","CredentialStore","default","console","log","navigator","usb","Manager","AdbDaemonWebUsbDeviceManager","BROWSER","alert","device","devices","connection","adb","onmonitor","dev_list","autoconnect_enabled","localStorage","requestDevice","filters","ADB_DEFAULT_DEVICE_FILTER","vendorId","productId","autoconnect","list_existing","getDevices","serial","filter","dev","length","close","error","raw","draw_device_list","val","dev_list_p","onmonitor_p","addEventListener","list_elem","innerHTML","opt","createElement","textContent","productName","manufacturerName","value","appendChild","connect","transport","AdbDaemonTransport","authenticate","credentialStore","Adb","getProp","mmu","res","stdout","matchAll","groups","uid","file","user","sync","write","filename","stream","dispose","session","split","rm","name","command","ignore_errors","silence_logs","process","subprocess","spawnAndWait","protocols","AdbSubprocessShellProtocol","stderr","msg","Date","toLocaleString","scrollTo","scrollHeight","$9f59c3e3ec39e929$export$83dac9bc96800be2","$9f59c3e3ec39e929$export$b4df074ec7ed7a36","$2lmjj","$fXuIk","$bwQFm","$jEctC","$3Ppgt","$6NYMu","$j4unN","$byTpg","classCode","subclassCode","protocolCode","$9f59c3e3ec39e929$var$Uint8ArrayExactReadable","position","constructor","data","readExactly","result","subarray","$9f59c3e3ec39e929$export$d762018b8d06af13","inEndpoint","outEndpoint","readable","writable","usbManager","closed1","duplex","DuplexStreamFactory","removeEventListener","handleUsbDisconnect","catch","unreachable","wrapReadable","ReadableStream","pull","controller","packet","enqueue","highWaterMark","zeroMask","packetSize","pipeFrom","createWritable","MaybeConsumable","WritableStream","chunk","transferOut","endpointNumber","EMPTY_UINT8_ARRAY","AdbPacketSerializeStream","transferIn","byteLength","buffer","Uint8Array","AdbPacketHeader","deserialize","magic","payloadLength","payload","isErrorName","Promise","resolve","setTimeout","closed","getSerialNumber","opened","open","configuration","interface_","alternate","findUsbAlternateInterface","configurationValue","selectConfiguration","claimed","claimInterface","interfaceNumber","alternateSetting","selectAlternateInterface","$9f59c3e3ec39e929$var$findUsbEndpoints","endpoints","TypeError","endpoint","direction","$34521237b2ec6ce9$export$7a062b26cb22e9be","$k61Wg","$koQVx","$5WSZn","$gequt","$5jHg5","$aBc50","$liel6","$beA73","$755W6","maxPayloadSize","banner","disconnected","clientFeatures","deviceFeatures","features","power","reverse","tcpip","AdbSubprocess","AdbPower","AdbReverseCommand","AdbTcpIpCommand","canUseFeature","feature","includes","createSocket","service","createSocketAndWait","socket","pipeThrough","TextDecoderStream","ConcatStringStream","key","spawnAndWaitLegacy","trim","filenames","options","args","recursive","push","force","Array","isArray","escapeArg","AdbSync","framebuffer","BufferedReadableStream","Consumable","BufferCombiner","DistributionStream","PushReadableStream","AbortController","TransformStream","StructDeserializeStream","WrapWritableStream","$15761f3c464dcaca$export$1dec6b9a18b23f58","$9LJSP","$bJSM1","$fnPEF","transform","sourceStreamController","buffered","StructEmptyError","cancel","reason","abort","ExactReadableEndedError","Struct","SyncPromise","decodeUtf8","encodeUtf8","placeholder","StructFieldDefinition","StructFieldValue","StructDefaultOptions","isStructValueInit","STRUCT_VALUE_SYMBOL","StructValue","$035d11ab306c6c89$export$804794de18b9cab0","TValue","TOmitInitKey","$312341718db575d7$export$391b04ee9b3e1655","definition","struct","hasCustomAccessors","prototype","getSize","$60c6f49fee635812$export$d519eb5cbd68a82e","littleEndian","$5192e50163bfdc4f$export$a89eeb2712a9e4e1","setPrototypeOf","$d51ffc090449bd90$export$bbd6643020302418","$d51ffc090449bd90$export$82df0b712ff78769","$d51ffc090449bd90$export$f66d5fb339033b6","Symbol","fieldValues","create","fieldValue","$71cc184b366eacb0$export$7af6964ac5489517","$71cc184b366eacb0$export$eabc71f011df675a","$70dme","$iissA","$8j8Qa","$6yg6p","$ioobU","$7M0oO","$fiklF","$drcSV","$71cc184b366eacb0$export$40dad8b579eb5f98","message","$71cc184b366eacb0$export$4217ee4abf29bfe6","TFields","TExtra","TInit","TDeserializeResult","size","fields","field","nameString","String","concat","other","defineProperties","getOwnPropertyDescriptors","type","typeScriptType","NumberFieldDefinition","int8","NumberFieldVariant","Int8","uint8","Uint8","int16","Int16","uint16","Uint16","int32","Int32","uint32","Uint32","BigIntFieldDefinition","int64","BigIntFieldVariant","Int64","uint64","Uint64","FixedLengthBufferLikeFieldDefinition","VariableLengthBufferLikeFieldDefinition","uint8Array","Uint8ArrayBufferFieldConverter","Instance","string","StringBufferFieldConverter","extra","postDeserialize","callback","structValue","promise","startPosition","then","override","undefined","valueOrPromise","serialize","output","entries","structSize","fieldsInfo","dataView","DataView","byteOffset","offset","$4c5268a801551813$export$6f292d4960313241","reject","$4c5268a801551813$var$RejectedSyncPromise","$4c5268a801551813$var$ResolvedSyncPromise","$4c5268a801551813$var$PendingSyncPromise","try","executor","onfulfilled","onrejected","$d63d3bb5814df626$export$7f44118adc318a0c","$d63d3bb5814df626$export$47590baf50e650b4","$duafd","$jzfEx","$hU3mS","$4dyEt","TTypeScriptType","getInt64","setInt64","getUint64","setUint64","variant","typescriptType","$d63d3bb5814df626$export$356b59f789fa5206","array","getInt16","getInt32","setInt64BigEndian","setInt64LittleEndian","getInt8","getUint16","getUint32","getUint32LittleEndian","setUint32LittleEndian","getUint64BigEndian","getUint64LittleEndian","$ad12f7c62572a109$export$7111ea4c3e27a959","$33eb2502b7dced81$export$20d487fff2ae6963","$9d160602087c97c1$export$69825c7adcc820c6","BigInt","$9d160602087c97c1$export$e2d026b78208efb4","Number","$9d160602087c97c1$export$cb00adb52e928ee5","$9d160602087c97c1$export$8532a5209571c04a","$c16eeb37ab2cbf45$export$56c0324b6d39bf6e","$d1245c7d15e31db4$export$89b158b9ac91fb05","$c6e880d99c088db3$export$93a5511f94f97356","$c6e880d99c088db3$export$44118f6ad20a04bd","$c6e880d99c088db3$export$c60a33cd4171510b","$e3ed6d8482796099$export$a43c509a1df9dbdf","$e3ed6d8482796099$export$71480404fe2732b3","$e3ed6d8482796099$export$59a2dbf579ff9568","$e3ed6d8482796099$export$20f71c4c8b0f96c3","$de25f57275dc3b5f$export$919ddce6d1c56738","$de25f57275dc3b5f$export$df462518ae175b8f","$de25f57275dc3b5f$export$ff4d98424a9fd4b9","$de25f57275dc3b5f$export$5fed7215206b866f","$de25f57275dc3b5f$export$3f021200daa961db","$6Savq","$de25f57275dc3b5f$export$44ecb42ac2345560","toBuffer","toValue","converter","getDeserializeSize","$500fef713084bd27$export$c7187bbd1a7a9244","$500fef713084bd27$export$8f647c2204da8484","$500fef713084bd27$export$72118b85b055afd","TextEncoder","$500fef713084bd27$var$TextEncoder","TextDecoder","$500fef713084bd27$var$TextDecoder","$500fef713084bd27$var$SharedEncoder","$500fef713084bd27$var$SharedDecoder","input","encode","decode","$5a8d5361bdac236c$export$f6ef9f85bb06aeff","BufferLikeFieldDefinition","$9c87caa7f7c09f42$export$bd5db95fcc20ece9","lengthField","parseInt","lengthFieldRadix","$9c87caa7f7c09f42$export$d3219f0279a7fe4e","BufferLikeFieldValue","lengthFieldValue","originalValue","$9c87caa7f7c09f42$export$4ea2368eb6ab5b42","bufferValue","toString","$b2285239387cc49c$export$6eb6015f2bce1d68","$b2285239387cc49c$export$e8cfbf1c68de676b","$eRgHk","$4smoc","$gBDJc","$hXg0k","$h4MAN","signed","setUint8","setInt8","setUint16","setInt16","setUint32","setInt32","$b2285239387cc49c$export$1365bb43729bbdfd","$88be62932bb485b5$export$4bc5733dbde37c71","$88be62932bb485b5$var$NOOP","reader","getReader","done","read","initial","index","release","abortSignal","releaseLock","$b3311298c0c6568c$export$bcc01621d2cdbb44","$aHKds","source","strategy","waterMarkLow","abortController","start","signal","aborted","desiredSize","PromiseResolver","AsyncOperationManager","delay","$154c42d422606d92$export$10a4a5aeec48d07","startId","pendingResolvers","Map","nextId","add","resolver","getResolver","has","delete","$7cb1c50efa1262d9$export$b523a6f1f39bfd1e","_this","_state","_resolve","_reject","_promise","$43bf8b277380453a$export$1391212d75b2ee65","time","$4f46778d30aae90e$export$48f7e099c149af88","$4f46778d30aae90e$export$5d3e1e5268af5f76","$4f46778d30aae90e$export$826849241f7970f8","$4f46778d30aae90e$export$d102341634899398","$4f46778d30aae90e$var$Global","$ea15df33799cd8f3$export$b6b7c3423a277d10","bind","finally","$459bb56e0b905665$export$888324e445e7ab42","$cilb9","consumed","createTask","consume","tryConsume","run","writer","consumable","sink","wrappedStrategy","wrappedController","$8f3798290ba6e406$export$f7292ab7796be73c","$8f3798290ba6e406$var$console","$813b1fd2092db7cf$export$b30c524a58e8458c","$813b1fd2092db7cf$export$feca7eb4e486f5cf","$5Ywqs","available","end","flush","combine","combiner","$e4db6e59fbae8999$export$544160f784d9074","getValue","UnwrapStream","$864b8946dafa2700$export$98fb3f973b596bf2","$cSu3L","$864b8946dafa2700$var$NOOP","writableClosed","WrapReadableStream","getWriter","$9601d8647e507a4c$export$85a7b9d088379e9e","wrapper","$ed9f1ac4caa555e8$export$a47f15ea2f3a718a","$ed9f1ac4caa555e8$var$Global","TextEncoderStream","$2c99bb95550a3c12$export$d407da7ebfa84417","pair","pipe","pipeTo","$a5363ea64eecd913$export$e8da4e75be156fae","$1QeNb","BufferedTransformStream","$4747d098e697958e$export$98b7c608564c82c4","$4747d098e697958e$var$getWrappedWritableStream","bePipedThroughFrom","transformer","$21c805dd93e00cd7$export$6c55dba0cc5f72fb","$aGQPd","AutoDisposable","$7c86cd92403ce500$export$a22a94f7d5cef8d5","addDisposable","disposable","$527d9ad6cf7afd05$export$4ed6c7c560c63868","$527d9ad6cf7afd05$var$Version","$527d9ad6cf7afd05$export$4c5fa6579699b052","$527d9ad6cf7afd05$export$d0bda24c79a1d603","$527d9ad6cf7afd05$export$31b42747346031c6","$527d9ad6cf7afd05$export$4fe684c7fc4bab42","version","$527d9ad6cf7afd05$export$b1ac6f66a424282e","$454d062a32aa0607$export$9b4dc8cf402dd991","$2TOFC","AdbCommandBase","reboot","mode","bootloader","fastboot","recovery","sideload","qualcommEdlMode","powerOff","powerButton","longPress","samsungOdin","$bd12809a72d921e3$export$f48b52846b274f79","$32bmk","$gtlgZ","$bd12809a72d921e3$var$AdbReverseStringResponse","$bd12809a72d921e3$export$12a5efc419918650","$bd12809a72d921e3$export$ae7a90ef18b5896a","$bd12809a72d921e3$var$AdbReverseErrorResponse","content","$bd12809a72d921e3$var$OKAY","createBufferedStream","sendRequest","response","sequenceEqual","list","line","map","deviceSerial","localName","remoteName","addExternal","deviceAddress","localAddress","startsWith","hexToNumber","port","$bd12809a72d921e3$var$decimalToNumber","byte","handler","addReverseTunnel","removeReverseTunnel","remove","removeAll","clearReverseTunnels","clear","AutoResetEvent","calculateBase64EncodedLength","encodeBase64","write4HexDigits","NOOP","$448ba6c1507a4b6f$export$6c7050fcdf3fbd6b","initialSet","wait","notifyOne","pop","item","$1b16e9917870169f$export$9e6dcb9430409adb","$1b16e9917870169f$export$8fb536984ec8b4d7","$1b16e9917870169f$var$charToIndex","$1b16e9917870169f$var$indexToChar","$1b16e9917870169f$var$addRange","charCodeStart","charCodeAt","charCodeEnd","charCode","inputLength","remainder","paddingLength","outputLength","$1b16e9917870169f$var$encodeForward","$1b16e9917870169f$var$encodeBackward","inputIndex","outputIndex","x","y","z","$235a5eb6b9daa8b2$export$d57f2bacc26b4249","i","$235a5eb6b9daa8b2$var$hexCharToNumber","char","$235a5eb6b9daa8b2$export$6109e2907f86231a","digit","$b9e430d7f1e7a460$export$5702a91a6f42969f","$b9e430d7f1e7a460$export$565e9d9bd6b6e0d4","join","$bfdfdb21e3c32026$export$d0a07e60ae428313","a","b","$3df04856ab447e80$export$7a6597f9fb12f14e","$co9iz","$3df04856ab447e80$var$DEFAULT_OPTIONS","AdbSubprocessNoneProtocol","Constructor","isSupported","shell","spawn","exitCode","all","exit","$904ef069d7a99ac4$export$d83482397cfbf8db","pty","stdin","resize","kill","$18032f121c93c39a$export$6810084fa64eee3f","AdbShellProtocolId","$18032f121c93c39a$export$4e6123448c357dfc","$ebpYL","$drR7i","$18032f121c93c39a$var$AdbShellProtocolPacket","AdbFeature","ShellV2","stdoutController","stderrController","Exit","Stdout","Stderr","Stdin","rows","cols","WindowSizeChange","$9ca6ffdb312d84ef$export$e05918f35b7c5680","$82dd03c0c08ee971$export$3470675a0ff86e89","base","found","indexOf","substring","$72b28df151d1adcb$export$1579339099549b64","$j6zCo","$h4v6J","$9for9","$72b28df151d1adcb$export$9f58ebc0d39b84a0","AdbSyncLstatResponse","$72b28df151d1adcb$export$f3f12bd93e4611be","AdbSyncStatResponse","$72b28df151d1adcb$export$17741d8e2b8c93","path","locked","lock","adbSyncWriteRequest","AdbSyncRequestId","ListV2","adbSyncReadResponses","AdbSyncResponseId","Entry2","AdbSyncStatErrorCode","SUCCESS","$72b28df151d1adcb$export$b83665dbb067898b","List","Entry","v2","mtime","permission","$de8a34e0882318f6$export$5322f80b7c65656e","$de8a34e0882318f6$export$9fbb2f6d9716c879","adbSyncEncodeId","Send","SendV2","Lstat","Stat","LstatV2","Data","Done","Receive","$de8a34e0882318f6$export$31b0bdfb146abfd4","arg","$c6daf0b886b3d547$export$e5f795408780cc7c","$c6daf0b886b3d547$export$cb117bc133363ddb","$c6daf0b886b3d547$export$2cf93447a6456640","$c6daf0b886b3d547$export$59ff2512fa71dc09","$c6daf0b886b3d547$var$encodeAsciiUnchecked","Lstat2","Ok","Fail","$c6daf0b886b3d547$export$ad50f5a23743360b","$c6daf0b886b3d547$export$bf28540d1ad84211","object","$6bb87868c5b7aa85$export$6b5fe9b0a9be762e","$6bb87868c5b7aa85$export$4091d821a4f90167","$6bb87868c5b7aa85$export$e93cb33d37e1d1a3","$6bb87868c5b7aa85$export$32343a08ff41df91","$6bb87868c5b7aa85$export$2241dc001bbd3624","$6bb87868c5b7aa85$export$9b51c155441928f2","LinuxFileType","adbSyncReadResponse","$484792ce1371d406$export$b2722bc5a41c81be","$484792ce1371d406$export$c364285c7f62b15f","$484792ce1371d406$export$e4f995c0cb69297d","$7aa3cc788c769a7c$export$68c559ba4f0f11a4","AdbSyncSendV2Flags","$7aa3cc788c769a7c$export$b4c20861ad50fe86","$b5TnZ","$7aa3cc788c769a7c$export$de38b4566403a6ea","$7aa3cc788c769a7c$var$pipeFileData","$7aa3cc788c769a7c$export$97096e9859e22356","File","now","pathAndMode","$7aa3cc788c769a7c$export$36fe31421b981962","$7aa3cc788c769a7c$export$65eec66d09c9751b","dryRun","flags","None","DryRun","$2b75b983ed1aaf9f$export$5ab9b68fbce86ef6","$5SRHv","$2b75b983ed1aaf9f$export$7224dd8d1cb774a1","bufferSize","$7b76badbaf65e5be$export$c7d21bab4b5606f3","$9QwYX","$6cK2h","$awO9J","$3JkOU","_adb","_socket","supportsStat","supportsListV2","fixedPushMkdir","supportsSendReceiveV2","needPushMkdirWorkaround","AdbSyncSocket","StatV2","FixedPushMkdir","SendReceiveV2","lstat","adbSyncLstat","stat","adbSyncStat","isDirectory","opendir","adbSyncOpenDir","readdir","results","entry","adbSyncPull","$7b76badbaf65e5be$export$7f7b8152cc673abe","lastIndexOf","adbSyncPush","lockSocket","$f80666ec7843035b$export$9d7ae67b2874bc2a","getListenAddresses","serviceListenAddresses","servicePort","persistPort","setPort","disable","$87e757b1771fca0a$export$23f5f7103a6c0e54","AdbBannerKey","$87e757b1771fca0a$export$25d495fe2ebd5375","parse","product","model","pieces","prop","props","keyValue","Product","Model","Device","Features","$c5b35711f7a6189a$export$485fb103785b43ab","$c5b35711f7a6189a$export$e4e9c85a581bb39f","AdbAuthType","$c5b35711f7a6189a$export$2e65721f4f5c7298","$2kccq","$7qLAG","getNextRequest","iterateKeys","arg0","Token","signature","rsaSign","AdbCommand","Auth","Signature","arg1","privateKey","generateKey","publicKeyLength","adbGetPublicKeySize","publicKeyBase64Length","nameBuffer","publicKeyBuffer","adbGeneratePublicKey","PublicKey","authenticators","authenticator","next","return","$568fe0a3a1a6b938$export$847074fb5f64c4e1","$568fe0a3a1a6b938$export$8699f7714545d1a1","$568fe0a3a1a6b938$export$97e3cdd046452c80","$568fe0a3a1a6b938$export$19ed8bf0faa0c9c","$568fe0a3a1a6b938$export$1fd10df48a397f51","$568fe0a3a1a6b938$export$5c1dc4cd37ff603","$568fe0a3a1a6b938$var$nonNegativeMod","m","d","r","outputType","outputView","outputOffset","$568fe0a3a1a6b938$var$ModulusLengthInBytes","n0inv","$568fe0a3a1a6b938$export$f085ad9052472793","NaN","Math","floor","$568fe0a3a1a6b938$export$1025a137f1840fa1","padded","fillLength","$568fe0a3a1a6b938$export$a871ce58ee56241a","exponent","modulus","asUintN","$1b4ed9515c9d7ed1$export$5d836449dc8c8870","$1b4ed9515c9d7ed1$export$96ac7b5be108186d","$1b4ed9515c9d7ed1$export$b0943743069d64df","$1b4ed9515c9d7ed1$export$4f57c42a69edaa4d","reduce","headerBuffer","$8dd872409796e78b$export$d634de534db06769","$1PmPk","$5OCzC","$5BaNe","initialDelayedAckBytes","Close","Okay","Open","Write","preventCancel","preserveConnection","ackBytes","Infinity","remoteId","availableWriteBytes","ack","sendPacket","localId","endsWith","AdbDaemonSocketController","dispatcher","localCreated","handled","promises","readTimeLimit","race","appendNullToServiceString","initializer","address","checksum","calculateChecksum","from","values","$4138c7bd76e67256$export$f061bb53e3f17c7c","chunkSize","$4138c7bd76e67256$export$8f6ff11549e9fecf","bytes","$7cdfc506af36bd48$export$7d98e1b80c4a2dc2","$bFpy9","$gYm23","$cb2uE","$7cdfc506af36bd48$export$a9b40d5d0c7f809b","Cmd","Abb","AbbExec","DelayedAck","ADB_DEFAULT_AUTHENTICATORS","authProcessor","AdbAuthenticationProcessor","Connect","min","actualFeatures","slice","splice","protocolVersion","AdbBanner","AdbPacketDispatcher","random","AdbServerClient","$67qk3","$btVdk","$d9e611074e4605d2$var$OKAY","$d9e611074e4605d2$var$FAIL","$d9e611074e4605d2$var$AdbServerStream","readString","writeString","encoded","readOkay","$d9e611074e4605d2$export$21bea6a433f41b7c","VERSION","connector","wireless","WirelessCommands","mDns","MDnsCommands","createConnection","request","$d9e611074e4605d2$export$76ed3709e60def45","getVersion","validateVersion","killServer","getServerFeatures","parseDeviceList","transportId","parts","Boolean","status","authenticating","trackDevices","formatDeviceService","reconnectDevice","getDeviceFeatures","createDeviceConnection","featuresString","switchService","waitFor","state","createTransport","info","find","AdbServerTransport","signals","abortPromise","NetworkError","UnauthorizedError","AlreadyConnectedError","client","password","check","getServices","$85bec8a2f163a989$export$7c1775a424a7d7ad","$85bec8a2f163a989$export$7c2347b5f1ca1982","unref","$86add9489fa853fa$export$9c7d51c3d5b5355e","$86add9489fa853fa$export$a36c2d3c1065d369","configurations","interfaces","alternates","$86add9489fa853fa$var$alternateMatchesFilter","some","interfaceClass","interfaceSubclass","interfaceProtocol","$86add9489fa853fa$var$padNumber","padStart","$86add9489fa853fa$export$94caf855bf00ca69","serialNumber","$7cc4dd8e8afc9fca$export$b13bb639ae0909dd","AdbDaemonWebUsbDevice","$e09a507438314e34$var$openDatabase","indexedDB","onerror","onupgradeneeded","db","createObjectStore","autoIncrement","onsuccess","$e09a507438314e34$var$saveKey","transaction","putRequest","store","objectStore","oncomplete","$e09a507438314e34$var$getAllKeys","getRequest","getAll","$e09a507438314e34$export$2e2bcd8739ae039","appName","cryptoKey","crypto","subtle","modulusLength","publicExponent","hash","exportKey","location","hostname"],"version":3,"file":"index.44060ccf.js.map"}